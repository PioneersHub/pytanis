{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\u200b","text":"<p>Pytanis includes a Pretalx client and all the tooling you need for conferences using Pretalx, from handling the initial call for papers to creating the final program.</p> <p>Trivia: The name Pytanis is a reference to Prytanis using the typical py prefix of Python tools. Prytanis was the name given  to the leading members of the government of a city (polis) in ancient Greece.  Offices that used this title usually had responsibility for presiding over councils of some kind, which met in the Prytaneion. Romani ite domum!</p>"},{"location":"#features","title":"Features","text":"<ul> <li> simple configuration management with a config folder in your home directory, just like many other tools do</li> <li> easily access Google Sheets, potentially filled by some Google Forms, and download sheets as data frames</li> <li> easy to use Pretalx client that returns proper Python objects thanks to the power of pydantic</li> <li> simple e-mail clients for batch mails, e.g. to your reviewers, via Mailgun and HelpDesk</li> <li> awesome documentation with best practices for the program committee of any community-based conference</li> <li> tools to assign proposals to reviewers based on constraints like preferences</li> <li> tools to support the final selection process of proposals</li> <li> tools to support the creation of the final program schedule</li> </ul>"},{"location":"#license","title":"License","text":"<p>Pytanis is distributed under the terms of the MIT license.</p>"},{"location":"#navigation","title":"Navigation","text":"<p>Documentation for specific <code>MAJOR.MINOR</code> versions can be chosen by using the dropdown on the top of every page. The <code>dev</code> version reflects changes that have not yet been released.</p> <p>Also, desktop readers can use special keyboard shortcuts:</p> Keys Action <ul><li>, (comma)</li><li>p</li></ul> Navigate to the \"previous\" page <ul><li>. (period)</li><li>n</li></ul> Navigate to the \"next\" page <ul><li>/</li><li>s</li></ul> Display the search modal"},{"location":"authors/","title":"Contributors","text":"<ul> <li>Florian Wilhelm</li> <li>Alexander Hendorf</li> <li>Paula Gonz\u00e1lez Avalos</li> <li>Christopher Schultz</li> <li>Theodore Meynard</li> <li>Nils Finke</li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#version-091-2025-06-21","title":"Version 0.9.1 (2025-06-21)","text":""},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Authentication: Fixed authentication issue where HeaderApiKey was not adding the required \"Token \" prefix for Pretalx API authorization headers</li> <li>Type hints: Added support for dict type in params parameter alongside QueryParams for better flexibility</li> </ul>"},{"location":"changelog/#improvements","title":"Improvements","text":"<ul> <li>Test configuration: Externalized test event slug to <code>tests/test_config.toml</code> configuration file</li> <li>Dependencies: Removed unused httpx-auth dependency since we now handle authentication directly</li> </ul>"},{"location":"changelog/#version-090-2025-06-21","title":"Version 0.9.0 (2025-06-21)","text":""},{"location":"changelog/#first-release-compatible-with-pretalx-versioned-api-v1","title":"\ud83c\udf89 First Release Compatible with Pretalx Versioned API v1","text":"<p>This is the first release fully compatible with the new Pretalx versioned API v1 introduced in June 2025.</p>"},{"location":"changelog/#major-features","title":"Major Features","text":"<ul> <li>Storage abstraction layer: Support for multiple storage backends (local CSV/Excel files, Google Sheets)</li> <li>Communication abstraction layer: Unified interface for email (Mailgun) and ticket (HelpDesk) providers</li> <li>Factory functions: Simplified client creation with <code>get_storage_client()</code> and <code>get_mail_client()</code></li> <li>Optional dependencies: Install only what you need with <code>pytanis[google]</code>, <code>pytanis[helpdesk]</code>, <code>pytanis[mailgun]</code></li> </ul>"},{"location":"changelog/#pretalx-api-improvements","title":"Pretalx API Improvements","text":"<ul> <li>API v1 Compatibility: Full support for Pretalx versioned API v1 with proper <code>expand</code> parameter usage</li> <li>Backward compatibility: Transparent handling of API changes where IDs replaced nested objects</li> <li>Performance optimization: Cache pre-population reduces API calls by 50-75x for bulk operations</li> <li>Redirect handling: Automatic handling of API redirects with trailing slashes</li> <li>New API methods: <code>submission_types()</code>, <code>tracks()</code> for accessing submission metadata</li> <li>SimpleTalk model: Export talks in simplified JSON format for easier processing</li> <li>API compatibility: Event.urls field now optional to support latest API versions</li> </ul>"},{"location":"changelog/#testing-quality","title":"Testing &amp; Quality","text":"<ul> <li>Comprehensive integration test framework with interactive CLI</li> <li>Structured logging with <code>structlog</code> for better test output visibility</li> <li>Support for multiple Pretalx API versions</li> <li>Improved test coverage and documentation</li> </ul>"},{"location":"changelog/#bug-fixes_1","title":"Bug Fixes","text":"<ul> <li>Fixed 401 Unauthorized errors when fetching individual resources by using proper API expansion</li> <li>Fixed redirect issues with missing trailing slashes in API endpoints</li> <li>Fixed circular import issues in Google storage adapter</li> </ul>"},{"location":"changelog/#version-08-2024-12-30","title":"Version 0.8 (2024-12-30)","text":"<ul> <li>Added support for Mailgun, thanks to Nils Mohr</li> <li>Added new notebook for calculating submission statistics, thanks to Nils Mohr</li> <li>Added devcontainer for easier development, thanks to Nils Mohr</li> <li>Updated all dependencies, added support for Python 3.13</li> <li>Added configurable Pretalx API version support via <code>api_version</code> config parameter (defaults to \"v1\")</li> </ul>"},{"location":"changelog/#version-072-2024-06-18","title":"Version 0.7.2 (2024-06-18)","text":"<ul> <li>Matplotlib replaced with webcolors, thanks Alexander Hendorf</li> <li>Updated ruff, pre-commit, mypy etc.</li> </ul>"},{"location":"changelog/#version-071-2024-01-29","title":"Version 0.7.1 (2024-01-29)","text":"<ul> <li>Pin gspread to &lt;6.0 because API was broken</li> </ul>"},{"location":"changelog/#version-07-2024-01-01","title":"Version 0.7 (2024-01-01)","text":"<ul> <li>Switched for reproducability to hatch-pip-compile</li> <li>A few fixes to make mypy happy</li> <li>Some more pydantic v2 deprecations migrated to new API</li> <li>Renamed <code>GSheetClient</code> to <code>GSheetsClient</code></li> <li>Added Gspread service user authentication</li> </ul>"},{"location":"changelog/#version-061-2023-12-10","title":"Version 0.6.1 (2023-12-10)","text":"<ul> <li>Fixed a deadlock problem in <code>utils.throttle</code></li> </ul>"},{"location":"changelog/#version-06-2023-12-04","title":"Version 0.6 (2023-12-04)","text":"<ul> <li>Migrate to Pydantic v2</li> <li>Require mininum Python version of 3.10</li> </ul>"},{"location":"changelog/#version-05-2023-04-10","title":"Version 0.5 (2023-04-10)","text":"<ul> <li>Change the start/end time of a slot to a datetime</li> </ul>"},{"location":"changelog/#version-041-2023-03-25","title":"Version 0.4.1 (2023-03-25)","text":"<ul> <li>Additional documentation about the CfP and some minor fixes</li> </ul>"},{"location":"changelog/#version-04-2023-03-10","title":"Version 0.4 (2023-03-10)","text":"<ul> <li>More functionality regarding the proposal selection process like <code>mark_rows</code></li> <li>Pretalx submissions states are now proper Enums.</li> <li><code>GSheetClient.save_df_as_gsheet</code> also applies some default <code>BasicFormatter</code> for nicer headlines etc.</li> <li>Added some MIP helpers (<code>highs</code>) to support the scheduling process</li> <li>Extended the documentation quite a bit</li> </ul>"},{"location":"changelog/#version-03-2023-02-17","title":"Version 0.3 (2023-02-17)","text":"<ul> <li>Allow creating a worksheet from <code>GSheetClient</code></li> <li>Make <code>get_cfg</code> importable from <code>pytanis</code></li> <li>Fix bug in <code>PretalxClient</code> that returned wrong number of results if a list was passed as <code>params</code> in conjunction with   pagination.</li> </ul>"},{"location":"changelog/#version-02-2023-02-11","title":"Version 0.2 (2023-02-11)","text":"<ul> <li>have a progress bar for long-running commands when possible</li> <li>switched to gspread for handling the low-level GoogleAPI</li> <li>using gspread-dataframe for converting a worksheet into a dataframe</li> <li>timeout of 60s for PretalxAPI as it is really slow, which caused a lot of timeout errors</li> <li>rename <code>*API</code> to <code>*Client</code> as it's rather a client for an API</li> <li>moved some functionality from <code>review</code> to <code>pretalx.utils</code></li> <li><code>GSheetClient</code> allows now uploading dataframes as Google Sheets</li> <li>an awesome logo created by Paula Gonz\u00e1lez Avalos</li> <li>way more usage documentation</li> </ul>"},{"location":"changelog/#version-011-2023-01-16","title":"Version 0.1.1 (2023-01-16)","text":"<ul> <li>fix typo <code>sent</code> -&gt; <code>send</code> in MailClient</li> </ul>"},{"location":"changelog/#version-01-2023-01-15","title":"Version 0.1 (2023-01-15)","text":"<ul> <li>First alpha version that can be used</li> <li>Google client to retrieve Google Sheets implemented</li> <li>Pretalx client implement</li> <li>A very basic HelpDesk client (minimal functionality) implemented</li> <li>Basic e-mail client implemented to send mails via HelpDesk</li> <li>Central configuration management for secrets and credentials implemented</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>Welcome to the contributor guide of Pytanis.</p> <p>This document focuses on getting any potential contributor familiarized with the development processes, but other kinds of contributions are also appreciated.</p> <p>If you are new to using git or have never collaborated on a project previously, please have a look at contribution-guide.org. Other resources are also listed in the excellent guide created by Freecodecamp<sup>1</sup>.</p> <p>Please note: all users and contributors are expected to be open, considerate, reasonable, and respectful. When in doubt, Python Software Foundation's Code of Conduct is a good reference in terms of behavior guidelines.</p>"},{"location":"contributing/#issue-reports","title":"Issue Reports","text":"<p>If you experience bugs or general issues with Pytanis, please have a look at the issue tracker. If you don't see anything useful there, please feel free to file an issue report.</p> <p>Tip</p> <p>Please don't forget to include the closed issues in your search. Sometimes a solution will have been reported already and the problem is considered solved.</p> <p>New issue reports should include information about your programming environment (e.g., operating system, Python version) and steps to reproduce the problem. Please try also to simplify the reproduction steps to a very minimal example that still illustrates the problem you are facing. By removing other factors, you help us to identify the root cause of the issue.</p>"},{"location":"contributing/#documentation-improvements","title":"Documentation improvements","text":"<p>You can contribute to the documentation of Pytanis by making them more readable and coherent, or by adding missing information and correcting mistakes.</p> <p>The documentation uses mkdocs as its main documentation compiler. This means that the docs are kept in the same repository as the project code, and that any documentation update is done in the same way was a code contribution.</p> <p>Tip</p> <p>Please note that the GitHub web interface provides a quick way of   propose changes in <code>Pytanis</code>' files. While this mechanism can   be tricky for normal code contributions, it works perfectly fine for   contributing to the docs, and can be quite handy.</p> <p>If you are interested in trying this method out, please navigate to   the <code>docs</code> folder in the source repository, find which file you   would like to propose changes and click in the little pencil icon at the   top to open GitHub's code editor. Once you finish editing the file,   please write a message in the form at the bottom of the page describing   which changes have you made and what are the motivations behind them and   submit your proposal.</p> <p>When working on documentation changes in your local machine, you can build and serve them using hatch with <code>hatch run docs:build</code> and <code>hatch run docs:serve</code>, respectively.</p>"},{"location":"contributing/#code-contributions","title":"Code Contributions","text":""},{"location":"contributing/#submit-an-issue","title":"Submit an issue","text":"<p>Before you work on any non-trivial code contribution it's best to first create a report in the issue tracker to start a discussion on the subject. This often provides additional considerations and avoids unnecessary work.</p>"},{"location":"contributing/#clone-the-repository","title":"Clone the repository","text":"<ol> <li> <p>Create a user account on GitHub if you do not already have one.</p> </li> <li> <p>Fork the project repository: click on the Fork button near the top of the    page. This creates a copy of the code under your account on GitHub.</p> </li> <li> <p>Clone this copy to your local disk:    <pre><code>git clone git@github.com:YourLogin/pytanis.git\ncd pytanis\n</code></pre></p> </li> <li> <p>Make sure hatch is installed using pipx:    <pre><code>pipx install hatch\n</code></pre></p> </li> <li> <p>[only once] install pre-commit hooks in the default environment with:    <pre><code>hatch run pre-commit install\n</code></pre></p> </li> </ol>"},{"location":"contributing/#implement-your-changes","title":"Implement your changes","text":"<ol> <li> <p>Create a branch to hold your changes:    <pre><code>git checkout -b my-feature\n</code></pre>    and start making changes. Never work on the main branch!</p> </li> <li> <p>Start your work on this branch. Don't forget to add docstrings in Google style    to new functions, modules and classes, especially if they are part of public APIs.</p> </li> <li> <p>Add yourself to the list of contributors in <code>AUTHORS.md</code>.</p> </li> <li> <p>When you\u2019re done editing, do:    <pre><code>git add &lt;MODIFIED FILES&gt;\ngit commit\n</code></pre>    to record your changes in git.        Please make sure to see the validation messages from pre-commit and fix    any eventual issues.    This should automatically use flake8/black to check/fix the code style    in a way that is compatible with the project.</p> <p>Info</p> <p>Don't forget to add unit tests and documentation in case your contribution adds a feature and is not just a bugfix.</p> <p>Moreover, writing an descriptive commit message is highly recommended. In case of doubt, you can check the commit history with: <pre><code>git log --graph --decorate --pretty=oneline --abbrev-commit --all\n</code></pre> to look for recurring communication patterns.</p> </li> <li> <p>Please check that your changes don't break any unit tests with <code>hatch run cov</code> or    <code>hatch run no-cov</code> to run the unitest with or without coverage reports, respectively.</p> </li> <li>For code hygiene, execute <code>hatch run lint:all</code> in order to run flake8, isort, black, mypy, etc.</li> <li>If your changes affect the Pretalx integration, run the integration tests to ensure compatibility:    <pre><code>hatch run integration\n# or with your credentials:\nhatch run integration --token YOUR_TOKEN --event pyconde-pydata-2025\n</code></pre>    See the Testing documentation for more details.</li> </ol>"},{"location":"contributing/#pre-push-verification","title":"Pre-push verification","text":"<p>Before pushing your changes, our pre-push hooks will automatically run to ensure code quality:</p> <ol> <li>Automatic checks: When you run <code>git push</code>, the following checks will run automatically:</li> <li>Pre-commit hooks (formatting, linting, security)</li> <li>Full linting suite (<code>hatch run lint:all</code>)</li> <li> <p>Test suite (<code>hatch run no-cov</code>)</p> </li> <li> <p>Security checks: The following security tools are integrated:</p> </li> <li>Bandit: Scans for common security issues in Python code</li> <li>detect-private-key: Prevents committing private keys</li> <li> <p>Additional security-focused pre-commit hooks</p> </li> <li> <p>Manual verification: You can run these checks manually before pushing:    <pre><code># Run all pre-push checks\n./scripts/pre-push-check.sh\n\n# Or run individual steps:\npre-commit run --all-files  # Run pre-commit hooks (includes security)\nhatch run lint:all          # Run full linting\nhatch run no-cov           # Run tests\n\n# Run only security checks:\npre-commit run bandit --all-files\n</code></pre></p> </li> <li> <p>Bypassing checks: While you can use <code>git push --no-verify</code> to skip these checks,    this is strongly discouraged as it may cause CI failures.</p> </li> </ol>"},{"location":"contributing/#submit-your-contribution","title":"Submit your contribution","text":"<ol> <li>If everything works fine and all checks pass, push your local branch to the remote server with:</li> </ol> <pre><code>git push -u origin my-feature\n</code></pre> <ol> <li>Go to the web page of your fork and click \"Create pull request\"    to send your changes for review.</li> </ol> <p>Find more detailed information in creating a PR. You might also want to open    the PR as a draft first and mark it as ready for review after the feedbacks    from the continuous integration (CI) system or any required fixes.</p> <ol> <li> <p>Even though these resources focus on open source projects and communities, the general ideas behind collaborating with other developers to collectively create software are general and can be applied to all sorts of environments, including private companies and proprietary code bases.\u00a0\u21a9</p> </li> </ol>"},{"location":"license/","title":"License","text":"<p>The MIT License (MIT)</p> <p>Copyright \u00a9 2023 Florian Wilhelm</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"reference/SUMMARY/","title":"Summary","text":"<ul> <li>pytanis<ul> <li>communication<ul> <li>base</li> <li>helpdesk_adapter</li> <li>mailgun_adapter</li> </ul> </li> <li>config</li> <li>factory</li> <li>google</li> <li>helpdesk<ul> <li>client</li> <li>mail</li> <li>models</li> </ul> </li> <li>highs</li> <li>mailgun<ul> <li>mail</li> </ul> </li> <li>pretalx<ul> <li>client</li> <li>models</li> <li>utils</li> </ul> </li> <li>review</li> <li>storage<ul> <li>base</li> <li>google</li> <li>local</li> </ul> </li> <li>utils</li> </ul> </li> </ul>"},{"location":"reference/pytanis/","title":"Pytanis","text":""},{"location":"reference/pytanis/#pytanis","title":"<code>pytanis</code>","text":""},{"location":"reference/pytanis/#pytanis.__all__","title":"<code>__all__ = ['GSheetsClient', 'HelpDeskClient', 'PretalxClient', 'SimpleTalk', '__version__', 'get_cfg', 'get_confirmed_talks_as_json', 'get_mail_client', 'get_storage_client', 'get_talks_as_json', 'get_ticket_client', 'save_confirmed_talks_to_json', 'save_talks_to_json', 'talks_to_json']</code>  <code>module-attribute</code>","text":""},{"location":"reference/pytanis/#pytanis.__version__","title":"<code>__version__ = version('pytanis')</code>  <code>module-attribute</code>","text":""},{"location":"reference/pytanis/#pytanis.GSheetsClient","title":"<code>GSheetsClient(config: Config | None = None, *, read_only: bool = True)</code>","text":"<p>Google API to easily handle GSheets and other files on GDrive</p> <p>By default, only the least permissive scope <code>GSHEET_RO</code> in case of <code>read_only = True</code> is used.</p> Source code in <code>src/pytanis/google.py</code> <pre><code>def __init__(self, config: Config | None = None, *, read_only: bool = True):\n    self._read_only = read_only\n    if read_only:\n        self._scopes = [Scope.GSHEET_RO]\n    else:\n        self._scopes = [Scope.GSHEET_RW]\n    if config is None:\n        config = get_cfg()\n    self._config = config\n    self.gc = gspread_client(self._scopes, config)  # gspread client for more functionality\n</code></pre>"},{"location":"reference/pytanis/#pytanis.GSheetsClient.gc","title":"<code>gc = gspread_client(self._scopes, config)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/#pytanis.GSheetsClient.clear_gsheet","title":"<code>clear_gsheet(spreadsheet_id: str, worksheet_name: str)</code>","text":"<p>Clear the worksheet including values, formatting, filtering, etc.</p> Source code in <code>src/pytanis/google.py</code> <pre><code>def clear_gsheet(self, spreadsheet_id: str, worksheet_name: str):\n    \"\"\"Clear the worksheet including values, formatting, filtering, etc.\"\"\"\n    worksheet = self.gsheet(spreadsheet_id, worksheet_name, create_ws=False)\n    default_fmt = get_default_format(worksheet.spreadsheet)\n    wrange = worksheet_range(worksheet)\n    try:\n        worksheet.clear()\n        worksheet.clear_basic_filter()\n        format_cell_range(worksheet, wrange, default_fmt)\n        rules = get_conditional_format_rules(worksheet)\n        rules.clear()\n        rules.save()\n        set_data_validation_for_cell_range(worksheet, wrange, None)\n    except APIError as error:\n        self._exception_feedback(error)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.GSheetsClient.gsheet","title":"<code>gsheet(spreadsheet_id: str, worksheet_name: str | None = None, *, create_ws: bool = False) -&gt; Worksheet | Spreadsheet</code>","text":"<p>Retrieve a Google sheet by its id and the name</p> <p>Open a Google sheet in your browser and check the URL to retrieve the id, e.g.: https://docs.google.com/spreadsheets/d/SPREEDSHEET_ID/edit...</p> <p>If the spreadsheet as several worksheets (check the lower bar) then <code>worksheet_name</code> can be used to specify a specific one.</p> Source code in <code>src/pytanis/google.py</code> <pre><code>def gsheet(\n    self, spreadsheet_id: str, worksheet_name: str | None = None, *, create_ws: bool = False\n) -&gt; Worksheet | Spreadsheet:\n    \"\"\"Retrieve a Google sheet by its id and the name\n\n    Open a Google sheet in your browser and check the URL to retrieve the id, e.g.:\n    https://docs.google.com/spreadsheets/d/SPREEDSHEET_ID/edit...\n\n    If the spreadsheet as several worksheets (check the lower bar) then `worksheet_name` can be used to\n    specify a specific one.\n    \"\"\"\n    spreadsheet = self.gc.open_by_key(spreadsheet_id)\n    if worksheet_name is None:\n        return spreadsheet\n    elif worksheet_name in [ws.title for ws in spreadsheet.worksheets()]:\n        return spreadsheet.worksheet(worksheet_name)\n    elif create_ws:\n        worksheet = spreadsheet.add_worksheet(title=worksheet_name, rows=100, cols=20)\n        self._wait_for_worksheet(spreadsheet_id, worksheet_name)\n        return worksheet\n    else:\n        return spreadsheet.worksheet(worksheet_name)  # raises exception\n</code></pre>"},{"location":"reference/pytanis/#pytanis.GSheetsClient.gsheet_as_df","title":"<code>gsheet_as_df(spreadsheet_id: str, worksheet_name: str, **kwargs: str | bool | int) -&gt; pd.DataFrame</code>","text":"<p>Returns a worksheet as dataframe</p> Source code in <code>src/pytanis/google.py</code> <pre><code>def gsheet_as_df(self, spreadsheet_id: str, worksheet_name: str, **kwargs: str | bool | int) -&gt; pd.DataFrame:\n    \"\"\"Returns a worksheet as dataframe\"\"\"\n    worksheet = self.gsheet(spreadsheet_id, worksheet_name)\n    df = get_as_dataframe(worksheet, **kwargs)\n    # remove Nan rows &amp; columns as they are exported by default\n    df.dropna(how='all', inplace=True, axis=0)\n    df.dropna(how='all', inplace=True, axis=1)\n    return df\n</code></pre>"},{"location":"reference/pytanis/#pytanis.GSheetsClient.recreate_token","title":"<code>recreate_token()</code>","text":"<p>Recreate the current token using the scopes given at initialization</p> Source code in <code>src/pytanis/google.py</code> <pre><code>def recreate_token(self):\n    \"\"\"Recreate the current token using the scopes given at initialization\"\"\"\n    self._config.Google.token_json.unlink(missing_ok=True)\n    self.gc = gspread_client(self._scopes, self._config)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.GSheetsClient.save_df_as_gsheet","title":"<code>save_df_as_gsheet(df: pd.DataFrame, spreadsheet_id: str, worksheet_name: str, *, create_ws: bool = False, default_fmt: bool = True, **kwargs: str | bool | int)</code>","text":"<p>Save the given dataframe as worksheet in a spreadsheet</p> <p>Make sure that the scope passed gives you write permissions</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>dataframe to save</p> required <code>spreadsheet_id</code> <code>str</code> <p>id of the Google spreadsheet</p> required <code>worksheet_name</code> <code>str</code> <p>name of the worksheet within the spreadsheet</p> required <code>create_ws</code> <code>bool</code> <p>create the worksheet if non-existent</p> <code>False</code> <code>default_fmt</code> <code>bool</code> <p>apply default formatter <code>BasicFormatter</code></p> <code>True</code> <code>**kwargs</code> <code>str | bool | int</code> <p>extra keyword arguments passed to <code>set_with_dataframe</code></p> <code>{}</code> Source code in <code>src/pytanis/google.py</code> <pre><code>def save_df_as_gsheet(\n    self,\n    df: pd.DataFrame,\n    spreadsheet_id: str,\n    worksheet_name: str,\n    *,\n    create_ws: bool = False,\n    default_fmt: bool = True,\n    **kwargs: str | (bool | int),\n):\n    \"\"\"Save the given dataframe as worksheet in a spreadsheet\n\n    Make sure that the scope passed gives you write permissions\n\n    Args:\n        df: dataframe to save\n        spreadsheet_id: id of the Google spreadsheet\n        worksheet_name: name of the worksheet within the spreadsheet\n        create_ws: create the worksheet if non-existent\n        default_fmt: apply default formatter `BasicFormatter`\n        **kwargs: extra keyword arguments passed to `set_with_dataframe`\n    \"\"\"\n    worksheet = self.gsheet(spreadsheet_id, worksheet_name, create_ws=create_ws)\n    # make sure it's really only the dataframe, not some residue\n    self.clear_gsheet(spreadsheet_id, worksheet_name)\n    params = {'resize': True} | dict(**kwargs)  # set sane defaults\n    try:\n        set_with_dataframe(worksheet, df, **params)\n        if default_fmt:\n            format_with_dataframe(worksheet, df)\n    except APIError as error:\n        self._exception_feedback(error)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.HelpDeskClient","title":"<code>HelpDeskClient(config: Config | None = None)</code>","text":"Source code in <code>src/pytanis/helpdesk/client.py</code> <pre><code>def __init__(self, config: Config | None = None):\n    if config is None:\n        config = get_cfg()\n    self._config = config\n    # Important: Always use a custom User-Agent, never a generic one.\n    # Generic User-Agents are filtered by helpdesk to reduce spam.\n    self._headers = {'User-Agent': 'Pytanis'}\n\n    self._get_throttled = self._get\n    self._post_throttled = self._post\n    self.set_throttling(calls=1, seconds=10)  # Helpdesk is really strange when it comes to this\n</code></pre>"},{"location":"reference/pytanis/#pytanis.HelpDeskClient.create_ticket","title":"<code>create_ticket(ticket: NewTicket)</code>","text":"Source code in <code>src/pytanis/helpdesk/client.py</code> <pre><code>def create_ticket(self, ticket: NewTicket):\n    return self.post('tickets', data=ticket.model_dump())\n</code></pre>"},{"location":"reference/pytanis/#pytanis.HelpDeskClient.get","title":"<code>get(endpoint: str, params: QueryParams | None = None) -&gt; JSON</code>","text":"<p>Retrieve data via throttled GET request and return the JSON</p> Source code in <code>src/pytanis/helpdesk/client.py</code> <pre><code>def get(self, endpoint: str, params: QueryParams | None = None) -&gt; JSON:\n    \"\"\"Retrieve data via throttled GET request and return the JSON\"\"\"\n    resp = self._get_throttled(endpoint, params)\n    resp.raise_for_status()\n    return resp.json()\n</code></pre>"},{"location":"reference/pytanis/#pytanis.HelpDeskClient.list_agents","title":"<code>list_agents() -&gt; list[Agent]</code>","text":"Source code in <code>src/pytanis/helpdesk/client.py</code> <pre><code>def list_agents(self) -&gt; list[Agent]:\n    agents = self.get('agents')\n    if not isinstance(agents, list):\n        msg = 'Received JSON is not a list object'\n        raise ValueError(msg)\n    return [Agent.model_validate(dct) for dct in agents]\n</code></pre>"},{"location":"reference/pytanis/#pytanis.HelpDeskClient.list_teams","title":"<code>list_teams() -&gt; list[Team]</code>","text":"Source code in <code>src/pytanis/helpdesk/client.py</code> <pre><code>def list_teams(self) -&gt; list[Team]:\n    teams = self.get('teams')\n    if not isinstance(teams, list):\n        msg = 'Received JSON is not a list object'\n        raise ValueError(msg)\n    return [Team.model_validate(dct) for dct in teams]\n</code></pre>"},{"location":"reference/pytanis/#pytanis.HelpDeskClient.post","title":"<code>post(endpoint: str, data: dict[str, Any], params: QueryParams | None = None) -&gt; JSON</code>","text":"Source code in <code>src/pytanis/helpdesk/client.py</code> <pre><code>def post(self, endpoint: str, data: dict[str, Any], params: QueryParams | None = None) -&gt; JSON:\n    resp = self._post_throttled(endpoint, data, params)\n    resp.raise_for_status()\n    return resp.json()\n</code></pre>"},{"location":"reference/pytanis/#pytanis.HelpDeskClient.set_throttling","title":"<code>set_throttling(calls: int, seconds: int)</code>","text":"<p>Throttle the number of calls per seconds to the Pretalx API</p> Source code in <code>src/pytanis/helpdesk/client.py</code> <pre><code>def set_throttling(self, calls: int, seconds: int):\n    \"\"\"Throttle the number of calls per seconds to the Pretalx API\"\"\"\n    _logger.debug('throttling', calls=calls, seconds=seconds)\n    self._get_throttled = throttle(calls, seconds)(self._get)\n    self._post_throttled = throttle(calls, seconds)(self._post)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient","title":"<code>PretalxClient(config: Config | None = None, *, blocking: bool = False)</code>","text":"<p>Client for the Pretalx API</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def __init__(self, config: Config | None = None, *, blocking: bool = False):\n    if config is None:\n        config = get_cfg()\n    self._config = config\n    self._get_throttled = self._get\n    self.blocking = blocking\n    self.set_throttling(calls=2, seconds=1)  # we are nice by default and Pretalx doesn't allow many calls at once.\n\n    # Caches for expanded objects (session-only, not persisted)\n    self._speaker_cache: dict[str, dict] = {}\n    self._submission_type_cache: dict[int, dict] = {}\n    self._track_cache: dict[int, dict] = {}\n    self._answer_cache: dict[int, dict | None] = {}\n    self._question_cache: dict[int, dict] = {}\n    self._caches_populated: dict[str, bool] = {}  # Track which event caches are populated\n    self._use_cache_prepopulation: bool = True  # Enable cache pre-population by default\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient.blocking","title":"<code>blocking = blocking</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/#pytanis.PretalxClient.__validate","title":"<code>__validate(model_type, result)</code>  <code>classmethod</code>","text":"Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>@classmethod\ndef __validate(cls, model_type, result):\n    try:\n        validated = model_type.model_validate(result)\n        return validated\n    except Exception as e:\n        # introduced to deal with API changes\n        _logger.error('result', resp=e)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient.answer","title":"<code>answer(event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Answer</code>","text":"<p>Returns a specific answer</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def answer(self, event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Answer:  # noqa: A002\n    \"\"\"Returns a specific answer\"\"\"\n    return self._endpoint_id(Answer, event_slug, 'answers', id, params=params)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient.answers","title":"<code>answers(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Answer]]</code>","text":"<p>Lists all answers and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def answers(self, event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Answer]]:\n    \"\"\"Lists all answers and their details\"\"\"\n    return self._endpoint_lst(Answer, event_slug, 'answers', params=params)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient.clear_caches","title":"<code>clear_caches() -&gt; None</code>","text":"<p>Clear all session caches.</p> <p>This is useful if you want to force fresh data to be fetched from the API. Note that caches are session-only and are not persisted between client instances.</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def clear_caches(self) -&gt; None:\n    \"\"\"Clear all session caches.\n\n    This is useful if you want to force fresh data to be fetched from the API.\n    Note that caches are session-only and are not persisted between client instances.\n    \"\"\"\n    self._speaker_cache.clear()\n    self._submission_type_cache.clear()\n    self._track_cache.clear()\n    self._answer_cache.clear()\n    self._question_cache.clear()\n    self._caches_populated.clear()\n    _logger.info('All caches cleared')\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient.event","title":"<code>event(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; Event</code>","text":"<p>Returns detailed information about a specific event</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def event(self, event_slug: str, *, params: QueryParams | dict | None = None) -&gt; Event:\n    \"\"\"Returns detailed information about a specific event\"\"\"\n    endpoint = f'/api/events/{event_slug}/'\n    result = self._get_one(endpoint, params)\n    _logger.debug('result', resp=result)\n    return self.__validate(Event, result)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient.events","title":"<code>events(*, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Event]]</code>","text":"<p>Lists all events and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def events(self, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Event]]:\n    \"\"\"Lists all events and their details\"\"\"\n    count, results = self._get_many('/api/events/', params)\n    events = iter(_logger.debug('result', resp=r) or Event.model_validate(r) for r in results)\n    return count, events\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient.me","title":"<code>me() -&gt; Me</code>","text":"<p>Returns what Pretalx knows about myself</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def me(self) -&gt; Me:\n    \"\"\"Returns what Pretalx knows about myself\"\"\"\n    result = self._get_one('/api/me/')\n    return self.__validate(Me, result)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient.question","title":"<code>question(event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Question</code>","text":"<p>Returns a specific question</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def question(self, event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Question:  # noqa: A002\n    \"\"\"Returns a specific question\"\"\"\n    return self._endpoint_id(Question, event_slug, 'questions', id, params=params)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient.questions","title":"<code>questions(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Question]]</code>","text":"<p>Lists all questions and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def questions(self, event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Question]]:\n    \"\"\"Lists all questions and their details\"\"\"\n    return self._endpoint_lst(Question, event_slug, 'questions', params=params)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient.review","title":"<code>review(event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Review</code>","text":"<p>Returns a specific review</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def review(self, event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Review:  # noqa: A002\n    \"\"\"Returns a specific review\"\"\"\n    return self._endpoint_id(Review, event_slug, 'reviews', id, params=params)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient.reviews","title":"<code>reviews(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Review]]</code>","text":"<p>Lists all reviews and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def reviews(self, event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Review]]:\n    \"\"\"Lists all reviews and their details\"\"\"\n    return self._endpoint_lst(Review, event_slug, 'reviews', params=params)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient.room","title":"<code>room(event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Room</code>","text":"<p>Returns a specific room</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def room(self, event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Room:  # noqa: A002\n    \"\"\"Returns a specific room\"\"\"\n    return self._endpoint_id(Room, event_slug, 'rooms', id, params=params)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient.rooms","title":"<code>rooms(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Room]]</code>","text":"<p>Lists all rooms and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def rooms(self, event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Room]]:\n    \"\"\"Lists all rooms and their details\"\"\"\n    return self._endpoint_lst(Room, event_slug, 'rooms', params=params)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient.set_cache_prepopulation","title":"<code>set_cache_prepopulation(enabled: bool) -&gt; None</code>","text":"<p>Enable or disable automatic cache pre-population for submissions.</p> <p>When enabled (default), the client will fetch all speakers, submission types, and tracks in bulk on the first submission to minimize API calls. Disable this if you're only fetching a few submissions.</p> <p>Parameters:</p> Name Type Description Default <code>enabled</code> <code>bool</code> <p>Whether to enable cache pre-population</p> required Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def set_cache_prepopulation(self, enabled: bool) -&gt; None:  # noqa: FBT001\n    \"\"\"Enable or disable automatic cache pre-population for submissions.\n\n    When enabled (default), the client will fetch all speakers, submission types,\n    and tracks in bulk on the first submission to minimize API calls.\n    Disable this if you're only fetching a few submissions.\n\n    Args:\n        enabled: Whether to enable cache pre-population\n    \"\"\"\n    self._use_cache_prepopulation = enabled\n    _logger.info(f'Cache pre-population {\"enabled\" if enabled else \"disabled\"}')\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient.set_throttling","title":"<code>set_throttling(calls: int, seconds: int)</code>","text":"<p>Throttle the number of calls per seconds to the Pretalx API</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def set_throttling(self, calls: int, seconds: int):\n    \"\"\"Throttle the number of calls per seconds to the Pretalx API\"\"\"\n    _logger.info('throttling', calls=calls, seconds=seconds)\n    self._get_throttled = throttle(calls, seconds)(self._get)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient.speaker","title":"<code>speaker(event_slug: str, code: str, *, params: QueryParams | dict | None = None) -&gt; Speaker</code>","text":"<p>Returns a specific speaker</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def speaker(self, event_slug: str, code: str, *, params: QueryParams | dict | None = None) -&gt; Speaker:\n    \"\"\"Returns a specific speaker\"\"\"\n    return self._endpoint_id(Speaker, event_slug, 'speakers', code, params=params)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient.speakers","title":"<code>speakers(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Speaker]]</code>","text":"<p>Lists all speakers and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def speakers(self, event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Speaker]]:\n    \"\"\"Lists all speakers and their details\"\"\"\n    return self._endpoint_lst(Speaker, event_slug, 'speakers', params=params)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient.submission","title":"<code>submission(event_slug: str, code: str, *, params: QueryParams | dict | None = None) -&gt; Submission</code>","text":"<p>Returns a specific submission</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def submission(self, event_slug: str, code: str, *, params: QueryParams | dict | None = None) -&gt; Submission:\n    \"\"\"Returns a specific submission\"\"\"\n    return self._endpoint_id(Submission, event_slug, 'submissions', code, params=params)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient.submission_type","title":"<code>submission_type(event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; SubmissionType</code>","text":"<p>Returns a specific submission type</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def submission_type(self, event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; SubmissionType:  # noqa: A002\n    \"\"\"Returns a specific submission type\"\"\"\n    return self._endpoint_id(SubmissionType, event_slug, 'submission-types', id, params=params)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient.submission_types","title":"<code>submission_types(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[SubmissionType]]</code>","text":"<p>Lists all submission types and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def submission_types(\n    self, event_slug: str, *, params: QueryParams | dict | None = None\n) -&gt; tuple[int, Iterator[SubmissionType]]:\n    \"\"\"Lists all submission types and their details\"\"\"\n    return self._endpoint_lst(SubmissionType, event_slug, 'submission-types', params=params)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient.submissions","title":"<code>submissions(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Submission]]</code>","text":"<p>Lists all submissions and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def submissions(\n    self, event_slug: str, *, params: QueryParams | dict | None = None\n) -&gt; tuple[int, Iterator[Submission]]:\n    \"\"\"Lists all submissions and their details\"\"\"\n    return self._endpoint_lst(Submission, event_slug, 'submissions', params=params)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient.tag","title":"<code>tag(event_slug: str, tag: str, *, params: QueryParams | dict | None = None) -&gt; Tag</code>","text":"<p>Returns a specific tag</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def tag(self, event_slug: str, tag: str, *, params: QueryParams | dict | None = None) -&gt; Tag:\n    \"\"\"Returns a specific tag\"\"\"\n    return self._endpoint_id(Tag, event_slug, 'tags', tag, params=params)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient.tags","title":"<code>tags(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Tag]]</code>","text":"<p>Lists all tags and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def tags(self, event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Tag]]:\n    \"\"\"Lists all tags and their details\"\"\"\n    return self._endpoint_lst(Tag, event_slug, 'tags', params=params)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient.talk","title":"<code>talk(event_slug: str, code: str, *, params: QueryParams | dict | None = None) -&gt; Talk</code>","text":"<p>Returns a specific talk</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def talk(self, event_slug: str, code: str, *, params: QueryParams | dict | None = None) -&gt; Talk:\n    \"\"\"Returns a specific talk\"\"\"\n    try:\n        return self._endpoint_id(Talk, event_slug, 'talks', code, params=params)\n    except httpx.HTTPStatusError as e:\n        if e.response.status_code == HTTP_NOT_FOUND:\n            _logger.info('talk endpoint not available, using submission endpoint')\n            # Use submission endpoint but validate as Talk object\n            return self._endpoint_id(Talk, event_slug, 'submissions', code, params=params)\n        raise\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient.talks","title":"<code>talks(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Talk]]</code>","text":"<p>Lists all talks and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def talks(self, event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Talk]]:\n    \"\"\"Lists all talks and their details\"\"\"\n    try:\n        return self._endpoint_lst(Talk, event_slug, 'talks', params=params)\n    except httpx.HTTPStatusError as e:\n        if e.response.status_code == HTTP_NOT_FOUND:\n            _logger.info('talks endpoint not available, using submissions endpoint')\n            # Use submissions endpoint but validate as Talk objects\n            return self._endpoint_lst(Talk, event_slug, 'submissions', params=params)\n        raise\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient.track","title":"<code>track(event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Track</code>","text":"<p>Returns a specific track</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def track(self, event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Track:  # noqa: A002\n    \"\"\"Returns a specific track\"\"\"\n    return self._endpoint_id(Track, event_slug, 'tracks', id, params=params)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient.tracks","title":"<code>tracks(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Track]]</code>","text":"<p>Lists all tracks and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def tracks(self, event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Track]]:\n    \"\"\"Lists all tracks and their details\"\"\"\n    return self._endpoint_lst(Track, event_slug, 'tracks', params=params)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.SimpleTalk","title":"<code>SimpleTalk</code>","text":"<p>Simplified Talk model for generating JSON output</p> <p>This model contains only the essential information needed for display purposes.</p>"},{"location":"reference/pytanis/#pytanis.SimpleTalk.abstract","title":"<code>abstract: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/#pytanis.SimpleTalk.code","title":"<code>code: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/#pytanis.SimpleTalk.description","title":"<code>description: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/#pytanis.SimpleTalk.domain_level","title":"<code>domain_level: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/#pytanis.SimpleTalk.duration","title":"<code>duration: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/#pytanis.SimpleTalk.organisation","title":"<code>organisation: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/#pytanis.SimpleTalk.prerequisites","title":"<code>prerequisites: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/#pytanis.SimpleTalk.python_level","title":"<code>python_level: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/#pytanis.SimpleTalk.speaker","title":"<code>speaker: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/#pytanis.SimpleTalk.title","title":"<code>title: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/#pytanis.SimpleTalk.track","title":"<code>track: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/#pytanis.__getattr__","title":"<code>__getattr__(name)</code>","text":"<p>Lazy load optional components</p> Source code in <code>src/pytanis/__init__.py</code> <pre><code>def __getattr__(name):\n    \"\"\"Lazy load optional components\"\"\"\n    if name == 'GSheetsClient':\n        try:\n            from pytanis.google import GSheetsClient  # noqa: PLC0415\n\n            return GSheetsClient\n        except ImportError as e:\n            msg = 'Google Sheets dependencies not installed. Install with: pip install pytanis[google]'\n            raise ImportError(msg) from e\n    elif name == 'HelpDeskClient':\n        try:\n            from pytanis.helpdesk import HelpDeskClient  # noqa: PLC0415\n\n            return HelpDeskClient\n        except ImportError as e:\n            msg = 'HelpDesk dependencies not installed. Install with: pip install pytanis[helpdesk]'\n            raise ImportError(msg) from e\n    msg = f\"module '{__name__}' has no attribute '{name}'\"\n    raise AttributeError(msg)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.get_cfg","title":"<code>get_cfg() -&gt; Config</code>","text":"<p>Returns the configuration as an object</p> Source code in <code>src/pytanis/config.py</code> <pre><code>def get_cfg() -&gt; Config:\n    \"\"\"Returns the configuration as an object\"\"\"\n    cfg_path = get_cfg_file()\n    with open(cfg_path, 'rb') as fh:\n        cfg_dict = tomli.load(fh)\n\n    # add config path to later resolve relative paths of config values\n    cfg_dict['cfg_path'] = cfg_path\n\n    # Ensure Pretalx section exists (it's required)\n    if 'Pretalx' not in cfg_dict:\n        cfg_dict['Pretalx'] = {}\n\n    # Optional sections will default to None if not present\n    return Config.model_validate(cfg_dict)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.get_confirmed_talks_as_json","title":"<code>get_confirmed_talks_as_json(pretalx_client: PretalxClient, event_slug: str, params: dict[str, Any] | None = None) -&gt; str</code>","text":"<p>Get confirmed talks from pretalx and convert them to JSON (legacy function for backward compatibility).</p> <p>Parameters:</p> Name Type Description Default <code>pretalx_client</code> <code>PretalxClient</code> <p>PretalxClient instance to fetch talk and speaker data</p> required <code>event_slug</code> <code>str</code> <p>Event slug for the pretalx event</p> required <code>params</code> <code>dict[str, Any] | None</code> <p>Additional parameters to pass to the pretalx API</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>A JSON string containing a list of SimpleTalk objects</p> Source code in <code>src/pytanis/pretalx/utils.py</code> <pre><code>def get_confirmed_talks_as_json(\n    pretalx_client: PretalxClient, event_slug: str, params: dict[str, Any] | None = None\n) -&gt; str:\n    \"\"\"\n    Get confirmed talks from pretalx and convert them to JSON (legacy function for backward compatibility).\n\n    Args:\n        pretalx_client: PretalxClient instance to fetch talk and speaker data\n        event_slug: Event slug for the pretalx event\n        params: Additional parameters to pass to the pretalx API\n\n    Returns:\n        A JSON string containing a list of SimpleTalk objects\n    \"\"\"\n    return get_talks_as_json(pretalx_client, event_slug, 'confirmed', params)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.get_mail_client","title":"<code>get_mail_client(config: Config | None = None) -&gt; BaseMailClient</code>","text":"<p>Get a mail client based on configuration</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config | None</code> <p>Configuration object (if None, will use get_cfg())</p> <code>None</code> <p>Returns:</p> Type Description <code>BaseMailClient</code> <p>A mail client instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no email provider is configured or if it's not supported</p> <code>ImportError</code> <p>If the provider's dependencies are not installed</p> Source code in <code>src/pytanis/factory.py</code> <pre><code>def get_mail_client(config: Config | None = None) -&gt; BaseMailClient:\n    \"\"\"Get a mail client based on configuration\n\n    Args:\n        config: Configuration object (if None, will use get_cfg())\n\n    Returns:\n        A mail client instance\n\n    Raises:\n        ValueError: If no email provider is configured or if it's not supported\n        ImportError: If the provider's dependencies are not installed\n    \"\"\"\n    if config is None:\n        config = get_cfg()\n\n    # Get communication configuration\n    comm_cfg = config.Communication\n    if comm_cfg is None or comm_cfg.email_provider is None:\n        # Check legacy configuration\n        if config.Mailgun is not None and config.Mailgun.token is not None:\n            _logger.info('Using Mailgun from legacy configuration')\n            provider = 'mailgun'\n        elif config.HelpDesk is not None and config.HelpDesk.token is not None:\n            _logger.info('Using HelpDesk from legacy configuration')\n            provider = 'helpdesk'\n        else:\n            raise ValueError('No email provider configured')\n    else:\n        provider = comm_cfg.email_provider.lower()\n\n    if provider == 'mailgun':\n        try:\n            from pytanis.communication.mailgun_adapter import MailgunAdapter\n        except ImportError as e:\n            raise ImportError('Mailgun dependencies not installed. Install with: pip install pytanis[mailgun]') from e\n        return MailgunAdapter(config=config)\n\n    elif provider == 'helpdesk':\n        try:\n            from pytanis.communication.helpdesk_adapter import HelpDeskMailAdapter\n        except ImportError as e:\n            raise ImportError('HelpDesk dependencies not installed. Install with: pip install pytanis[helpdesk]') from e\n        return HelpDeskMailAdapter(config=config)\n\n    else:\n        raise ValueError(f'Unknown email provider: {provider}')\n</code></pre>"},{"location":"reference/pytanis/#pytanis.get_storage_client","title":"<code>get_storage_client(config: Config | None = None) -&gt; BaseSpreadsheetClient</code>","text":"<p>Get a storage client based on configuration</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config | None</code> <p>Configuration object (if None, will use get_cfg())</p> <code>None</code> <p>Returns:</p> Type Description <code>BaseSpreadsheetClient</code> <p>A storage client instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the configured provider is not supported</p> <code>ImportError</code> <p>If the provider's dependencies are not installed</p> Source code in <code>src/pytanis/factory.py</code> <pre><code>def get_storage_client(config: Config | None = None) -&gt; BaseSpreadsheetClient:\n    \"\"\"Get a storage client based on configuration\n\n    Args:\n        config: Configuration object (if None, will use get_cfg())\n\n    Returns:\n        A storage client instance\n\n    Raises:\n        ValueError: If the configured provider is not supported\n        ImportError: If the provider's dependencies are not installed\n    \"\"\"\n    if config is None:\n        config = get_cfg()\n\n    # Get storage configuration\n    storage_cfg = config.Storage\n    if storage_cfg is None:\n        # Default to local storage\n        from pytanis.storage.local import LocalFileClient\n\n        _logger.info('No storage configuration found, defaulting to local storage')\n        return LocalFileClient()\n\n    provider = storage_cfg.provider.lower()\n\n    if provider == 'local':\n        from pytanis.storage.local import LocalFileClient\n\n        base_path = storage_cfg.local_path or '.'\n        return LocalFileClient(base_path=base_path)\n\n    elif provider == 'google':\n        try:\n            from pytanis.storage.google import GoogleSheetsStorageClient\n        except ImportError as e:\n            raise ImportError(\n                'Google Sheets dependencies not installed. Install with: pip install pytanis[google]'\n            ) from e\n        return GoogleSheetsStorageClient(config=config)\n\n    else:\n        raise ValueError(f'Unknown storage provider: {provider}')\n</code></pre>"},{"location":"reference/pytanis/#pytanis.get_talks_as_json","title":"<code>get_talks_as_json(pretalx_client: PretalxClient, event_slug: str, state_value: str = 'confirmed', params: dict[str, Any] | None = None) -&gt; str</code>","text":"<p>Get talks from pretalx and convert them to a JSON list of SimpleTalk objects.</p> <p>This function fetches talks from pretalx based on the specified state, extracts the essential information, and returns a JSON string containing a list of simplified talk objects.</p> <p>Parameters:</p> Name Type Description Default <code>pretalx_client</code> <code>PretalxClient</code> <p>PretalxClient instance to fetch talk and speaker data</p> required <code>event_slug</code> <code>str</code> <p>Event slug for the pretalx event</p> required <code>state_value</code> <code>str</code> <p>State of talks to include (default: \"confirmed\")</p> <code>'confirmed'</code> <code>params</code> <code>dict[str, Any] | None</code> <p>Additional parameters to pass to the pretalx API</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>A JSON string containing a list of SimpleTalk objects</p> Source code in <code>src/pytanis/pretalx/utils.py</code> <pre><code>def get_talks_as_json(\n    pretalx_client: PretalxClient, event_slug: str, state_value: str = 'confirmed', params: dict[str, Any] | None = None\n) -&gt; str:\n    \"\"\"\n    Get talks from pretalx and convert them to a JSON list of SimpleTalk objects.\n\n    This function fetches talks from pretalx based on the specified state,\n    extracts the essential information, and returns a JSON string containing\n    a list of simplified talk objects.\n\n    Args:\n        pretalx_client: PretalxClient instance to fetch talk and speaker data\n        event_slug: Event slug for the pretalx event\n        state_value: State of talks to include (default: \"confirmed\")\n        params: Additional parameters to pass to the pretalx API\n\n    Returns:\n        A JSON string containing a list of SimpleTalk objects\n    \"\"\"\n    # Prepare parameters for the API call\n    if params is None:\n        params = {}\n\n    # Ensure we get all questions and filter by state\n    params['questions'] = 'all'\n    params['state'] = state_value\n\n    # Fetch talks from pretalx\n    _, talks_iter = pretalx_client.talks(event_slug, params=params)\n    talks = list(talks_iter)  # Materialize the iterator\n\n    return talks_to_json(talks, pretalx_client, event_slug)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.get_ticket_client","title":"<code>get_ticket_client(config: Config | None = None) -&gt; BaseTicketClient</code>","text":"<p>Get a ticket client based on configuration</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config | None</code> <p>Configuration object (if None, will use get_cfg())</p> <code>None</code> <p>Returns:</p> Type Description <code>BaseTicketClient</code> <p>A ticket client instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no ticket provider is configured or if it's not supported</p> <code>ImportError</code> <p>If the provider's dependencies are not installed</p> Source code in <code>src/pytanis/factory.py</code> <pre><code>def get_ticket_client(config: Config | None = None) -&gt; BaseTicketClient:\n    \"\"\"Get a ticket client based on configuration\n\n    Args:\n        config: Configuration object (if None, will use get_cfg())\n\n    Returns:\n        A ticket client instance\n\n    Raises:\n        ValueError: If no ticket provider is configured or if it's not supported\n        ImportError: If the provider's dependencies are not installed\n    \"\"\"\n    if config is None:\n        config = get_cfg()\n\n    # Get communication configuration\n    comm_cfg = config.Communication\n    if comm_cfg is None or comm_cfg.ticket_provider is None:\n        # Check legacy configuration\n        if config.HelpDesk is not None and config.HelpDesk.token is not None:\n            _logger.info('Using HelpDesk from legacy configuration')\n            provider = 'helpdesk'\n        else:\n            raise ValueError('No ticket provider configured')\n    else:\n        provider = comm_cfg.ticket_provider.lower()\n\n    if provider == 'helpdesk':\n        try:\n            from pytanis.communication.helpdesk_adapter import HelpDeskTicketAdapter\n        except ImportError as e:\n            raise ImportError('HelpDesk dependencies not installed. Install with: pip install pytanis[helpdesk]') from e\n        return HelpDeskTicketAdapter(config=config)\n\n    else:\n        raise ValueError(f'Unknown ticket provider: {provider}')\n</code></pre>"},{"location":"reference/pytanis/#pytanis.save_confirmed_talks_to_json","title":"<code>save_confirmed_talks_to_json(talks: Iterable[Talk], file_path: str, pretalx_client: PretalxClient | None = None, event_slug: str | None = None) -&gt; None</code>","text":"<p>Save confirmed talks to a JSON file (legacy function for backward compatibility).</p> <p>Parameters:</p> Name Type Description Default <code>talks</code> <code>Iterable[Talk]</code> <p>An iterable of Talk objects, typically from pretalx_client.talks()</p> required <code>file_path</code> <code>str</code> <p>Path where the JSON file should be saved</p> required <code>pretalx_client</code> <code>PretalxClient | None</code> <p>Optional PretalxClient instance to fetch speaker data</p> <code>None</code> <code>event_slug</code> <code>str | None</code> <p>Optional event slug needed if pretalx_client is provided</p> <code>None</code> Source code in <code>src/pytanis/pretalx/utils.py</code> <pre><code>def save_confirmed_talks_to_json(\n    talks: Iterable[Talk], file_path: str, pretalx_client: PretalxClient | None = None, event_slug: str | None = None\n) -&gt; None:\n    \"\"\"\n    Save confirmed talks to a JSON file (legacy function for backward compatibility).\n\n    Args:\n        talks: An iterable of Talk objects, typically from pretalx_client.talks()\n        file_path: Path where the JSON file should be saved\n        pretalx_client: Optional PretalxClient instance to fetch speaker data\n        event_slug: Optional event slug needed if pretalx_client is provided\n    \"\"\"\n    json_data = talks_to_json([talk for talk in talks if talk.state.value == 'confirmed'], pretalx_client, event_slug)\n\n    with open(file_path, 'w', encoding='utf-8') as f:\n        f.write(json_data)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.save_talks_to_json","title":"<code>save_talks_to_json(pretalx_client: PretalxClient, event_slug: str, file_path: str, state_value: str = 'confirmed', params: dict[str, Any] | None = None) -&gt; None</code>","text":"<p>Fetch talks from pretalx and save them to a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>pretalx_client</code> <code>PretalxClient</code> <p>PretalxClient instance to fetch talk and speaker data</p> required <code>event_slug</code> <code>str</code> <p>Event slug for the pretalx event</p> required <code>file_path</code> <code>str</code> <p>Path where the JSON file should be saved</p> required <code>state_value</code> <code>str</code> <p>State of talks to include (default: \"confirmed\")</p> <code>'confirmed'</code> <code>params</code> <code>dict[str, Any] | None</code> <p>Additional parameters to pass to the pretalx API</p> <code>None</code> Source code in <code>src/pytanis/pretalx/utils.py</code> <pre><code>def save_talks_to_json(\n    pretalx_client: PretalxClient,\n    event_slug: str,\n    file_path: str,\n    state_value: str = 'confirmed',\n    params: dict[str, Any] | None = None,\n) -&gt; None:\n    \"\"\"\n    Fetch talks from pretalx and save them to a JSON file.\n\n    Args:\n        pretalx_client: PretalxClient instance to fetch talk and speaker data\n        event_slug: Event slug for the pretalx event\n        file_path: Path where the JSON file should be saved\n        state_value: State of talks to include (default: \"confirmed\")\n        params: Additional parameters to pass to the pretalx API\n    \"\"\"\n    json_data = get_talks_as_json(pretalx_client, event_slug, state_value, params)\n\n    with open(file_path, 'w', encoding='utf-8') as f:\n        f.write(json_data)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.talks_to_json","title":"<code>talks_to_json(talks: Iterable[Talk], pretalx_client: PretalxClient | None = None, event_slug: str | None = None) -&gt; str</code>","text":"<p>Convert Talk objects to a JSON list of SimpleTalk objects.</p> <p>This function extracts the essential information from pretalx Talk objects and returns a JSON string containing a list of simplified talk objects.</p> <p>Parameters:</p> Name Type Description Default <code>talks</code> <code>Iterable[Talk]</code> <p>An iterable of Talk objects</p> required <code>pretalx_client</code> <code>PretalxClient | None</code> <p>Optional PretalxClient instance to fetch speaker data</p> <code>None</code> <code>event_slug</code> <code>str | None</code> <p>Optional event slug needed if pretalx_client is provided</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>A JSON string containing a list of SimpleTalk objects</p> Source code in <code>src/pytanis/pretalx/utils.py</code> <pre><code>def talks_to_json(\n    talks: Iterable[Talk], pretalx_client: PretalxClient | None = None, event_slug: str | None = None\n) -&gt; str:\n    \"\"\"\n    Convert Talk objects to a JSON list of SimpleTalk objects.\n\n    This function extracts the essential information from pretalx Talk objects\n    and returns a JSON string containing a list of simplified talk objects.\n\n    Args:\n        talks: An iterable of Talk objects\n        pretalx_client: Optional PretalxClient instance to fetch speaker data\n        event_slug: Optional event slug needed if pretalx_client is provided\n\n    Returns:\n        A JSON string containing a list of SimpleTalk objects\n    \"\"\"\n    simple_talks = []\n\n    # Store speaker data to avoid fetching the same speaker multiple times\n    speaker_data: dict[str, Speaker] = {}\n\n    for talk in talks:\n        # Create a SimpleTalk object with basic information\n        simple_talk = create_simple_talk_from_talk(talk)\n\n        # Extract expertise levels and prerequisites\n        extract_expertise_and_prerequisites(talk, simple_talk)\n\n        # Extract organisation information\n        if event_slug and pretalx_client:\n            extract_organisation(talk, simple_talk, pretalx_client, event_slug, speaker_data)\n\n        simple_talks.append(simple_talk)\n\n    # Convert to JSON\n    return json.dumps([talk.model_dump() for talk in simple_talks], indent=2)\n</code></pre>"},{"location":"reference/pytanis/config/","title":"Config","text":""},{"location":"reference/pytanis/config/#pytanis.config","title":"<code>config</code>","text":"<p>Handling the configuration</p>"},{"location":"reference/pytanis/config/#pytanis.config.PYTANIS_CFG_PATH","title":"<code>PYTANIS_CFG_PATH: str = '.pytanis/config.toml'</code>  <code>module-attribute</code>","text":"<p>Path within $HOME to the configuration file of Pytanis</p>"},{"location":"reference/pytanis/config/#pytanis.config.PYTANIS_ENV","title":"<code>PYTANIS_ENV: str = 'PYTANIS_CONFIG'</code>  <code>module-attribute</code>","text":"<p>Name of the environment variable to look up the path for the config</p>"},{"location":"reference/pytanis/config/#pytanis.config.__all__","title":"<code>__all__ = ['CommunicationCfg', 'Config', 'GoogleCfg', 'HelpDeskCfg', 'MailgunCfg', 'PretalxCfg', 'StorageCfg', 'get_cfg', 'get_cfg_file']</code>  <code>module-attribute</code>","text":""},{"location":"reference/pytanis/config/#pytanis.config.CommunicationCfg","title":"<code>CommunicationCfg</code>","text":"<p>Configuration for communication providers</p>"},{"location":"reference/pytanis/config/#pytanis.config.CommunicationCfg.email_provider","title":"<code>email_provider: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/config/#pytanis.config.CommunicationCfg.ticket_provider","title":"<code>ticket_provider: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/config/#pytanis.config.Config","title":"<code>Config</code>","text":"<p>Main configuration object</p>"},{"location":"reference/pytanis/config/#pytanis.config.Config.Communication","title":"<code>Communication: CommunicationCfg | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/config/#pytanis.config.Config.Google","title":"<code>Google: GoogleCfg | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/config/#pytanis.config.Config.HelpDesk","title":"<code>HelpDesk: HelpDeskCfg | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/config/#pytanis.config.Config.Mailgun","title":"<code>Mailgun: MailgunCfg | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/config/#pytanis.config.Config.Pretalx","title":"<code>Pretalx: PretalxCfg</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/config/#pytanis.config.Config.Storage","title":"<code>Storage: StorageCfg | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/config/#pytanis.config.Config.cfg_path","title":"<code>cfg_path: FilePath</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/config/#pytanis.config.Config.convert_json_path","title":"<code>convert_json_path(v: GoogleCfg | None, info: ValidationInfo) -&gt; GoogleCfg | None</code>  <code>classmethod</code>","text":"Source code in <code>src/pytanis/config.py</code> <pre><code>@field_validator('Google')\n@classmethod\ndef convert_json_path(cls, v: GoogleCfg | None, info: ValidationInfo) -&gt; GoogleCfg | None:\n    if v is None:\n        return v\n\n    def make_rel_path_abs(entry):\n        if entry is not None and not entry.is_absolute():\n            entry = info.data['cfg_path'].parent / entry\n        return entry\n\n    v.client_secret_json = make_rel_path_abs(v.client_secret_json)\n    v.token_json = make_rel_path_abs(v.token_json)\n\n    return v\n</code></pre>"},{"location":"reference/pytanis/config/#pytanis.config.Config.validate_storage","title":"<code>validate_storage(v: StorageCfg | None, info: ValidationInfo) -&gt; StorageCfg | None</code>  <code>classmethod</code>","text":"Source code in <code>src/pytanis/config.py</code> <pre><code>@field_validator('Storage')\n@classmethod\ndef validate_storage(cls, v: StorageCfg | None, info: ValidationInfo) -&gt; StorageCfg | None:\n    if v is None:\n        # Default to local storage\n        v = StorageCfg(provider='local')\n\n    # Make local_path absolute if provided\n    if v.local_path is not None and not v.local_path.is_absolute():\n        v.local_path = info.data['cfg_path'].parent / v.local_path\n\n    return v\n</code></pre>"},{"location":"reference/pytanis/config/#pytanis.config.GoogleCfg","title":"<code>GoogleCfg</code>","text":"<p>Configuration related to the Google API</p>"},{"location":"reference/pytanis/config/#pytanis.config.GoogleCfg.client_secret_json","title":"<code>client_secret_json: Path | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/config/#pytanis.config.GoogleCfg.service_user_authentication","title":"<code>service_user_authentication: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/config/#pytanis.config.GoogleCfg.token_json","title":"<code>token_json: Path | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/config/#pytanis.config.HelpDeskCfg","title":"<code>HelpDeskCfg</code>","text":"<p>Configuration related to the HelpDesk API</p>"},{"location":"reference/pytanis/config/#pytanis.config.HelpDeskCfg.account","title":"<code>account: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/config/#pytanis.config.HelpDeskCfg.entity_id","title":"<code>entity_id: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/config/#pytanis.config.HelpDeskCfg.token","title":"<code>token: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/config/#pytanis.config.MailgunCfg","title":"<code>MailgunCfg</code>","text":"<p>Configuration related to the Mailgun API</p>"},{"location":"reference/pytanis/config/#pytanis.config.MailgunCfg.from_address","title":"<code>from_address: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/config/#pytanis.config.MailgunCfg.reply_to","title":"<code>reply_to: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/config/#pytanis.config.MailgunCfg.token","title":"<code>token: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/config/#pytanis.config.PretalxCfg","title":"<code>PretalxCfg</code>","text":"<p>Configuration related to the Pretalx API</p>"},{"location":"reference/pytanis/config/#pytanis.config.PretalxCfg.api_token","title":"<code>api_token: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/config/#pytanis.config.PretalxCfg.api_version","title":"<code>api_version: str = 'v1'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/config/#pytanis.config.StorageCfg","title":"<code>StorageCfg</code>","text":"<p>Configuration for storage providers</p>"},{"location":"reference/pytanis/config/#pytanis.config.StorageCfg.local_path","title":"<code>local_path: Path | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/config/#pytanis.config.StorageCfg.provider","title":"<code>provider: str = 'local'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/config/#pytanis.config.get_cfg","title":"<code>get_cfg() -&gt; Config</code>","text":"<p>Returns the configuration as an object</p> Source code in <code>src/pytanis/config.py</code> <pre><code>def get_cfg() -&gt; Config:\n    \"\"\"Returns the configuration as an object\"\"\"\n    cfg_path = get_cfg_file()\n    with open(cfg_path, 'rb') as fh:\n        cfg_dict = tomli.load(fh)\n\n    # add config path to later resolve relative paths of config values\n    cfg_dict['cfg_path'] = cfg_path\n\n    # Ensure Pretalx section exists (it's required)\n    if 'Pretalx' not in cfg_dict:\n        cfg_dict['Pretalx'] = {}\n\n    # Optional sections will default to None if not present\n    return Config.model_validate(cfg_dict)\n</code></pre>"},{"location":"reference/pytanis/config/#pytanis.config.get_cfg_file","title":"<code>get_cfg_file() -&gt; Path</code>","text":"<p>Determines the path of the config file</p> Source code in <code>src/pytanis/config.py</code> <pre><code>def get_cfg_file() -&gt; Path:\n    \"\"\"Determines the path of the config file\"\"\"\n    path_str = os.environ.get(PYTANIS_ENV, None)\n    path = Path.home() / Path(PYTANIS_CFG_PATH) if path_str is None else Path(path_str)\n    return path\n</code></pre>"},{"location":"reference/pytanis/factory/","title":"Factory","text":""},{"location":"reference/pytanis/factory/#pytanis.factory","title":"<code>factory</code>","text":"<p>Factory functions for creating storage and communication clients</p>"},{"location":"reference/pytanis/factory/#pytanis.factory.get_mail_client","title":"<code>get_mail_client(config: Config | None = None) -&gt; BaseMailClient</code>","text":"<p>Get a mail client based on configuration</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config | None</code> <p>Configuration object (if None, will use get_cfg())</p> <code>None</code> <p>Returns:</p> Type Description <code>BaseMailClient</code> <p>A mail client instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no email provider is configured or if it's not supported</p> <code>ImportError</code> <p>If the provider's dependencies are not installed</p> Source code in <code>src/pytanis/factory.py</code> <pre><code>def get_mail_client(config: Config | None = None) -&gt; BaseMailClient:\n    \"\"\"Get a mail client based on configuration\n\n    Args:\n        config: Configuration object (if None, will use get_cfg())\n\n    Returns:\n        A mail client instance\n\n    Raises:\n        ValueError: If no email provider is configured or if it's not supported\n        ImportError: If the provider's dependencies are not installed\n    \"\"\"\n    if config is None:\n        config = get_cfg()\n\n    # Get communication configuration\n    comm_cfg = config.Communication\n    if comm_cfg is None or comm_cfg.email_provider is None:\n        # Check legacy configuration\n        if config.Mailgun is not None and config.Mailgun.token is not None:\n            _logger.info('Using Mailgun from legacy configuration')\n            provider = 'mailgun'\n        elif config.HelpDesk is not None and config.HelpDesk.token is not None:\n            _logger.info('Using HelpDesk from legacy configuration')\n            provider = 'helpdesk'\n        else:\n            raise ValueError('No email provider configured')\n    else:\n        provider = comm_cfg.email_provider.lower()\n\n    if provider == 'mailgun':\n        try:\n            from pytanis.communication.mailgun_adapter import MailgunAdapter\n        except ImportError as e:\n            raise ImportError('Mailgun dependencies not installed. Install with: pip install pytanis[mailgun]') from e\n        return MailgunAdapter(config=config)\n\n    elif provider == 'helpdesk':\n        try:\n            from pytanis.communication.helpdesk_adapter import HelpDeskMailAdapter\n        except ImportError as e:\n            raise ImportError('HelpDesk dependencies not installed. Install with: pip install pytanis[helpdesk]') from e\n        return HelpDeskMailAdapter(config=config)\n\n    else:\n        raise ValueError(f'Unknown email provider: {provider}')\n</code></pre>"},{"location":"reference/pytanis/factory/#pytanis.factory.get_storage_client","title":"<code>get_storage_client(config: Config | None = None) -&gt; BaseSpreadsheetClient</code>","text":"<p>Get a storage client based on configuration</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config | None</code> <p>Configuration object (if None, will use get_cfg())</p> <code>None</code> <p>Returns:</p> Type Description <code>BaseSpreadsheetClient</code> <p>A storage client instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the configured provider is not supported</p> <code>ImportError</code> <p>If the provider's dependencies are not installed</p> Source code in <code>src/pytanis/factory.py</code> <pre><code>def get_storage_client(config: Config | None = None) -&gt; BaseSpreadsheetClient:\n    \"\"\"Get a storage client based on configuration\n\n    Args:\n        config: Configuration object (if None, will use get_cfg())\n\n    Returns:\n        A storage client instance\n\n    Raises:\n        ValueError: If the configured provider is not supported\n        ImportError: If the provider's dependencies are not installed\n    \"\"\"\n    if config is None:\n        config = get_cfg()\n\n    # Get storage configuration\n    storage_cfg = config.Storage\n    if storage_cfg is None:\n        # Default to local storage\n        from pytanis.storage.local import LocalFileClient\n\n        _logger.info('No storage configuration found, defaulting to local storage')\n        return LocalFileClient()\n\n    provider = storage_cfg.provider.lower()\n\n    if provider == 'local':\n        from pytanis.storage.local import LocalFileClient\n\n        base_path = storage_cfg.local_path or '.'\n        return LocalFileClient(base_path=base_path)\n\n    elif provider == 'google':\n        try:\n            from pytanis.storage.google import GoogleSheetsStorageClient\n        except ImportError as e:\n            raise ImportError(\n                'Google Sheets dependencies not installed. Install with: pip install pytanis[google]'\n            ) from e\n        return GoogleSheetsStorageClient(config=config)\n\n    else:\n        raise ValueError(f'Unknown storage provider: {provider}')\n</code></pre>"},{"location":"reference/pytanis/factory/#pytanis.factory.get_ticket_client","title":"<code>get_ticket_client(config: Config | None = None) -&gt; BaseTicketClient</code>","text":"<p>Get a ticket client based on configuration</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config | None</code> <p>Configuration object (if None, will use get_cfg())</p> <code>None</code> <p>Returns:</p> Type Description <code>BaseTicketClient</code> <p>A ticket client instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no ticket provider is configured or if it's not supported</p> <code>ImportError</code> <p>If the provider's dependencies are not installed</p> Source code in <code>src/pytanis/factory.py</code> <pre><code>def get_ticket_client(config: Config | None = None) -&gt; BaseTicketClient:\n    \"\"\"Get a ticket client based on configuration\n\n    Args:\n        config: Configuration object (if None, will use get_cfg())\n\n    Returns:\n        A ticket client instance\n\n    Raises:\n        ValueError: If no ticket provider is configured or if it's not supported\n        ImportError: If the provider's dependencies are not installed\n    \"\"\"\n    if config is None:\n        config = get_cfg()\n\n    # Get communication configuration\n    comm_cfg = config.Communication\n    if comm_cfg is None or comm_cfg.ticket_provider is None:\n        # Check legacy configuration\n        if config.HelpDesk is not None and config.HelpDesk.token is not None:\n            _logger.info('Using HelpDesk from legacy configuration')\n            provider = 'helpdesk'\n        else:\n            raise ValueError('No ticket provider configured')\n    else:\n        provider = comm_cfg.ticket_provider.lower()\n\n    if provider == 'helpdesk':\n        try:\n            from pytanis.communication.helpdesk_adapter import HelpDeskTicketAdapter\n        except ImportError as e:\n            raise ImportError('HelpDesk dependencies not installed. Install with: pip install pytanis[helpdesk]') from e\n        return HelpDeskTicketAdapter(config=config)\n\n    else:\n        raise ValueError(f'Unknown ticket provider: {provider}')\n</code></pre>"},{"location":"reference/pytanis/google/","title":"Google","text":""},{"location":"reference/pytanis/google/#pytanis.google","title":"<code>google</code>","text":"<p>Functionality around the Google's Spreadsheet API</p> <p>Additional Documentation</p> <ul> <li>Google GSheet API</li> <li>GSpread</li> <li>GSpread-Dataframe</li> <li>GSpread-Formatting</li> </ul>"},{"location":"reference/pytanis/google/#pytanis.google.ColorType","title":"<code>ColorType = str | tuple[float, float, float] | tuple[float, float, float, float]</code>  <code>module-attribute</code>","text":""},{"location":"reference/pytanis/google/#pytanis.google.__all__","title":"<code>__all__ = ['GSheetsClient', 'PermissionDeniedError', 'gsheet_rows_for_fmt']</code>  <code>module-attribute</code>","text":""},{"location":"reference/pytanis/google/#pytanis.google.GSheetsClient","title":"<code>GSheetsClient(config: Config | None = None, *, read_only: bool = True)</code>","text":"<p>Google API to easily handle GSheets and other files on GDrive</p> <p>By default, only the least permissive scope <code>GSHEET_RO</code> in case of <code>read_only = True</code> is used.</p> Source code in <code>src/pytanis/google.py</code> <pre><code>def __init__(self, config: Config | None = None, *, read_only: bool = True):\n    self._read_only = read_only\n    if read_only:\n        self._scopes = [Scope.GSHEET_RO]\n    else:\n        self._scopes = [Scope.GSHEET_RW]\n    if config is None:\n        config = get_cfg()\n    self._config = config\n    self.gc = gspread_client(self._scopes, config)  # gspread client for more functionality\n</code></pre>"},{"location":"reference/pytanis/google/#pytanis.google.GSheetsClient.gc","title":"<code>gc = gspread_client(self._scopes, config)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/google/#pytanis.google.GSheetsClient.clear_gsheet","title":"<code>clear_gsheet(spreadsheet_id: str, worksheet_name: str)</code>","text":"<p>Clear the worksheet including values, formatting, filtering, etc.</p> Source code in <code>src/pytanis/google.py</code> <pre><code>def clear_gsheet(self, spreadsheet_id: str, worksheet_name: str):\n    \"\"\"Clear the worksheet including values, formatting, filtering, etc.\"\"\"\n    worksheet = self.gsheet(spreadsheet_id, worksheet_name, create_ws=False)\n    default_fmt = get_default_format(worksheet.spreadsheet)\n    wrange = worksheet_range(worksheet)\n    try:\n        worksheet.clear()\n        worksheet.clear_basic_filter()\n        format_cell_range(worksheet, wrange, default_fmt)\n        rules = get_conditional_format_rules(worksheet)\n        rules.clear()\n        rules.save()\n        set_data_validation_for_cell_range(worksheet, wrange, None)\n    except APIError as error:\n        self._exception_feedback(error)\n</code></pre>"},{"location":"reference/pytanis/google/#pytanis.google.GSheetsClient.gsheet","title":"<code>gsheet(spreadsheet_id: str, worksheet_name: str | None = None, *, create_ws: bool = False) -&gt; Worksheet | Spreadsheet</code>","text":"<p>Retrieve a Google sheet by its id and the name</p> <p>Open a Google sheet in your browser and check the URL to retrieve the id, e.g.: https://docs.google.com/spreadsheets/d/SPREEDSHEET_ID/edit...</p> <p>If the spreadsheet as several worksheets (check the lower bar) then <code>worksheet_name</code> can be used to specify a specific one.</p> Source code in <code>src/pytanis/google.py</code> <pre><code>def gsheet(\n    self, spreadsheet_id: str, worksheet_name: str | None = None, *, create_ws: bool = False\n) -&gt; Worksheet | Spreadsheet:\n    \"\"\"Retrieve a Google sheet by its id and the name\n\n    Open a Google sheet in your browser and check the URL to retrieve the id, e.g.:\n    https://docs.google.com/spreadsheets/d/SPREEDSHEET_ID/edit...\n\n    If the spreadsheet as several worksheets (check the lower bar) then `worksheet_name` can be used to\n    specify a specific one.\n    \"\"\"\n    spreadsheet = self.gc.open_by_key(spreadsheet_id)\n    if worksheet_name is None:\n        return spreadsheet\n    elif worksheet_name in [ws.title for ws in spreadsheet.worksheets()]:\n        return spreadsheet.worksheet(worksheet_name)\n    elif create_ws:\n        worksheet = spreadsheet.add_worksheet(title=worksheet_name, rows=100, cols=20)\n        self._wait_for_worksheet(spreadsheet_id, worksheet_name)\n        return worksheet\n    else:\n        return spreadsheet.worksheet(worksheet_name)  # raises exception\n</code></pre>"},{"location":"reference/pytanis/google/#pytanis.google.GSheetsClient.gsheet_as_df","title":"<code>gsheet_as_df(spreadsheet_id: str, worksheet_name: str, **kwargs: str | bool | int) -&gt; pd.DataFrame</code>","text":"<p>Returns a worksheet as dataframe</p> Source code in <code>src/pytanis/google.py</code> <pre><code>def gsheet_as_df(self, spreadsheet_id: str, worksheet_name: str, **kwargs: str | bool | int) -&gt; pd.DataFrame:\n    \"\"\"Returns a worksheet as dataframe\"\"\"\n    worksheet = self.gsheet(spreadsheet_id, worksheet_name)\n    df = get_as_dataframe(worksheet, **kwargs)\n    # remove Nan rows &amp; columns as they are exported by default\n    df.dropna(how='all', inplace=True, axis=0)\n    df.dropna(how='all', inplace=True, axis=1)\n    return df\n</code></pre>"},{"location":"reference/pytanis/google/#pytanis.google.GSheetsClient.recreate_token","title":"<code>recreate_token()</code>","text":"<p>Recreate the current token using the scopes given at initialization</p> Source code in <code>src/pytanis/google.py</code> <pre><code>def recreate_token(self):\n    \"\"\"Recreate the current token using the scopes given at initialization\"\"\"\n    self._config.Google.token_json.unlink(missing_ok=True)\n    self.gc = gspread_client(self._scopes, self._config)\n</code></pre>"},{"location":"reference/pytanis/google/#pytanis.google.GSheetsClient.save_df_as_gsheet","title":"<code>save_df_as_gsheet(df: pd.DataFrame, spreadsheet_id: str, worksheet_name: str, *, create_ws: bool = False, default_fmt: bool = True, **kwargs: str | bool | int)</code>","text":"<p>Save the given dataframe as worksheet in a spreadsheet</p> <p>Make sure that the scope passed gives you write permissions</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>dataframe to save</p> required <code>spreadsheet_id</code> <code>str</code> <p>id of the Google spreadsheet</p> required <code>worksheet_name</code> <code>str</code> <p>name of the worksheet within the spreadsheet</p> required <code>create_ws</code> <code>bool</code> <p>create the worksheet if non-existent</p> <code>False</code> <code>default_fmt</code> <code>bool</code> <p>apply default formatter <code>BasicFormatter</code></p> <code>True</code> <code>**kwargs</code> <code>str | bool | int</code> <p>extra keyword arguments passed to <code>set_with_dataframe</code></p> <code>{}</code> Source code in <code>src/pytanis/google.py</code> <pre><code>def save_df_as_gsheet(\n    self,\n    df: pd.DataFrame,\n    spreadsheet_id: str,\n    worksheet_name: str,\n    *,\n    create_ws: bool = False,\n    default_fmt: bool = True,\n    **kwargs: str | (bool | int),\n):\n    \"\"\"Save the given dataframe as worksheet in a spreadsheet\n\n    Make sure that the scope passed gives you write permissions\n\n    Args:\n        df: dataframe to save\n        spreadsheet_id: id of the Google spreadsheet\n        worksheet_name: name of the worksheet within the spreadsheet\n        create_ws: create the worksheet if non-existent\n        default_fmt: apply default formatter `BasicFormatter`\n        **kwargs: extra keyword arguments passed to `set_with_dataframe`\n    \"\"\"\n    worksheet = self.gsheet(spreadsheet_id, worksheet_name, create_ws=create_ws)\n    # make sure it's really only the dataframe, not some residue\n    self.clear_gsheet(spreadsheet_id, worksheet_name)\n    params = {'resize': True} | dict(**kwargs)  # set sane defaults\n    try:\n        set_with_dataframe(worksheet, df, **params)\n        if default_fmt:\n            format_with_dataframe(worksheet, df)\n    except APIError as error:\n        self._exception_feedback(error)\n</code></pre>"},{"location":"reference/pytanis/google/#pytanis.google.PermissionDeniedError","title":"<code>PermissionDeniedError</code>","text":"<p>Error for APIError with status PERMISSION_DENIED</p> <p>Most likely thrown in cases when the scope is not <code>GSHEET_RW</code> or the token needs to be updated accordingly.</p>"},{"location":"reference/pytanis/google/#pytanis.google.Scope","title":"<code>Scope</code>","text":""},{"location":"reference/pytanis/google/#pytanis.google.Scope.GDRIVE_FILE","title":"<code>GDRIVE_FILE = 'https://www.googleapis.com/auth/drive.file'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/google/#pytanis.google.Scope.GDRIVE_RO","title":"<code>GDRIVE_RO = 'https://www.googleapis.com/auth/drive.readonly'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/google/#pytanis.google.Scope.GDRIVE_RW","title":"<code>GDRIVE_RW = 'https://www.googleapis.com/auth/drive'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/google/#pytanis.google.Scope.GSHEET_RO","title":"<code>GSHEET_RO = 'https://www.googleapis.com/auth/spreadsheets.readonly'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/google/#pytanis.google.Scope.GSHEET_RW","title":"<code>GSHEET_RW = 'https://www.googleapis.com/auth/spreadsheets'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/google/#pytanis.google.gsheet_col","title":"<code>gsheet_col(idx: int) -&gt; str</code>","text":"<p>Convert a column index to Google Sheet range notation, e.g. A, BE, etc.</p> Source code in <code>src/pytanis/google.py</code> <pre><code>def gsheet_col(idx: int) -&gt; str:\n    \"\"\"Convert a column index to Google Sheet range notation, e.g. A, BE, etc.\"\"\"\n    idx += 1\n    chars = []\n    while idx:\n        chars.append(string.ascii_uppercase[(idx % 26) - 1])\n        idx //= 27\n    return ''.join(chars[::-1])\n</code></pre>"},{"location":"reference/pytanis/google/#pytanis.google.gsheet_rows_for_fmt","title":"<code>gsheet_rows_for_fmt(mask: pd.Series, n_cols: int) -&gt; list[str]</code>","text":"<p>Get the Google Sheet row range specifications for formatting</p> Source code in <code>src/pytanis/google.py</code> <pre><code>def gsheet_rows_for_fmt(mask: pd.Series, n_cols: int) -&gt; list[str]:\n    \"\"\"Get the Google Sheet row range specifications for formatting\"\"\"\n    rows = pd.Series(np.argwhere(mask.to_numpy()).reshape(-1) + 2)  # +2 since 1-index and header\n    last_col = gsheet_col(n_cols - 1)  # last index\n    rows = rows.map(lambda x: f'A{x}:{last_col}{x}')\n    return rows.to_list()\n</code></pre>"},{"location":"reference/pytanis/google/#pytanis.google.gspread_client","title":"<code>gspread_client(scopes: list[Scope], config: Config) -&gt; gspread.client.Client</code>","text":"<p>Creates the GSheet client using our configuration</p> <p>Read GSpread for usage details</p> Source code in <code>src/pytanis/google.py</code> <pre><code>def gspread_client(scopes: list[Scope], config: Config) -&gt; gspread.client.Client:\n    \"\"\"Creates the GSheet client using our configuration\n\n    Read [GSpread](https://docs.gspread.org/) for usage details\n    \"\"\"\n    if config.Google is None:\n        msg = 'Google configuration is missing in config.toml!'\n        raise RuntimeError(msg)\n    if (secret_path := config.Google.client_secret_json) is None:\n        msg = 'You have to set Google.client_secret_json in your config.toml!'\n        raise RuntimeError(msg)\n\n    if (service_user_authentication := config.Google.service_user_authentication) is None:\n        service_user_authentication = False\n\n    if service_user_authentication:\n        gc = gspread.service_account(scopes=[scope.value for scope in scopes], filename=str(secret_path))\n    else:\n        if (token_path := config.Google.token_json) is None:\n            msg = 'You have to set Google.token_json in your config.toml!'\n            raise RuntimeError(msg)\n\n        gc = gspread.oauth(\n            scopes=[scope.value for scope in scopes],\n            credentials_filename=str(secret_path),\n            authorized_user_filename=str(token_path),\n        )\n\n    return gc\n</code></pre>"},{"location":"reference/pytanis/google/#pytanis.google.mark_rows","title":"<code>mark_rows(worksheet, mask: pd.Series, color: ColorType)</code>","text":"<p>Mark rows specified by a mask (condition) with a given color</p> <p>Color can be a tuple of RGB values or a Matplotlib string specification: https://matplotlib.org/stable/gallery/color/named_colors.html#css-colors</p> Source code in <code>src/pytanis/google.py</code> <pre><code>def mark_rows(worksheet, mask: pd.Series, color: ColorType):\n    \"\"\"Mark rows specified by a mask (condition) with a given color\n\n    Color can be a tuple of RGB values or a Matplotlib string specification:\n    https://matplotlib.org/stable/gallery/color/named_colors.html#css-colors\n    \"\"\"\n    rows = gsheet_rows_for_fmt(mask, worksheet.col_count)\n    color_rgb = name_to_rgb(color) if isinstance(color, str) else color[:3]\n    color_rgb = [x / 255 for x in color_rgb]  # convert RGB to 0-1 range\n    fmt = cellFormat(backgroundColor=Color(*color_rgb))\n    if rows:\n        format_cell_ranges(worksheet, [(rng, fmt) for rng in rows])\n</code></pre>"},{"location":"reference/pytanis/google/#pytanis.google.worksheet_range","title":"<code>worksheet_range(worksheet: Worksheet) -&gt; str</code>","text":"<p>Returns a range encompassing the whole worksheet</p> Source code in <code>src/pytanis/google.py</code> <pre><code>def worksheet_range(worksheet: Worksheet) -&gt; str:\n    \"\"\"Returns a range encompassing the whole worksheet\"\"\"\n    last_row = worksheet.row_count\n    last_col = gsheet_col(worksheet.col_count)\n    return f'A1:{last_col}{last_row}'\n</code></pre>"},{"location":"reference/pytanis/highs/","title":"Highs","text":""},{"location":"reference/pytanis/highs/#pytanis.highs","title":"<code>highs</code>","text":"<p>Some helper functions for HiGHS (https://highs.dev/)</p> <p><code>pyomo</code> and <code>highspy</code> need to be installed, consider <code>pip install 'pytanis[all]'</code>.</p> <p>ToDo</p> <ul> <li>Introduce a function <code>check_model_vars</code> that checks the names of variables and sets to be alphanumeric   before reading in a solution in <code>set_solution_from_file</code>.</li> </ul>"},{"location":"reference/pytanis/highs/#pytanis.highs.read_sol_file","title":"<code>read_sol_file(file_name: str) -&gt; Iterator[tuple[str, float]]</code>","text":"<p>Read a solution file from HiGHS solver with default output style</p> <p>We assume here that your variable names are alphanumeric!</p> <p>No underscores, no dashes, etc.!</p> Source code in <code>src/pytanis/highs.py</code> <pre><code>def read_sol_file(file_name: str) -&gt; Iterator[tuple[str, float]]:\n    \"\"\"Read a solution file from HiGHS solver with default output style\n\n    Attention: We assume here that your variable names are alphanumeric!\n               No underscores, no dashes, etc.!\n    \"\"\"\n    line_re = re.compile(r'(\\w+)(?:\\((\\w+)\\))?(_binary_indicator_var)? ([.\\w-]+)')\n\n    with open(file_name, encoding='utf8') as fh:\n        while True:\n            line = fh.readline()\n            if line.startswith('# Columns'):\n                break\n        for line in fh.readlines():\n            if line.startswith('#'):\n                break\n            if (match_obj := line_re.match(line.strip())) is None:\n                msg = f'Could not interpret line: {line}'\n                raise RuntimeError(msg)\n            else:\n                var_name, idx, binary, val = match_obj.groups()\n            val = float(val)\n            binary = binary.replace('_', '.', 1) if binary else ''\n\n            if idx is None:\n                yield f'{var_name}{binary}', val\n            else:\n                idx = idx.replace('_', ',')\n                yield f'{var_name}[{idx}]{binary}', val\n</code></pre>"},{"location":"reference/pytanis/highs/#pytanis.highs.set_solution_from_file","title":"<code>set_solution_from_file(model: ConcreteModel, file_name: str)</code>","text":"<p>Given a HiGHS solution file set the variables of a Pyomo model accordingly.</p> <p>This is a workaround to set a Pyomo model's variables to the solution from a HiGHS solution file.</p> Source code in <code>src/pytanis/highs.py</code> <pre><code>def set_solution_from_file(model: ConcreteModel, file_name: str):\n    \"\"\"Given a HiGHS solution file set the variables of a Pyomo model accordingly.\n\n    This is a workaround to set a Pyomo model's variables to the solution\n    from a HiGHS solution file.\n    \"\"\"\n    # just to initialize we read it in using HiGHS. The result is incorrect though,\n    # as the order of variables is mixed up quite often. We fix this below!\n    opt = Highs()\n    opt.set_instance(model)\n    opt._solver_model.readSolution(file_name, 0)\n    opt._sol = opt._solver_model.getSolution()\n    opt.load_vars()\n\n    # read the actual mapping of the variable names to the values\n    file_sol = dict(read_sol_file(file_name))\n\n    # overwrite the values of the variables again using the symbolic names from the file\n    for v, ref_info in opt._referenced_variables.items():\n        using_cons, using_sos, using_obj = ref_info\n        if using_cons or using_sos or (using_obj is not None):\n            var = opt._vars[v][0]\n            var.set_value(file_sol[var.name], skip_validation=True)\n</code></pre>"},{"location":"reference/pytanis/review/","title":"Review","text":""},{"location":"reference/pytanis/review/#pytanis.review","title":"<code>review</code>","text":"<p>Tools related to assigning proposals to reviewers</p> <p>In Pretalx assignments can be done in two directions:</p> <ol> <li>Assign proposals to reviewers</li> <li>Assign reviewers to proposals</li> </ol> <p>We will always assume direction 1. in this file when we talk about an assignment. So in Operation Research-speak, resources get assigned tasks, not the other way around. The time needed for the task of reviewing a proposal is quite homogeneous while the number of reviews a single reviewer may highly vary. Also, we will rather use the name submission instead of proposal as this also reflects the naming of the Pretalx API.</p> <p>We follow the convention over configuration principle here and thus check out the <code>Col</code> class for the naming of columns.</p>"},{"location":"reference/pytanis/review/#pytanis.review.Col","title":"<code>Col</code>","text":"<p>Additional conventions used for reviews</p>"},{"location":"reference/pytanis/review/#pytanis.review.Col.address_as","title":"<code>address_as = 'Address as'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/review/#pytanis.review.Col.all_proposals","title":"<code>all_proposals = 'All Proposals'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/review/#pytanis.review.Col.committee_contact","title":"<code>committee_contact = 'Committee Contact'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/review/#pytanis.review.Col.committee_member","title":"<code>committee_member = 'Committee Member'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/review/#pytanis.review.Col.curr_assignments","title":"<code>curr_assignments = 'Current Assignments'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/review/#pytanis.review.Col.done_nreviews","title":"<code>done_nreviews = 'Done #Reviews'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/review/#pytanis.review.Col.nassignments","title":"<code>nassignments = '#Assignments'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/review/#pytanis.review.Col.nvotes","title":"<code>nvotes = '#Votes'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/review/#pytanis.review.Col.pretalx_activated","title":"<code>pretalx_activated = 'Pretalx activated'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/review/#pytanis.review.Col.rem_nreviews","title":"<code>rem_nreviews = 'Remaining #Reviews'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/review/#pytanis.review.Col.target_nreviews","title":"<code>target_nreviews = 'Target #Reviews'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/review/#pytanis.review.Col.track_prefs","title":"<code>track_prefs = 'Track Preferences'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/review/#pytanis.review.Col.vote_score","title":"<code>vote_score = 'Vote Score'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/review/#pytanis.review.read_assignment_as_df","title":"<code>read_assignment_as_df(file_path: Path) -&gt; pd.DataFrame</code>","text":"<p>Reads an assignment and returns a dataframe.</p> Source code in <code>src/pytanis/review.py</code> <pre><code>def read_assignment_as_df(file_path: Path) -&gt; pd.DataFrame:\n    \"\"\"Reads an assignment and returns a dataframe.\"\"\"\n    with open(file_path, encoding='utf8') as fh:\n        curr_assign = json.load(fh)\n    df = pd.DataFrame({k: [v] for k, v in curr_assign.items()})\n    df = df.T.rename_axis(index=Col.email).rename(columns={0: Col.curr_assignments}).reset_index()\n    return df\n</code></pre>"},{"location":"reference/pytanis/review/#pytanis.review.save_assignments_as_json","title":"<code>save_assignments_as_json(df: pd.DataFrame, file_path: Path | str) -&gt; None</code>","text":"<p>Save the dataframe as proposal assignment JSON file.</p> <p>We expect <code>df</code> to have the columns <code>Col.email</code> and <code>Col.curr_assignments</code>.</p> Source code in <code>src/pytanis/review.py</code> <pre><code>def save_assignments_as_json(df: pd.DataFrame, file_path: Path | str) -&gt; None:\n    \"\"\"Save the dataframe as proposal assignment JSON file.\n\n    We expect `df` to have the columns `Col.email` and `Col.curr_assignments`.\n    \"\"\"\n    if df[Col.email].duplicated().any():\n        non_unique_mails = df[Col.email][df[Col.email].duplicated(keep=False)].unique().tolist()\n        msg = f'Non-unique emails found in the dataframe: {\", \".join(non_unique_mails)}'\n        raise ValueError(msg)\n    file_path = Path(file_path)\n    df = df.loc[:, [Col.email, Col.curr_assignments]]\n    json_dct = json.loads(df.set_index(Col.email).to_json())[Col.curr_assignments]\n    # prettify the json string for human-edit-ability if reviewers need to be dropped later\n    json_str = json.dumps(json_dct).replace('{', '{\\n').replace('], ', '],\\n').replace(']}', ']\\n}')\n    with open(file_path, 'w', encoding='utf8') as fh:\n        fh.write(json_str)\n</code></pre>"},{"location":"reference/pytanis/utils/","title":"Utils","text":""},{"location":"reference/pytanis/utils/#pytanis.utils","title":"<code>utils</code>","text":"<p>Additional utilities</p>"},{"location":"reference/pytanis/utils/#pytanis.utils.RT","title":"<code>RT = TypeVar('RT')</code>  <code>module-attribute</code>","text":""},{"location":"reference/pytanis/utils/#pytanis.utils.implode","title":"<code>implode(df: pd.DataFrame, cols: str | list[str]) -&gt; pd.DataFrame</code>","text":"<p>The inverse of Pandas' explode</p> Source code in <code>src/pytanis/utils.py</code> <pre><code>def implode(df: pd.DataFrame, cols: str | list[str]) -&gt; pd.DataFrame:\n    \"\"\"The inverse of Pandas' explode\"\"\"\n    if not isinstance(cols, list):\n        cols = [cols]\n    orig_cols = df.columns\n    grp_cols = [col for col in df.columns if col not in cols]\n    df = df.groupby(grp_cols, group_keys=True, dropna=False).aggregate({col: lambda x: x.tolist() for col in cols})\n    df.reset_index(inplace=True)\n    df = df.loc[:, list(orig_cols)]\n    return df\n</code></pre>"},{"location":"reference/pytanis/utils/#pytanis.utils.pretty_timedelta","title":"<code>pretty_timedelta(seconds: int) -&gt; str</code>","text":"<p>Converts timedelta in seconds to human-readable string</p> <p>Parameters:</p> Name Type Description Default <code>seconds</code> <code>int</code> <p>time delta in seconds</p> required <p>Returns:</p> Type Description <code>str</code> <p>timedelta as pretty string</p> Source code in <code>src/pytanis/utils.py</code> <pre><code>def pretty_timedelta(seconds: int) -&gt; str:\n    \"\"\"Converts timedelta in seconds to human-readable string\n\n    Args:\n        seconds: time delta in seconds\n\n    Returns:\n        timedelta as pretty string\n    \"\"\"\n    sign = '-' if seconds &lt; 0 else ''\n    seconds = abs(int(seconds))\n    days, seconds = divmod(seconds, 86400)\n    hours, seconds = divmod(seconds, 3600)\n    minutes, seconds = divmod(seconds, 60)\n    if days &gt; 0:\n        return f'{sign}{days}d{hours}h{minutes}m{seconds}s'\n    elif hours &gt; 0:\n        return f'{sign}{hours}h{minutes}m{seconds}s'\n    elif minutes &gt; 0:\n        return f'{sign}{minutes}m{seconds}s'\n    else:\n        return f'{sign}{seconds}s'\n</code></pre>"},{"location":"reference/pytanis/utils/#pytanis.utils.rm_keys","title":"<code>rm_keys(keys: Any | list[Any], dct: dict[Any, Any]) -&gt; dict[Any, Any]</code>","text":"<p>Return a copy with keys removed from dictionary</p> Source code in <code>src/pytanis/utils.py</code> <pre><code>def rm_keys(\n    keys: Any | list[Any],\n    dct: dict[Any, Any],\n) -&gt; dict[Any, Any]:\n    \"\"\"Return a copy with keys removed from dictionary\"\"\"\n    if not isinstance(keys, list):\n        keys = [keys]\n    return {k: v for k, v in dct.items() if k not in keys}\n</code></pre>"},{"location":"reference/pytanis/utils/#pytanis.utils.throttle","title":"<code>throttle(calls: int, seconds: int = 1) -&gt; Callable[[Callable[..., RT]], Callable[..., RT]]</code>","text":"<p>Decorator for throttling a function to number of calls per seconds</p> <p>Parameters:</p> Name Type Description Default <code>calls</code> <code>int</code> <p>number of calls per interval</p> required <code>seconds</code> <code>int</code> <p>number of seconds in interval</p> <code>1</code> <p>Returns:</p> Type Description <code>Callable[[Callable[..., RT]], Callable[..., RT]]</code> <p>wrapped function</p> Source code in <code>src/pytanis/utils.py</code> <pre><code>def throttle(calls: int, seconds: int = 1) -&gt; Callable[[Callable[..., RT]], Callable[..., RT]]:\n    \"\"\"Decorator for throttling a function to number of calls per seconds\n\n    Args:\n        calls: number of calls per interval\n        seconds: number of seconds in interval\n\n    Returns:\n        wrapped function\n    \"\"\"\n    if not isinstance(calls, int):\n        msg = 'number of calls must be integer'\n        raise ValueError(msg)\n    if not isinstance(seconds, int):\n        msg = 'number of seconds must be integer'\n        raise ValueError(msg)\n\n    def decorator(func: Callable[..., RT]) -&gt; Callable[..., RT]:\n        # keeps track of the last calls\n        last_calls: list[float] = []\n        lock = threading.Lock()\n\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs) -&gt; RT:\n            nonlocal last_calls\n            with lock:\n                curr_time = time.time()\n                # Remove old calls\n                last_calls = [call for call in last_calls if call &gt; curr_time - seconds]\n\n                if len(last_calls) &gt;= calls:\n                    sleep_time = last_calls[0] + seconds - curr_time\n                    logger = get_logger()\n                    logger.debug('stalling call', func=func.__name__, secs=sleep_time)\n                    time.sleep(sleep_time)\n\n                resp = func(*args, **kwargs)\n                last_calls.append(time.time())\n                return resp\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"reference/pytanis/communication/","title":"Communication","text":""},{"location":"reference/pytanis/communication/#pytanis.communication","title":"<code>communication</code>","text":"<p>Communication abstraction layer for Pytanis</p> <p>This module provides abstract base classes and implementations for sending emails and managing support tickets through various providers.</p>"},{"location":"reference/pytanis/communication/#pytanis.communication.__all__","title":"<code>__all__ = ['BaseMailClient', 'BaseTicketClient', 'EmailMessage', 'Ticket', 'TicketComment']</code>  <code>module-attribute</code>","text":""},{"location":"reference/pytanis/communication/#pytanis.communication.BaseMailClient","title":"<code>BaseMailClient</code>","text":"<p>Abstract base class for email clients</p> <p>This class defines the interface for sending emails through various providers (e.g., SMTP, Mailgun, SendGrid, etc.).</p>"},{"location":"reference/pytanis/communication/#pytanis.communication.BaseMailClient.send_bulk_emails","title":"<code>send_bulk_emails(messages: list[EmailMessage], rate_limit: int | None = None) -&gt; list[str | None]</code>  <code>abstractmethod</code>","text":"<p>Send multiple email messages</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>list[EmailMessage]</code> <p>List of email messages to send</p> required <code>rate_limit</code> <code>int | None</code> <p>Maximum emails per second (None for no limit)</p> <code>None</code> <p>Returns:</p> Type Description <code>list[str | None]</code> <p>List of message IDs (None for failures)</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If there's an error sending emails</p> Source code in <code>src/pytanis/communication/base.py</code> <pre><code>@abstractmethod\ndef send_bulk_emails(self, messages: list[EmailMessage], rate_limit: int | None = None) -&gt; list[str | None]:\n    \"\"\"Send multiple email messages\n\n    Args:\n        messages: List of email messages to send\n        rate_limit: Maximum emails per second (None for no limit)\n\n    Returns:\n        List of message IDs (None for failures)\n\n    Raises:\n        IOError: If there's an error sending emails\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/pytanis/communication/#pytanis.communication.BaseMailClient.send_email","title":"<code>send_email(message: EmailMessage) -&gt; str | None</code>  <code>abstractmethod</code>","text":"<p>Send an email message</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>EmailMessage</code> <p>The email message to send</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>Message ID if available, None otherwise</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If there's an error sending the email</p> Source code in <code>src/pytanis/communication/base.py</code> <pre><code>@abstractmethod\ndef send_email(self, message: EmailMessage) -&gt; str | None:\n    \"\"\"Send an email message\n\n    Args:\n        message: The email message to send\n\n    Returns:\n        Message ID if available, None otherwise\n\n    Raises:\n        IOError: If there's an error sending the email\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/pytanis/communication/#pytanis.communication.BaseMailClient.validate_email","title":"<code>validate_email(email: str) -&gt; bool</code>  <code>staticmethod</code>","text":"<p>Validate an email address format</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Email address to validate</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>src/pytanis/communication/base.py</code> <pre><code>@staticmethod\ndef validate_email(email: str) -&gt; bool:\n    \"\"\"Validate an email address format\n\n    Args:\n        email: Email address to validate\n\n    Returns:\n        True if valid, False otherwise\n    \"\"\"\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    return bool(re.match(pattern, email))\n</code></pre>"},{"location":"reference/pytanis/communication/#pytanis.communication.BaseTicketClient","title":"<code>BaseTicketClient</code>","text":"<p>Abstract base class for support ticket clients</p> <p>This class defines the interface for managing support tickets through various providers (e.g., HelpDesk, Zendesk, Freshdesk, etc.).</p>"},{"location":"reference/pytanis/communication/#pytanis.communication.BaseTicketClient.add_comment","title":"<code>add_comment(comment: TicketComment) -&gt; str</code>  <code>abstractmethod</code>","text":"<p>Add a comment to a ticket</p> <p>Parameters:</p> Name Type Description Default <code>comment</code> <code>TicketComment</code> <p>The comment to add</p> required <p>Returns:</p> Type Description <code>str</code> <p>The comment ID</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the ticket does not exist</p> <code>IOError</code> <p>If there's an error adding the comment</p> Source code in <code>src/pytanis/communication/base.py</code> <pre><code>@abstractmethod\ndef add_comment(self, comment: TicketComment) -&gt; str:\n    \"\"\"Add a comment to a ticket\n\n    Args:\n        comment: The comment to add\n\n    Returns:\n        The comment ID\n\n    Raises:\n        KeyError: If the ticket does not exist\n        IOError: If there's an error adding the comment\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/pytanis/communication/#pytanis.communication.BaseTicketClient.close_ticket","title":"<code>close_ticket(ticket_id: str) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Close a ticket</p> <p>Parameters:</p> Name Type Description Default <code>ticket_id</code> <code>str</code> <p>The ticket ID</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the ticket does not exist</p> <code>IOError</code> <p>If there's an error closing the ticket</p> Source code in <code>src/pytanis/communication/base.py</code> <pre><code>@abstractmethod\ndef close_ticket(self, ticket_id: str) -&gt; None:\n    \"\"\"Close a ticket\n\n    Args:\n        ticket_id: The ticket ID\n\n    Raises:\n        KeyError: If the ticket does not exist\n        IOError: If there's an error closing the ticket\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/pytanis/communication/#pytanis.communication.BaseTicketClient.create_ticket","title":"<code>create_ticket(ticket: Ticket) -&gt; str</code>  <code>abstractmethod</code>","text":"<p>Create a new support ticket</p> <p>Parameters:</p> Name Type Description Default <code>ticket</code> <code>Ticket</code> <p>The ticket to create</p> required <p>Returns:</p> Type Description <code>str</code> <p>The created ticket ID</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If there's an error creating the ticket</p> Source code in <code>src/pytanis/communication/base.py</code> <pre><code>@abstractmethod\ndef create_ticket(self, ticket: Ticket) -&gt; str:\n    \"\"\"Create a new support ticket\n\n    Args:\n        ticket: The ticket to create\n\n    Returns:\n        The created ticket ID\n\n    Raises:\n        IOError: If there's an error creating the ticket\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/pytanis/communication/#pytanis.communication.BaseTicketClient.get_ticket","title":"<code>get_ticket(ticket_id: str) -&gt; Ticket</code>  <code>abstractmethod</code>","text":"<p>Get a ticket by ID</p> <p>Parameters:</p> Name Type Description Default <code>ticket_id</code> <code>str</code> <p>The ticket ID</p> required <p>Returns:</p> Type Description <code>Ticket</code> <p>The ticket details</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the ticket does not exist</p> <code>IOError</code> <p>If there's an error retrieving the ticket</p> Source code in <code>src/pytanis/communication/base.py</code> <pre><code>@abstractmethod\ndef get_ticket(self, ticket_id: str) -&gt; Ticket:\n    \"\"\"Get a ticket by ID\n\n    Args:\n        ticket_id: The ticket ID\n\n    Returns:\n        The ticket details\n\n    Raises:\n        KeyError: If the ticket does not exist\n        IOError: If there's an error retrieving the ticket\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/pytanis/communication/#pytanis.communication.BaseTicketClient.list_tickets","title":"<code>list_tickets(status: str | None = None, requester_email: str | None = None, limit: int = 100) -&gt; list[Ticket]</code>  <code>abstractmethod</code>","text":"<p>List tickets with optional filtering</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>str | None</code> <p>Filter by status (e.g., 'open', 'closed')</p> <code>None</code> <code>requester_email</code> <code>str | None</code> <p>Filter by requester email</p> <code>None</code> <code>limit</code> <code>int</code> <p>Maximum number of tickets to return</p> <code>100</code> <p>Returns:</p> Type Description <code>list[Ticket]</code> <p>List of tickets matching the criteria</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If there's an error listing tickets</p> Source code in <code>src/pytanis/communication/base.py</code> <pre><code>@abstractmethod\ndef list_tickets(\n    self, status: str | None = None, requester_email: str | None = None, limit: int = 100\n) -&gt; list[Ticket]:\n    \"\"\"List tickets with optional filtering\n\n    Args:\n        status: Filter by status (e.g., 'open', 'closed')\n        requester_email: Filter by requester email\n        limit: Maximum number of tickets to return\n\n    Returns:\n        List of tickets matching the criteria\n\n    Raises:\n        IOError: If there's an error listing tickets\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/pytanis/communication/#pytanis.communication.BaseTicketClient.update_ticket","title":"<code>update_ticket(ticket_id: str, updates: dict[str, Any]) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Update a ticket</p> <p>Parameters:</p> Name Type Description Default <code>ticket_id</code> <code>str</code> <p>The ticket ID</p> required <code>updates</code> <code>dict[str, Any]</code> <p>Dictionary of fields to update</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the ticket does not exist</p> <code>IOError</code> <p>If there's an error updating the ticket</p> Source code in <code>src/pytanis/communication/base.py</code> <pre><code>@abstractmethod\ndef update_ticket(self, ticket_id: str, updates: dict[str, Any]) -&gt; None:\n    \"\"\"Update a ticket\n\n    Args:\n        ticket_id: The ticket ID\n        updates: Dictionary of fields to update\n\n    Raises:\n        KeyError: If the ticket does not exist\n        IOError: If there's an error updating the ticket\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/pytanis/communication/#pytanis.communication.EmailMessage","title":"<code>EmailMessage(to: list[str], subject: str, body: str, html_body: str | None = None, cc: list[str] | None = None, bcc: list[str] | None = None, reply_to: str | None = None, attachments: list[tuple[str, bytes]] | None = None, headers: dict[str, str] | None = None, metadata: dict[str, Any] | None = None)</code>  <code>dataclass</code>","text":"<p>Standard email message representation</p>"},{"location":"reference/pytanis/communication/#pytanis.communication.EmailMessage.attachments","title":"<code>attachments: list[tuple[str, bytes]] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/#pytanis.communication.EmailMessage.bcc","title":"<code>bcc: list[str] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/#pytanis.communication.EmailMessage.body","title":"<code>body: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/#pytanis.communication.EmailMessage.cc","title":"<code>cc: list[str] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/#pytanis.communication.EmailMessage.headers","title":"<code>headers: dict[str, str] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/#pytanis.communication.EmailMessage.html_body","title":"<code>html_body: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/#pytanis.communication.EmailMessage.metadata","title":"<code>metadata: dict[str, Any] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/#pytanis.communication.EmailMessage.reply_to","title":"<code>reply_to: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/#pytanis.communication.EmailMessage.subject","title":"<code>subject: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/#pytanis.communication.EmailMessage.to","title":"<code>to: list[str]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/#pytanis.communication.Ticket","title":"<code>Ticket(id: str | None, subject: str, description: str, requester_email: str, requester_name: str | None = None, status: str = 'open', priority: str = 'normal', tags: list[str] | None = None, custom_fields: dict[str, Any] | None = None)</code>  <code>dataclass</code>","text":"<p>Support ticket representation</p>"},{"location":"reference/pytanis/communication/#pytanis.communication.Ticket.custom_fields","title":"<code>custom_fields: dict[str, Any] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/#pytanis.communication.Ticket.description","title":"<code>description: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/#pytanis.communication.Ticket.id","title":"<code>id: str | None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/#pytanis.communication.Ticket.priority","title":"<code>priority: str = 'normal'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/#pytanis.communication.Ticket.requester_email","title":"<code>requester_email: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/#pytanis.communication.Ticket.requester_name","title":"<code>requester_name: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/#pytanis.communication.Ticket.status","title":"<code>status: str = 'open'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/#pytanis.communication.Ticket.subject","title":"<code>subject: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/#pytanis.communication.Ticket.tags","title":"<code>tags: list[str] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/#pytanis.communication.TicketComment","title":"<code>TicketComment(ticket_id: str, body: str, author_email: str, author_name: str | None = None, public: bool = True, attachments: list[tuple[str, bytes]] | None = None)</code>  <code>dataclass</code>","text":"<p>Comment on a support ticket</p>"},{"location":"reference/pytanis/communication/#pytanis.communication.TicketComment.attachments","title":"<code>attachments: list[tuple[str, bytes]] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/#pytanis.communication.TicketComment.author_email","title":"<code>author_email: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/#pytanis.communication.TicketComment.author_name","title":"<code>author_name: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/#pytanis.communication.TicketComment.body","title":"<code>body: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/#pytanis.communication.TicketComment.public","title":"<code>public: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/#pytanis.communication.TicketComment.ticket_id","title":"<code>ticket_id: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/base/","title":"Base","text":""},{"location":"reference/pytanis/communication/base/#pytanis.communication.base","title":"<code>base</code>","text":"<p>Base classes for communication abstraction</p>"},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.BaseMailClient","title":"<code>BaseMailClient</code>","text":"<p>Abstract base class for email clients</p> <p>This class defines the interface for sending emails through various providers (e.g., SMTP, Mailgun, SendGrid, etc.).</p>"},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.BaseMailClient.send_bulk_emails","title":"<code>send_bulk_emails(messages: list[EmailMessage], rate_limit: int | None = None) -&gt; list[str | None]</code>  <code>abstractmethod</code>","text":"<p>Send multiple email messages</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>list[EmailMessage]</code> <p>List of email messages to send</p> required <code>rate_limit</code> <code>int | None</code> <p>Maximum emails per second (None for no limit)</p> <code>None</code> <p>Returns:</p> Type Description <code>list[str | None]</code> <p>List of message IDs (None for failures)</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If there's an error sending emails</p> Source code in <code>src/pytanis/communication/base.py</code> <pre><code>@abstractmethod\ndef send_bulk_emails(self, messages: list[EmailMessage], rate_limit: int | None = None) -&gt; list[str | None]:\n    \"\"\"Send multiple email messages\n\n    Args:\n        messages: List of email messages to send\n        rate_limit: Maximum emails per second (None for no limit)\n\n    Returns:\n        List of message IDs (None for failures)\n\n    Raises:\n        IOError: If there's an error sending emails\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.BaseMailClient.send_email","title":"<code>send_email(message: EmailMessage) -&gt; str | None</code>  <code>abstractmethod</code>","text":"<p>Send an email message</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>EmailMessage</code> <p>The email message to send</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>Message ID if available, None otherwise</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If there's an error sending the email</p> Source code in <code>src/pytanis/communication/base.py</code> <pre><code>@abstractmethod\ndef send_email(self, message: EmailMessage) -&gt; str | None:\n    \"\"\"Send an email message\n\n    Args:\n        message: The email message to send\n\n    Returns:\n        Message ID if available, None otherwise\n\n    Raises:\n        IOError: If there's an error sending the email\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.BaseMailClient.validate_email","title":"<code>validate_email(email: str) -&gt; bool</code>  <code>staticmethod</code>","text":"<p>Validate an email address format</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Email address to validate</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>src/pytanis/communication/base.py</code> <pre><code>@staticmethod\ndef validate_email(email: str) -&gt; bool:\n    \"\"\"Validate an email address format\n\n    Args:\n        email: Email address to validate\n\n    Returns:\n        True if valid, False otherwise\n    \"\"\"\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    return bool(re.match(pattern, email))\n</code></pre>"},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.BaseTicketClient","title":"<code>BaseTicketClient</code>","text":"<p>Abstract base class for support ticket clients</p> <p>This class defines the interface for managing support tickets through various providers (e.g., HelpDesk, Zendesk, Freshdesk, etc.).</p>"},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.BaseTicketClient.add_comment","title":"<code>add_comment(comment: TicketComment) -&gt; str</code>  <code>abstractmethod</code>","text":"<p>Add a comment to a ticket</p> <p>Parameters:</p> Name Type Description Default <code>comment</code> <code>TicketComment</code> <p>The comment to add</p> required <p>Returns:</p> Type Description <code>str</code> <p>The comment ID</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the ticket does not exist</p> <code>IOError</code> <p>If there's an error adding the comment</p> Source code in <code>src/pytanis/communication/base.py</code> <pre><code>@abstractmethod\ndef add_comment(self, comment: TicketComment) -&gt; str:\n    \"\"\"Add a comment to a ticket\n\n    Args:\n        comment: The comment to add\n\n    Returns:\n        The comment ID\n\n    Raises:\n        KeyError: If the ticket does not exist\n        IOError: If there's an error adding the comment\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.BaseTicketClient.close_ticket","title":"<code>close_ticket(ticket_id: str) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Close a ticket</p> <p>Parameters:</p> Name Type Description Default <code>ticket_id</code> <code>str</code> <p>The ticket ID</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the ticket does not exist</p> <code>IOError</code> <p>If there's an error closing the ticket</p> Source code in <code>src/pytanis/communication/base.py</code> <pre><code>@abstractmethod\ndef close_ticket(self, ticket_id: str) -&gt; None:\n    \"\"\"Close a ticket\n\n    Args:\n        ticket_id: The ticket ID\n\n    Raises:\n        KeyError: If the ticket does not exist\n        IOError: If there's an error closing the ticket\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.BaseTicketClient.create_ticket","title":"<code>create_ticket(ticket: Ticket) -&gt; str</code>  <code>abstractmethod</code>","text":"<p>Create a new support ticket</p> <p>Parameters:</p> Name Type Description Default <code>ticket</code> <code>Ticket</code> <p>The ticket to create</p> required <p>Returns:</p> Type Description <code>str</code> <p>The created ticket ID</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If there's an error creating the ticket</p> Source code in <code>src/pytanis/communication/base.py</code> <pre><code>@abstractmethod\ndef create_ticket(self, ticket: Ticket) -&gt; str:\n    \"\"\"Create a new support ticket\n\n    Args:\n        ticket: The ticket to create\n\n    Returns:\n        The created ticket ID\n\n    Raises:\n        IOError: If there's an error creating the ticket\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.BaseTicketClient.get_ticket","title":"<code>get_ticket(ticket_id: str) -&gt; Ticket</code>  <code>abstractmethod</code>","text":"<p>Get a ticket by ID</p> <p>Parameters:</p> Name Type Description Default <code>ticket_id</code> <code>str</code> <p>The ticket ID</p> required <p>Returns:</p> Type Description <code>Ticket</code> <p>The ticket details</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the ticket does not exist</p> <code>IOError</code> <p>If there's an error retrieving the ticket</p> Source code in <code>src/pytanis/communication/base.py</code> <pre><code>@abstractmethod\ndef get_ticket(self, ticket_id: str) -&gt; Ticket:\n    \"\"\"Get a ticket by ID\n\n    Args:\n        ticket_id: The ticket ID\n\n    Returns:\n        The ticket details\n\n    Raises:\n        KeyError: If the ticket does not exist\n        IOError: If there's an error retrieving the ticket\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.BaseTicketClient.list_tickets","title":"<code>list_tickets(status: str | None = None, requester_email: str | None = None, limit: int = 100) -&gt; list[Ticket]</code>  <code>abstractmethod</code>","text":"<p>List tickets with optional filtering</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>str | None</code> <p>Filter by status (e.g., 'open', 'closed')</p> <code>None</code> <code>requester_email</code> <code>str | None</code> <p>Filter by requester email</p> <code>None</code> <code>limit</code> <code>int</code> <p>Maximum number of tickets to return</p> <code>100</code> <p>Returns:</p> Type Description <code>list[Ticket]</code> <p>List of tickets matching the criteria</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If there's an error listing tickets</p> Source code in <code>src/pytanis/communication/base.py</code> <pre><code>@abstractmethod\ndef list_tickets(\n    self, status: str | None = None, requester_email: str | None = None, limit: int = 100\n) -&gt; list[Ticket]:\n    \"\"\"List tickets with optional filtering\n\n    Args:\n        status: Filter by status (e.g., 'open', 'closed')\n        requester_email: Filter by requester email\n        limit: Maximum number of tickets to return\n\n    Returns:\n        List of tickets matching the criteria\n\n    Raises:\n        IOError: If there's an error listing tickets\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.BaseTicketClient.update_ticket","title":"<code>update_ticket(ticket_id: str, updates: dict[str, Any]) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Update a ticket</p> <p>Parameters:</p> Name Type Description Default <code>ticket_id</code> <code>str</code> <p>The ticket ID</p> required <code>updates</code> <code>dict[str, Any]</code> <p>Dictionary of fields to update</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the ticket does not exist</p> <code>IOError</code> <p>If there's an error updating the ticket</p> Source code in <code>src/pytanis/communication/base.py</code> <pre><code>@abstractmethod\ndef update_ticket(self, ticket_id: str, updates: dict[str, Any]) -&gt; None:\n    \"\"\"Update a ticket\n\n    Args:\n        ticket_id: The ticket ID\n        updates: Dictionary of fields to update\n\n    Raises:\n        KeyError: If the ticket does not exist\n        IOError: If there's an error updating the ticket\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.EmailMessage","title":"<code>EmailMessage(to: list[str], subject: str, body: str, html_body: str | None = None, cc: list[str] | None = None, bcc: list[str] | None = None, reply_to: str | None = None, attachments: list[tuple[str, bytes]] | None = None, headers: dict[str, str] | None = None, metadata: dict[str, Any] | None = None)</code>  <code>dataclass</code>","text":"<p>Standard email message representation</p>"},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.EmailMessage.attachments","title":"<code>attachments: list[tuple[str, bytes]] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.EmailMessage.bcc","title":"<code>bcc: list[str] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.EmailMessage.body","title":"<code>body: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.EmailMessage.cc","title":"<code>cc: list[str] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.EmailMessage.headers","title":"<code>headers: dict[str, str] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.EmailMessage.html_body","title":"<code>html_body: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.EmailMessage.metadata","title":"<code>metadata: dict[str, Any] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.EmailMessage.reply_to","title":"<code>reply_to: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.EmailMessage.subject","title":"<code>subject: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.EmailMessage.to","title":"<code>to: list[str]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.Ticket","title":"<code>Ticket(id: str | None, subject: str, description: str, requester_email: str, requester_name: str | None = None, status: str = 'open', priority: str = 'normal', tags: list[str] | None = None, custom_fields: dict[str, Any] | None = None)</code>  <code>dataclass</code>","text":"<p>Support ticket representation</p>"},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.Ticket.custom_fields","title":"<code>custom_fields: dict[str, Any] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.Ticket.description","title":"<code>description: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.Ticket.id","title":"<code>id: str | None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.Ticket.priority","title":"<code>priority: str = 'normal'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.Ticket.requester_email","title":"<code>requester_email: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.Ticket.requester_name","title":"<code>requester_name: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.Ticket.status","title":"<code>status: str = 'open'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.Ticket.subject","title":"<code>subject: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.Ticket.tags","title":"<code>tags: list[str] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.TicketComment","title":"<code>TicketComment(ticket_id: str, body: str, author_email: str, author_name: str | None = None, public: bool = True, attachments: list[tuple[str, bytes]] | None = None)</code>  <code>dataclass</code>","text":"<p>Comment on a support ticket</p>"},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.TicketComment.attachments","title":"<code>attachments: list[tuple[str, bytes]] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.TicketComment.author_email","title":"<code>author_email: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.TicketComment.author_name","title":"<code>author_name: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.TicketComment.body","title":"<code>body: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.TicketComment.public","title":"<code>public: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.TicketComment.ticket_id","title":"<code>ticket_id: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/helpdesk_adapter/","title":"Helpdesk adapter","text":""},{"location":"reference/pytanis/communication/helpdesk_adapter/#pytanis.communication.helpdesk_adapter","title":"<code>helpdesk_adapter</code>","text":"<p>HelpDesk adapter for the communication abstraction</p>"},{"location":"reference/pytanis/communication/helpdesk_adapter/#pytanis.communication.helpdesk_adapter.HelpDeskMailAdapter","title":"<code>HelpDeskMailAdapter(config: Any = None)</code>","text":"<p>HelpDesk email client adapter</p> <p>This class wraps the existing HelpDesk mail functionality to provide a consistent interface with other email providers.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Any</code> <p>Configuration object (if None, will use get_cfg())</p> <code>None</code> Source code in <code>src/pytanis/communication/helpdesk_adapter.py</code> <pre><code>def __init__(self, config: Any = None):\n    \"\"\"Initialize the HelpDesk mail adapter\n\n    Args:\n        config: Configuration object (if None, will use get_cfg())\n    \"\"\"\n    # Lazy import to avoid dependency issues\n    try:\n        from pytanis.config import get_cfg\n        from pytanis.helpdesk import HelpDeskClient, MailClient\n    except ImportError as e:\n        raise ImportError('HelpDesk dependencies not installed. Install with: pip install pytanis[helpdesk]') from e\n\n    if config is None:\n        config = get_cfg()\n\n    # Create HelpDeskClient first, then pass it to MailClient\n    helpdesk_client = HelpDeskClient()\n    self._client = MailClient(helpdesk_client=helpdesk_client)\n    self._config = config\n</code></pre>"},{"location":"reference/pytanis/communication/helpdesk_adapter/#pytanis.communication.helpdesk_adapter.HelpDeskMailAdapter.send_bulk_emails","title":"<code>send_bulk_emails(messages: list[EmailMessage], rate_limit: int | None = None) -&gt; list[str | None]</code>","text":"<p>Send multiple email messages</p> Source code in <code>src/pytanis/communication/helpdesk_adapter.py</code> <pre><code>def send_bulk_emails(self, messages: list[EmailMessage], rate_limit: int | None = None) -&gt; list[str | None]:\n    \"\"\"Send multiple email messages\"\"\"\n    # The HelpDesk MailClient handles batching internally\n    # We'll create a single Mail object with all recipients for efficiency\n    try:\n        from pytanis.helpdesk.mail import Mail, Recipient\n\n        if not messages:\n            return []\n\n        all_recipients = []\n        # Use the first message as template, assuming all have same content\n        template_message = messages[0]\n\n        for message in messages:\n            if not message.to:\n                continue\n\n            for email in message.to:\n                recipient = Recipient(\n                    name=email.split('@')[0],  # Use email prefix as name\n                    email=email,\n                )\n                all_recipients.append(recipient)\n\n        if not all_recipients:\n            return []\n\n        # Get team_id and agent_id from config (with defaults)\n        team_id = getattr(self._config, 'helpdesk_team_id', 'default_team')\n        agent_id = getattr(self._config, 'helpdesk_agent_id', 'default_agent')\n\n        # Create a single mail object with all recipients\n        mail = Mail(\n            subject=template_message.subject,\n            text=template_message.body or template_message.html_body or '',\n            team_id=team_id,\n            agent_id=agent_id,\n            recipients=all_recipients,\n            status='solved',  # Default status\n        )\n\n        # Configure rate limiting if specified\n        if rate_limit:\n            self._client.batch_size = rate_limit\n\n        # Send emails (dry_run=False to actually send)\n        tickets, errors = self._client.send(mail, dry_run=False)\n\n        # Log any errors\n        if errors:\n            for recipient, error in errors:\n                _logger.error('Failed to send to recipient', recipient=recipient.email, error=str(error))\n\n        # Create result list matching input messages\n        results: list[str | None] = []\n        ticket_map = {ticket[0].email: ticket[1] for ticket in tickets if ticket[1]}\n\n        for message in messages:\n            if message.to and message.to[0] in ticket_map:\n                # Access ID via dict since Ticket model uses extra='allow'\n                ticket = ticket_map[message.to[0]]\n                ticket_dict = ticket.model_dump()\n                results.append(str(ticket_dict.get('ID', '')))\n            else:\n                results.append(None)\n\n        return results\n\n    except Exception as e:\n        raise OSError(f'Error sending bulk emails via HelpDesk: {e}') from e\n</code></pre>"},{"location":"reference/pytanis/communication/helpdesk_adapter/#pytanis.communication.helpdesk_adapter.HelpDeskMailAdapter.send_email","title":"<code>send_email(message: EmailMessage) -&gt; str | None</code>","text":"<p>Send an email message using HelpDesk</p> Source code in <code>src/pytanis/communication/helpdesk_adapter.py</code> <pre><code>def send_email(self, message: EmailMessage) -&gt; str | None:\n    \"\"\"Send an email message using HelpDesk\"\"\"\n    try:\n        # Convert to HelpDesk format\n        from pytanis.helpdesk.mail import Mail, Recipient\n\n        if not message.to:\n            raise ValueError('No recipients specified')\n\n        # Create recipient objects for all recipients\n        recipients = []\n        for email in message.to:\n            recipient = Recipient(\n                name=email.split('@')[0],  # Use email prefix as name\n                email=email,\n            )\n            recipients.append(recipient)\n\n        # Get team_id and agent_id from config (with defaults)\n        team_id = getattr(self._config, 'helpdesk_team_id', 'default_team')\n        agent_id = getattr(self._config, 'helpdesk_agent_id', 'default_agent')\n\n        # Create mail object with required fields\n        mail = Mail(\n            subject=message.subject,\n            text=message.body or message.html_body or '',\n            team_id=team_id,\n            agent_id=agent_id,\n            recipients=recipients,\n            status='solved',  # Default status\n        )\n\n        # Send email (dry_run=False to actually send)\n        tickets, errors = self._client.send(mail, dry_run=False)\n\n        # Log any errors\n        if errors:\n            for recipient, error in errors:\n                _logger.error('Failed to send to recipient', recipient=recipient.email, error=str(error))\n\n        # Handle CC recipients warning\n        if message.cc:\n            _logger.warning(\n                'HelpDesk adapter does not support CC recipients. CC recipients ignored.',\n                cc=message.cc,\n            )\n\n        # Return the first ticket ID if successful\n        if tickets and tickets[0][1]:\n            # Access ID via dict since Ticket model uses extra='allow'\n            ticket_dict = tickets[0][1].model_dump()\n            return str(ticket_dict.get('ID', ''))\n        return None\n\n    except Exception as e:\n        raise OSError(f'Error sending email via HelpDesk: {e}') from e\n</code></pre>"},{"location":"reference/pytanis/communication/helpdesk_adapter/#pytanis.communication.helpdesk_adapter.HelpDeskTicketAdapter","title":"<code>HelpDeskTicketAdapter(config: Any = None)</code>","text":"<p>HelpDesk ticket client adapter</p> <p>This class wraps the existing HelpDesk client to provide a consistent interface with other ticket providers.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Any</code> <p>Configuration object (if None, will use get_cfg())</p> <code>None</code> Source code in <code>src/pytanis/communication/helpdesk_adapter.py</code> <pre><code>def __init__(self, config: Any = None):\n    \"\"\"Initialize the HelpDesk ticket adapter\n\n    Args:\n        config: Configuration object (if None, will use get_cfg())\n    \"\"\"\n    # Lazy import to avoid dependency issues\n    try:\n        from pytanis.config import get_cfg\n        from pytanis.helpdesk import HelpDeskClient\n    except ImportError as e:\n        raise ImportError('HelpDesk dependencies not installed. Install with: pip install pytanis[helpdesk]') from e\n\n    if config is None:\n        config = get_cfg()\n    self._client = HelpDeskClient()\n    self._config = config\n</code></pre>"},{"location":"reference/pytanis/communication/helpdesk_adapter/#pytanis.communication.helpdesk_adapter.HelpDeskTicketAdapter.add_comment","title":"<code>add_comment(comment: TicketComment) -&gt; str</code>","text":"<p>Add a comment to a ticket</p> Source code in <code>src/pytanis/communication/helpdesk_adapter.py</code> <pre><code>def add_comment(self, comment: TicketComment) -&gt; str:\n    \"\"\"Add a comment to a ticket\"\"\"\n    # HelpDesk client doesn't have an add_comment method in the current implementation\n    raise NotImplementedError('HelpDesk adapter does not support adding comments yet')\n</code></pre>"},{"location":"reference/pytanis/communication/helpdesk_adapter/#pytanis.communication.helpdesk_adapter.HelpDeskTicketAdapter.close_ticket","title":"<code>close_ticket(ticket_id: str) -&gt; None</code>","text":"<p>Close a ticket</p> Source code in <code>src/pytanis/communication/helpdesk_adapter.py</code> <pre><code>def close_ticket(self, ticket_id: str) -&gt; None:\n    \"\"\"Close a ticket\"\"\"\n    # HelpDesk client doesn't have a close_ticket method in the current implementation\n    raise NotImplementedError('HelpDesk adapter does not support closing tickets yet')\n</code></pre>"},{"location":"reference/pytanis/communication/helpdesk_adapter/#pytanis.communication.helpdesk_adapter.HelpDeskTicketAdapter.create_ticket","title":"<code>create_ticket(ticket: Ticket) -&gt; str</code>","text":"<p>Create a new support ticket</p> Source code in <code>src/pytanis/communication/helpdesk_adapter.py</code> <pre><code>def create_ticket(self, ticket: Ticket) -&gt; str:\n    \"\"\"Create a new support ticket\"\"\"\n    try:\n        from pytanis.helpdesk.models import Assignment, Id, Message, NewTicket, Requester\n\n        # Create requester object\n        requester = Requester(\n            email=ticket.requester_email,\n            name=ticket.requester_name or ticket.requester_email.split('@')[0],\n        )\n\n        # Create message object\n        message = Message(text=ticket.description)\n\n        # Get team_id and agent_id from config (with defaults)\n        team_id = getattr(self._config, 'helpdesk_team_id', 'default_team')\n        agent_id = getattr(self._config, 'helpdesk_agent_id', 'default_agent')\n\n        # Create assignment if we have team and agent IDs\n        assignment = None\n        team_ids = None\n        if team_id and agent_id:\n            assignment = Assignment(\n                team=Id(ID=team_id),\n                agent=Id(ID=agent_id),\n            )\n            team_ids = [team_id]\n\n        # Convert to HelpDesk format\n        new_ticket = NewTicket(\n            subject=ticket.subject,\n            message=message,\n            requester=requester,\n            status=ticket.status or 'open',\n            assignment=assignment,\n            teamIDs=team_ids,\n        )\n\n        # Create ticket\n        result = self._client.create_ticket(new_ticket)\n\n        # Extract ticket ID from result\n        if isinstance(result, dict) and 'ID' in result:\n            return str(result['ID'])\n        return str(result)\n\n    except Exception as e:\n        raise OSError(f'Error creating ticket: {e}') from e\n</code></pre>"},{"location":"reference/pytanis/communication/helpdesk_adapter/#pytanis.communication.helpdesk_adapter.HelpDeskTicketAdapter.get_ticket","title":"<code>get_ticket(ticket_id: str) -&gt; Ticket</code>","text":"<p>Get a ticket by ID</p> Source code in <code>src/pytanis/communication/helpdesk_adapter.py</code> <pre><code>def get_ticket(self, ticket_id: str) -&gt; Ticket:\n    \"\"\"Get a ticket by ID\"\"\"\n    # HelpDesk client doesn't have a get_ticket method in the current implementation\n    raise NotImplementedError('HelpDesk adapter does not support getting tickets yet')\n</code></pre>"},{"location":"reference/pytanis/communication/helpdesk_adapter/#pytanis.communication.helpdesk_adapter.HelpDeskTicketAdapter.list_tickets","title":"<code>list_tickets(status: str | None = None, requester_email: str | None = None, limit: int = 100) -&gt; list[Ticket]</code>","text":"<p>List tickets with optional filtering</p> Source code in <code>src/pytanis/communication/helpdesk_adapter.py</code> <pre><code>def list_tickets(\n    self, status: str | None = None, requester_email: str | None = None, limit: int = 100\n) -&gt; list[Ticket]:\n    \"\"\"List tickets with optional filtering\"\"\"\n    # HelpDesk client doesn't have a list_tickets method in the current implementation\n    raise NotImplementedError('HelpDesk adapter does not support listing tickets yet')\n</code></pre>"},{"location":"reference/pytanis/communication/helpdesk_adapter/#pytanis.communication.helpdesk_adapter.HelpDeskTicketAdapter.update_ticket","title":"<code>update_ticket(ticket_id: str, updates: dict[str, Any]) -&gt; None</code>","text":"<p>Update a ticket</p> Source code in <code>src/pytanis/communication/helpdesk_adapter.py</code> <pre><code>def update_ticket(self, ticket_id: str, updates: dict[str, Any]) -&gt; None:\n    \"\"\"Update a ticket\"\"\"\n    # HelpDesk client doesn't have an update_ticket method in the current implementation\n    raise NotImplementedError('HelpDesk adapter does not support updating tickets yet')\n</code></pre>"},{"location":"reference/pytanis/communication/mailgun_adapter/","title":"Mailgun adapter","text":""},{"location":"reference/pytanis/communication/mailgun_adapter/#pytanis.communication.mailgun_adapter","title":"<code>mailgun_adapter</code>","text":"<p>Mailgun adapter for the communication abstraction</p>"},{"location":"reference/pytanis/communication/mailgun_adapter/#pytanis.communication.mailgun_adapter.MailgunAdapter","title":"<code>MailgunAdapter(config: Any = None)</code>","text":"<p>Mailgun email client adapter</p> <p>This class wraps the existing Mailgun functionality to provide a consistent interface with other email providers.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Any</code> <p>Configuration object (if None, will use get_cfg())</p> <code>None</code> Source code in <code>src/pytanis/communication/mailgun_adapter.py</code> <pre><code>def __init__(self, config: Any = None):\n    \"\"\"Initialize the Mailgun adapter\n\n    Args:\n        config: Configuration object (if None, will use get_cfg())\n    \"\"\"\n    # Lazy import to avoid dependency issues\n    try:\n        from pytanis.config import get_cfg\n        from pytanis.mailgun.mail import MailClient\n    except ImportError as e:\n        msg = 'Mailgun dependencies not installed. Install with: pip install pytanis[mailgun]'\n        raise ImportError(msg) from e\n\n    if config is None:\n        config = get_cfg()\n    self._client = MailClient(config=config)\n    self._config = config\n</code></pre>"},{"location":"reference/pytanis/communication/mailgun_adapter/#pytanis.communication.mailgun_adapter.MailgunAdapter.send_bulk_emails","title":"<code>send_bulk_emails(messages: list[EmailMessage], rate_limit: int | None = None) -&gt; list[str | None]</code>","text":"<p>Send multiple email messages</p> <p>Note: This implementation sends emails individually as the Mailgun client handles batching internally based on its batch_size configuration.</p> Source code in <code>src/pytanis/communication/mailgun_adapter.py</code> <pre><code>def send_bulk_emails(self, messages: list[EmailMessage], rate_limit: int | None = None) -&gt; list[str | None]:\n    \"\"\"Send multiple email messages\n\n    Note: This implementation sends emails individually as the Mailgun client\n    handles batching internally based on its batch_size configuration.\n    \"\"\"\n    results = []\n\n    # If rate limit is specified, override the client's wait time\n    if rate_limit:\n        original_batch_size = self._client.batch_size\n        original_wait_time = self._client.wait_time\n        self._client.batch_size = 1  # Send one at a time\n        self._client.wait_time = int(1.0 / rate_limit)\n\n    try:\n        for i, message in enumerate(messages):\n            try:\n                # For bulk sends, we could optimize by creating a single Mail object\n                # with all recipients if all messages have the same subject/body\n                msg_id = self.send_email(message)\n                results.append(msg_id)\n\n            except Exception as e:\n                _logger.error('Failed to send email', error=str(e), index=i, to=message.to)\n                results.append(None)\n\n    finally:\n        # Restore original settings if we modified them\n        if rate_limit:\n            self._client.batch_size = original_batch_size\n            self._client.wait_time = original_wait_time\n\n    return results\n</code></pre>"},{"location":"reference/pytanis/communication/mailgun_adapter/#pytanis.communication.mailgun_adapter.MailgunAdapter.send_email","title":"<code>send_email(message: EmailMessage) -&gt; str | None</code>","text":"<p>Send an email message using Mailgun</p> Source code in <code>src/pytanis/communication/mailgun_adapter.py</code> <pre><code>def send_email(self, message: EmailMessage) -&gt; str | None:\n    \"\"\"Send an email message using Mailgun\"\"\"\n    try:\n        # Convert to Mailgun format\n        from pytanis.mailgun.mail import Mail, Recipient\n\n        # Extract recipients\n        if not message.to:\n            msg = 'No recipients specified'\n            raise ValueError(msg)\n\n        # Create recipient objects for all recipients\n        recipients = []\n        for email in message.to:\n            # Extract name from email if no metadata is provided\n            name = email.split('@')[0]\n            recipients.append(\n                Recipient(\n                    name=name,\n                    email=email,\n                )\n            )\n\n        # Create mail object with correct parameters\n        mail = Mail(\n            subject=message.subject,\n            body=message.body,\n            recipients=recipients,\n        )\n\n        # Send email using the correct method name\n        responses, errors = self._client.send(mail)\n\n        # Check for errors\n        if errors:\n            error_msgs = [f'{recipient.email}: {error!s}' for recipient, error in errors]\n            _logger.error('Errors sending emails', errors=error_msgs)\n            if not responses:\n                msg = f'All emails failed: {\"; \".join(error_msgs)}'\n                raise OSError(msg)\n\n        # Handle additional recipients as CC/BCC (not supported by current Mailgun implementation)\n        if message.cc or message.bcc:\n            _logger.warning(\n                'Mailgun adapter currently does not support CC/BCC recipients.',\n                cc=message.cc,\n                bcc=message.bcc,\n            )\n\n        # Return the first response ID if available\n        if responses and hasattr(responses[0], 'json'):\n            return responses[0].json().get('id')\n\n        return None\n\n    except Exception as e:\n        msg = f'Error sending email via Mailgun: {e}'\n        raise OSError(msg) from e\n</code></pre>"},{"location":"reference/pytanis/helpdesk/","title":"Helpdesk","text":""},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk","title":"<code>helpdesk</code>","text":"<p>Functionality around the HelpDesk / LiveChat API</p>"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.__all__","title":"<code>__all__ = ['HelpDeskClient', 'Mail', 'MailClient', 'Recipient']</code>  <code>module-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.HelpDeskClient","title":"<code>HelpDeskClient(config: Config | None = None)</code>","text":"Source code in <code>src/pytanis/helpdesk/client.py</code> <pre><code>def __init__(self, config: Config | None = None):\n    if config is None:\n        config = get_cfg()\n    self._config = config\n    # Important: Always use a custom User-Agent, never a generic one.\n    # Generic User-Agents are filtered by helpdesk to reduce spam.\n    self._headers = {'User-Agent': 'Pytanis'}\n\n    self._get_throttled = self._get\n    self._post_throttled = self._post\n    self.set_throttling(calls=1, seconds=10)  # Helpdesk is really strange when it comes to this\n</code></pre>"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.HelpDeskClient.create_ticket","title":"<code>create_ticket(ticket: NewTicket)</code>","text":"Source code in <code>src/pytanis/helpdesk/client.py</code> <pre><code>def create_ticket(self, ticket: NewTicket):\n    return self.post('tickets', data=ticket.model_dump())\n</code></pre>"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.HelpDeskClient.get","title":"<code>get(endpoint: str, params: QueryParams | None = None) -&gt; JSON</code>","text":"<p>Retrieve data via throttled GET request and return the JSON</p> Source code in <code>src/pytanis/helpdesk/client.py</code> <pre><code>def get(self, endpoint: str, params: QueryParams | None = None) -&gt; JSON:\n    \"\"\"Retrieve data via throttled GET request and return the JSON\"\"\"\n    resp = self._get_throttled(endpoint, params)\n    resp.raise_for_status()\n    return resp.json()\n</code></pre>"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.HelpDeskClient.list_agents","title":"<code>list_agents() -&gt; list[Agent]</code>","text":"Source code in <code>src/pytanis/helpdesk/client.py</code> <pre><code>def list_agents(self) -&gt; list[Agent]:\n    agents = self.get('agents')\n    if not isinstance(agents, list):\n        msg = 'Received JSON is not a list object'\n        raise ValueError(msg)\n    return [Agent.model_validate(dct) for dct in agents]\n</code></pre>"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.HelpDeskClient.list_teams","title":"<code>list_teams() -&gt; list[Team]</code>","text":"Source code in <code>src/pytanis/helpdesk/client.py</code> <pre><code>def list_teams(self) -&gt; list[Team]:\n    teams = self.get('teams')\n    if not isinstance(teams, list):\n        msg = 'Received JSON is not a list object'\n        raise ValueError(msg)\n    return [Team.model_validate(dct) for dct in teams]\n</code></pre>"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.HelpDeskClient.post","title":"<code>post(endpoint: str, data: dict[str, Any], params: QueryParams | None = None) -&gt; JSON</code>","text":"Source code in <code>src/pytanis/helpdesk/client.py</code> <pre><code>def post(self, endpoint: str, data: dict[str, Any], params: QueryParams | None = None) -&gt; JSON:\n    resp = self._post_throttled(endpoint, data, params)\n    resp.raise_for_status()\n    return resp.json()\n</code></pre>"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.HelpDeskClient.set_throttling","title":"<code>set_throttling(calls: int, seconds: int)</code>","text":"<p>Throttle the number of calls per seconds to the Pretalx API</p> Source code in <code>src/pytanis/helpdesk/client.py</code> <pre><code>def set_throttling(self, calls: int, seconds: int):\n    \"\"\"Throttle the number of calls per seconds to the Pretalx API\"\"\"\n    _logger.debug('throttling', calls=calls, seconds=seconds)\n    self._get_throttled = throttle(calls, seconds)(self._get)\n    self._post_throttled = throttle(calls, seconds)(self._post)\n</code></pre>"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.Mail","title":"<code>Mail</code>","text":"<p>Mail template</p> <p>Use the <code>data</code> field to store additional information</p> <p>You can use the typical Format String Syntax and the objects <code>recipient</code> and <code>mail</code> to access metadata to complement the template, e.g.:</p> <pre><code>Hello {recipient.address_as},\n\nWe hope it's ok to address you your first name rather than using your full name being {recipient.name}.\nHave you read the email's subject '{mail.subject}'? How is your work right now at {recipient.data.company}?\n\nCheers!\n</code></pre>"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.Mail.agent_id","title":"<code>agent_id: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.Mail.data","title":"<code>data: MetaData | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.Mail.recipients","title":"<code>recipients: list[Recipient]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.Mail.status","title":"<code>status: str = 'solved'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.Mail.subject","title":"<code>subject: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.Mail.team_id","title":"<code>team_id: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.Mail.text","title":"<code>text: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.MailClient","title":"<code>MailClient(helpdesk_client: HelpDeskClient | None = None)</code>","text":"<p>Mail client for mass mails over HelpDesk</p> Source code in <code>src/pytanis/helpdesk/mail.py</code> <pre><code>def __init__(self, helpdesk_client: HelpDeskClient | None = None):\n    if helpdesk_client is None:\n        helpdesk_client = HelpDeskClient()\n    self._helpdesk_client = helpdesk_client\n    self.dry_run: Callable[[NewTicket], None] = self.print_new_ticket\n</code></pre>"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.MailClient.batch_size","title":"<code>batch_size: int = 10</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.MailClient.dry_run","title":"<code>dry_run: Callable[[NewTicket], None] = self.print_new_ticket</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.MailClient.wait_time","title":"<code>wait_time: int = 20</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.MailClient.print_new_ticket","title":"<code>print_new_ticket(ticket: NewTicket)</code>  <code>staticmethod</code>","text":"<p>Default action in a dry-run. Mainly for making sure you sent what you mean!</p> <p>Overwrite it by assigning to self.dry_run another function</p> <p>ToDo: Make this function nice, maybe use the <code>rich</code> library even</p> Source code in <code>src/pytanis/helpdesk/mail.py</code> <pre><code>@staticmethod\ndef print_new_ticket(ticket: NewTicket):\n    \"\"\"Default action in a dry-run. Mainly for making sure you sent what you mean!\n\n    Overwrite it by assigning to self.dry_run another function\n\n    ToDo: Make this function nice, maybe use the `rich` library even\n    \"\"\"\n    print('#' * 40)  # noqa: T201\n    print(f'Recipient: {ticket.requester.name} &lt;{ticket.requester.email}&gt;')  # noqa: T201\n    print(f'Subject: {ticket.subject}')  # noqa: T201\n    print(f'{ticket.message.text}')  # noqa: T201\n</code></pre>"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.MailClient.send","title":"<code>send(mail: Mail, *, dry_run: bool = True) -&gt; tuple[list[tuple[Recipient, Ticket | None]], list[tuple[Recipient, Exception]]]</code>","text":"<p>Send a mail to all recipients using HelpDesk</p> Source code in <code>src/pytanis/helpdesk/mail.py</code> <pre><code>def send(\n    self, mail: Mail, *, dry_run: bool = True\n) -&gt; tuple[list[tuple[Recipient, Ticket | None]], list[tuple[Recipient, Exception]]]:\n    \"\"\"Send a mail to all recipients using HelpDesk\"\"\"\n    errors = []\n    tickets = []\n    for idx, recipient in enumerate(tqdm(mail.recipients), start=1):\n        recip_mail = mail.model_copy()\n        try:\n            recip_mail.subject = mail.subject.format(recipient=recipient, mail=mail)\n            # be aware here that the body might reference to subject line, so it must be filled already\n            recip_mail.text = recip_mail.text.format(recipient=recipient, mail=recip_mail)\n            ticket = self._create_ticket(recip_mail, recipient)\n            if dry_run:\n                self.print_new_ticket(ticket)\n                resp_ticket = None\n            else:\n                resp = self._helpdesk_client.create_ticket(ticket)\n                resp_ticket = Ticket.model_validate(resp)\n        except Exception as e:\n            errors.append((recipient, e))\n        else:\n            tickets.append((recipient, resp_ticket))\n        if (idx % self.batch_size == 0) and not dry_run:\n            time.sleep(self.wait_time)\n\n    return tickets, errors\n</code></pre>"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.Recipient","title":"<code>Recipient</code>","text":"<p>Details about the recipient</p> <p>Use the <code>data</code> field to store additional information</p>"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.Recipient.address_as","title":"<code>address_as: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.Recipient.data","title":"<code>data: MetaData | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.Recipient.email","title":"<code>email: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.Recipient.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.Recipient.fill_with_name","title":"<code>fill_with_name(v, values)</code>  <code>classmethod</code>","text":"Source code in <code>src/pytanis/helpdesk/mail.py</code> <pre><code>@field_validator('address_as')\n@classmethod\ndef fill_with_name(cls, v, values):\n    if v is None:\n        v = values['name']\n    return v\n</code></pre>"},{"location":"reference/pytanis/helpdesk/client/","title":"Client","text":""},{"location":"reference/pytanis/helpdesk/client/#pytanis.helpdesk.client","title":"<code>client</code>","text":"<p>Client for the HelpDesk / LiveChat API</p> <p>Documentation: https://api.helpdesk.com/docs</p> <p>ToDo</p> <ul> <li>Transfer more functionality from PYCONDE/py_helpdesk_com</li> </ul>"},{"location":"reference/pytanis/helpdesk/client/#pytanis.helpdesk.client.JSON","title":"<code>JSON: TypeAlias = JSONObj | JSONLst</code>  <code>module-attribute</code>","text":"<p>Type of the JSON response as returned by the HelpDesk / LiveChat API</p>"},{"location":"reference/pytanis/helpdesk/client/#pytanis.helpdesk.client.JSONLst","title":"<code>JSONLst: TypeAlias = list[JSONObj]</code>  <code>module-attribute</code>","text":"<p>Type of a JSON list of JSON objects</p>"},{"location":"reference/pytanis/helpdesk/client/#pytanis.helpdesk.client.JSONObj","title":"<code>JSONObj: TypeAlias = dict[str, Any]</code>  <code>module-attribute</code>","text":"<p>Type of a JSON object (without recursion)</p>"},{"location":"reference/pytanis/helpdesk/client/#pytanis.helpdesk.client.HelpDeskClient","title":"<code>HelpDeskClient(config: Config | None = None)</code>","text":"Source code in <code>src/pytanis/helpdesk/client.py</code> <pre><code>def __init__(self, config: Config | None = None):\n    if config is None:\n        config = get_cfg()\n    self._config = config\n    # Important: Always use a custom User-Agent, never a generic one.\n    # Generic User-Agents are filtered by helpdesk to reduce spam.\n    self._headers = {'User-Agent': 'Pytanis'}\n\n    self._get_throttled = self._get\n    self._post_throttled = self._post\n    self.set_throttling(calls=1, seconds=10)  # Helpdesk is really strange when it comes to this\n</code></pre>"},{"location":"reference/pytanis/helpdesk/client/#pytanis.helpdesk.client.HelpDeskClient.create_ticket","title":"<code>create_ticket(ticket: NewTicket)</code>","text":"Source code in <code>src/pytanis/helpdesk/client.py</code> <pre><code>def create_ticket(self, ticket: NewTicket):\n    return self.post('tickets', data=ticket.model_dump())\n</code></pre>"},{"location":"reference/pytanis/helpdesk/client/#pytanis.helpdesk.client.HelpDeskClient.get","title":"<code>get(endpoint: str, params: QueryParams | None = None) -&gt; JSON</code>","text":"<p>Retrieve data via throttled GET request and return the JSON</p> Source code in <code>src/pytanis/helpdesk/client.py</code> <pre><code>def get(self, endpoint: str, params: QueryParams | None = None) -&gt; JSON:\n    \"\"\"Retrieve data via throttled GET request and return the JSON\"\"\"\n    resp = self._get_throttled(endpoint, params)\n    resp.raise_for_status()\n    return resp.json()\n</code></pre>"},{"location":"reference/pytanis/helpdesk/client/#pytanis.helpdesk.client.HelpDeskClient.list_agents","title":"<code>list_agents() -&gt; list[Agent]</code>","text":"Source code in <code>src/pytanis/helpdesk/client.py</code> <pre><code>def list_agents(self) -&gt; list[Agent]:\n    agents = self.get('agents')\n    if not isinstance(agents, list):\n        msg = 'Received JSON is not a list object'\n        raise ValueError(msg)\n    return [Agent.model_validate(dct) for dct in agents]\n</code></pre>"},{"location":"reference/pytanis/helpdesk/client/#pytanis.helpdesk.client.HelpDeskClient.list_teams","title":"<code>list_teams() -&gt; list[Team]</code>","text":"Source code in <code>src/pytanis/helpdesk/client.py</code> <pre><code>def list_teams(self) -&gt; list[Team]:\n    teams = self.get('teams')\n    if not isinstance(teams, list):\n        msg = 'Received JSON is not a list object'\n        raise ValueError(msg)\n    return [Team.model_validate(dct) for dct in teams]\n</code></pre>"},{"location":"reference/pytanis/helpdesk/client/#pytanis.helpdesk.client.HelpDeskClient.post","title":"<code>post(endpoint: str, data: dict[str, Any], params: QueryParams | None = None) -&gt; JSON</code>","text":"Source code in <code>src/pytanis/helpdesk/client.py</code> <pre><code>def post(self, endpoint: str, data: dict[str, Any], params: QueryParams | None = None) -&gt; JSON:\n    resp = self._post_throttled(endpoint, data, params)\n    resp.raise_for_status()\n    return resp.json()\n</code></pre>"},{"location":"reference/pytanis/helpdesk/client/#pytanis.helpdesk.client.HelpDeskClient.set_throttling","title":"<code>set_throttling(calls: int, seconds: int)</code>","text":"<p>Throttle the number of calls per seconds to the Pretalx API</p> Source code in <code>src/pytanis/helpdesk/client.py</code> <pre><code>def set_throttling(self, calls: int, seconds: int):\n    \"\"\"Throttle the number of calls per seconds to the Pretalx API\"\"\"\n    _logger.debug('throttling', calls=calls, seconds=seconds)\n    self._get_throttled = throttle(calls, seconds)(self._get)\n    self._post_throttled = throttle(calls, seconds)(self._post)\n</code></pre>"},{"location":"reference/pytanis/helpdesk/mail/","title":"Mail","text":""},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail","title":"<code>mail</code>","text":"<p>Functionality around mailing</p> <p>ToDo</p> <ul> <li>add logging where appropriate</li> <li>Find out why <code>extra=Extra.allow</code> causes mypy to fail. Seems like a bug in pydantic.</li> <li>Sending mails is quite slow, so using <code>tqdm</code> to show feedback to the current progress would be nice</li> </ul>"},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Mail","title":"<code>Mail</code>","text":"<p>Mail template</p> <p>Use the <code>data</code> field to store additional information</p> <p>You can use the typical Format String Syntax and the objects <code>recipient</code> and <code>mail</code> to access metadata to complement the template, e.g.:</p> <pre><code>Hello {recipient.address_as},\n\nWe hope it's ok to address you your first name rather than using your full name being {recipient.name}.\nHave you read the email's subject '{mail.subject}'? How is your work right now at {recipient.data.company}?\n\nCheers!\n</code></pre>"},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Mail.agent_id","title":"<code>agent_id: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Mail.data","title":"<code>data: MetaData | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Mail.recipients","title":"<code>recipients: list[Recipient]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Mail.status","title":"<code>status: str = 'solved'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Mail.subject","title":"<code>subject: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Mail.team_id","title":"<code>team_id: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Mail.text","title":"<code>text: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.MailClient","title":"<code>MailClient(helpdesk_client: HelpDeskClient | None = None)</code>","text":"<p>Mail client for mass mails over HelpDesk</p> Source code in <code>src/pytanis/helpdesk/mail.py</code> <pre><code>def __init__(self, helpdesk_client: HelpDeskClient | None = None):\n    if helpdesk_client is None:\n        helpdesk_client = HelpDeskClient()\n    self._helpdesk_client = helpdesk_client\n    self.dry_run: Callable[[NewTicket], None] = self.print_new_ticket\n</code></pre>"},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.MailClient.batch_size","title":"<code>batch_size: int = 10</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.MailClient.dry_run","title":"<code>dry_run: Callable[[NewTicket], None] = self.print_new_ticket</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.MailClient.wait_time","title":"<code>wait_time: int = 20</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.MailClient.print_new_ticket","title":"<code>print_new_ticket(ticket: NewTicket)</code>  <code>staticmethod</code>","text":"<p>Default action in a dry-run. Mainly for making sure you sent what you mean!</p> <p>Overwrite it by assigning to self.dry_run another function</p> <p>ToDo: Make this function nice, maybe use the <code>rich</code> library even</p> Source code in <code>src/pytanis/helpdesk/mail.py</code> <pre><code>@staticmethod\ndef print_new_ticket(ticket: NewTicket):\n    \"\"\"Default action in a dry-run. Mainly for making sure you sent what you mean!\n\n    Overwrite it by assigning to self.dry_run another function\n\n    ToDo: Make this function nice, maybe use the `rich` library even\n    \"\"\"\n    print('#' * 40)  # noqa: T201\n    print(f'Recipient: {ticket.requester.name} &lt;{ticket.requester.email}&gt;')  # noqa: T201\n    print(f'Subject: {ticket.subject}')  # noqa: T201\n    print(f'{ticket.message.text}')  # noqa: T201\n</code></pre>"},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.MailClient.send","title":"<code>send(mail: Mail, *, dry_run: bool = True) -&gt; tuple[list[tuple[Recipient, Ticket | None]], list[tuple[Recipient, Exception]]]</code>","text":"<p>Send a mail to all recipients using HelpDesk</p> Source code in <code>src/pytanis/helpdesk/mail.py</code> <pre><code>def send(\n    self, mail: Mail, *, dry_run: bool = True\n) -&gt; tuple[list[tuple[Recipient, Ticket | None]], list[tuple[Recipient, Exception]]]:\n    \"\"\"Send a mail to all recipients using HelpDesk\"\"\"\n    errors = []\n    tickets = []\n    for idx, recipient in enumerate(tqdm(mail.recipients), start=1):\n        recip_mail = mail.model_copy()\n        try:\n            recip_mail.subject = mail.subject.format(recipient=recipient, mail=mail)\n            # be aware here that the body might reference to subject line, so it must be filled already\n            recip_mail.text = recip_mail.text.format(recipient=recipient, mail=recip_mail)\n            ticket = self._create_ticket(recip_mail, recipient)\n            if dry_run:\n                self.print_new_ticket(ticket)\n                resp_ticket = None\n            else:\n                resp = self._helpdesk_client.create_ticket(ticket)\n                resp_ticket = Ticket.model_validate(resp)\n        except Exception as e:\n            errors.append((recipient, e))\n        else:\n            tickets.append((recipient, resp_ticket))\n        if (idx % self.batch_size == 0) and not dry_run:\n            time.sleep(self.wait_time)\n\n    return tickets, errors\n</code></pre>"},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.MetaData","title":"<code>MetaData</code>","text":"<p>Additional, arbitrary metadata provided by the user like for template filling</p>"},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.MetaData.model_config","title":"<code>model_config = ConfigDict(extra='allow')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Recipient","title":"<code>Recipient</code>","text":"<p>Details about the recipient</p> <p>Use the <code>data</code> field to store additional information</p>"},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Recipient.address_as","title":"<code>address_as: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Recipient.data","title":"<code>data: MetaData | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Recipient.email","title":"<code>email: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Recipient.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Recipient.fill_with_name","title":"<code>fill_with_name(v, values)</code>  <code>classmethod</code>","text":"Source code in <code>src/pytanis/helpdesk/mail.py</code> <pre><code>@field_validator('address_as')\n@classmethod\ndef fill_with_name(cls, v, values):\n    if v is None:\n        v = values['name']\n    return v\n</code></pre>"},{"location":"reference/pytanis/helpdesk/models/","title":"Models","text":""},{"location":"reference/pytanis/helpdesk/models/#pytanis.helpdesk.models","title":"<code>models</code>","text":"<p>Return types of the HelpDesk / LiveChat API</p> <p>Documentation: https://api.helpdesk.com/docs</p> <p>ToDo</p> <ul> <li>Implement the types below correctly instead of using <code>Extra.Allow</code></li> <li>Find out why <code>extra=Extra.allow</code> causes mypy to fail. Seems like a bug in pydantic.</li> </ul>"},{"location":"reference/pytanis/helpdesk/models/#pytanis.helpdesk.models.Agent","title":"<code>Agent</code>","text":""},{"location":"reference/pytanis/helpdesk/models/#pytanis.helpdesk.models.Agent.model_config","title":"<code>model_config = ConfigDict(extra='allow')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/models/#pytanis.helpdesk.models.Assignment","title":"<code>Assignment</code>","text":""},{"location":"reference/pytanis/helpdesk/models/#pytanis.helpdesk.models.Assignment.agent","title":"<code>agent: Id</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/models/#pytanis.helpdesk.models.Assignment.model_config","title":"<code>model_config = ConfigDict(extra='allow')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/models/#pytanis.helpdesk.models.Assignment.team","title":"<code>team: Id</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/models/#pytanis.helpdesk.models.Id","title":"<code>Id</code>","text":""},{"location":"reference/pytanis/helpdesk/models/#pytanis.helpdesk.models.Id.ID","title":"<code>ID: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/models/#pytanis.helpdesk.models.Message","title":"<code>Message</code>","text":""},{"location":"reference/pytanis/helpdesk/models/#pytanis.helpdesk.models.Message.model_config","title":"<code>model_config = ConfigDict(extra='allow')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/models/#pytanis.helpdesk.models.Message.text","title":"<code>text: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/models/#pytanis.helpdesk.models.NewTicket","title":"<code>NewTicket</code>","text":"<p>Object that needs to be sent when creating a NEW ticket</p>"},{"location":"reference/pytanis/helpdesk/models/#pytanis.helpdesk.models.NewTicket.assignment","title":"<code>assignment: Assignment | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/models/#pytanis.helpdesk.models.NewTicket.message","title":"<code>message: Message</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/models/#pytanis.helpdesk.models.NewTicket.model_config","title":"<code>model_config = ConfigDict(extra='allow')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/models/#pytanis.helpdesk.models.NewTicket.requester","title":"<code>requester: Requester</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/models/#pytanis.helpdesk.models.NewTicket.status","title":"<code>status: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/models/#pytanis.helpdesk.models.NewTicket.subject","title":"<code>subject: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/models/#pytanis.helpdesk.models.NewTicket.teamIDs","title":"<code>teamIDs: list[str] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/models/#pytanis.helpdesk.models.Requester","title":"<code>Requester</code>","text":""},{"location":"reference/pytanis/helpdesk/models/#pytanis.helpdesk.models.Requester.email","title":"<code>email: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/models/#pytanis.helpdesk.models.Requester.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/models/#pytanis.helpdesk.models.Team","title":"<code>Team</code>","text":""},{"location":"reference/pytanis/helpdesk/models/#pytanis.helpdesk.models.Team.model_config","title":"<code>model_config = ConfigDict(extra='allow')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/models/#pytanis.helpdesk.models.Ticket","title":"<code>Ticket</code>","text":"<p>Actual ticket as returned by the API</p>"},{"location":"reference/pytanis/helpdesk/models/#pytanis.helpdesk.models.Ticket.model_config","title":"<code>model_config = ConfigDict(extra='allow')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/mailgun/","title":"Mailgun","text":""},{"location":"reference/pytanis/mailgun/#pytanis.mailgun","title":"<code>mailgun</code>","text":"<p>Functionality around the Mailgun API</p>"},{"location":"reference/pytanis/mailgun/#pytanis.mailgun.__all__","title":"<code>__all__ = ['Mail', 'MailClient', 'Recipient']</code>  <code>module-attribute</code>","text":""},{"location":"reference/pytanis/mailgun/#pytanis.mailgun.Mail","title":"<code>Mail</code>","text":"<p>Mail template</p> <p>Use the <code>data</code> field to store additional information</p> <p>You can use the typical Format String Syntax and the objects <code>recipient</code> and <code>mail</code> to access metadata to complement the template, e.g.:</p> <pre><code>Hello {recipient.address_as},\n\nWe hope it's ok to address you your first name rather than using your full name being {recipient.name}.\nHave you read the email's subject '{mail.subject}'? How is your work right now at {recipient.data.company}?\n\nCheers!\n</code></pre>"},{"location":"reference/pytanis/mailgun/#pytanis.mailgun.Mail.body","title":"<code>body: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/mailgun/#pytanis.mailgun.Mail.data","title":"<code>data: MetaData | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/mailgun/#pytanis.mailgun.Mail.recipients","title":"<code>recipients: list[Recipient]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/mailgun/#pytanis.mailgun.Mail.subject","title":"<code>subject: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/mailgun/#pytanis.mailgun.MailClient","title":"<code>MailClient(config: Config | None = None)</code>","text":"<p>Mail client for mass mails via Mailgun</p> Source code in <code>src/pytanis/mailgun/mail.py</code> <pre><code>def __init__(self, config: Config | None = None):\n    if config is None:\n        config = get_cfg()\n    self._config = config\n</code></pre>"},{"location":"reference/pytanis/mailgun/#pytanis.mailgun.MailClient.batch_size","title":"<code>batch_size: int = 10</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/mailgun/#pytanis.mailgun.MailClient.timeout","title":"<code>timeout: int = 10</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/mailgun/#pytanis.mailgun.MailClient.wait_time","title":"<code>wait_time: int = 20</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/mailgun/#pytanis.mailgun.MailClient.send","title":"<code>send(mail: Mail)</code>","text":"<p>Send a mail to all recipients using Mailgun</p> Source code in <code>src/pytanis/mailgun/mail.py</code> <pre><code>def send(self, mail: Mail):\n    \"\"\"Send a mail to all recipients using Mailgun\"\"\"\n    errors = []\n    responses = []\n\n    # TODO: improve Mailgun batch mailing by setting custom transactional variables\n    if self._config.Mailgun is None:\n        msg = 'Mailgun configuration is missing'\n        raise RuntimeError(msg)\n    for idx, recipient in enumerate(tqdm(mail.recipients), start=1):\n        try:\n            recipient_mail = mail.model_copy()\n            if self._config.Mailgun.token is None:\n                msg = 'API token for Mailgun is empty'\n                raise RuntimeError(msg)\n            if self._config.Mailgun.from_address is None:\n                msg = 'From Email for Mailgun is empty'\n                raise RuntimeError(msg)\n            if self._config.Mailgun.reply_to is None:\n                msg = 'Reply To Email for Mailgun is empty'\n                raise RuntimeError(msg)\n\n            response = requests.post(\n                'https://api.eu.mailgun.net/v3/mg.pycon.de/messages',\n                auth=('api', self._config.Mailgun.token),\n                data={\n                    'to': [recipient.email],\n                    'from': self._config.Mailgun.from_address,\n                    'subject': recipient_mail.subject.format(recipient=recipient, mail=mail),\n                    'text': recipient_mail.body.format(recipient=recipient, mail=mail),\n                    'h:Reply-To': self._config.Mailgun.reply_to,\n                },\n                timeout=self.timeout,\n            )\n            # check response status message and throw exception if not 200\n            response.raise_for_status()\n        except Exception as e:\n            errors.append((recipient, e))\n        else:\n            responses.append(response)\n\n        if idx % self.batch_size == 0:\n            time.sleep(self.wait_time)\n\n    return responses, errors\n</code></pre>"},{"location":"reference/pytanis/mailgun/#pytanis.mailgun.Recipient","title":"<code>Recipient</code>","text":"<p>Details about the recipient</p> <p>Use the <code>data</code> field to store additional information</p>"},{"location":"reference/pytanis/mailgun/#pytanis.mailgun.Recipient.address_as","title":"<code>address_as: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/mailgun/#pytanis.mailgun.Recipient.data","title":"<code>data: MetaData | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/mailgun/#pytanis.mailgun.Recipient.email","title":"<code>email: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/mailgun/#pytanis.mailgun.Recipient.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/mailgun/#pytanis.mailgun.Recipient.fill_with_name","title":"<code>fill_with_name(v, values)</code>  <code>classmethod</code>","text":"Source code in <code>src/pytanis/mailgun/mail.py</code> <pre><code>@validator('address_as')\n@classmethod\ndef fill_with_name(cls, v, values):\n    if v is None:\n        v = values['name']\n    return v\n</code></pre>"},{"location":"reference/pytanis/mailgun/mail/","title":"Mail","text":""},{"location":"reference/pytanis/mailgun/mail/#pytanis.mailgun.mail","title":"<code>mail</code>","text":""},{"location":"reference/pytanis/mailgun/mail/#pytanis.mailgun.mail.Mail","title":"<code>Mail</code>","text":"<p>Mail template</p> <p>Use the <code>data</code> field to store additional information</p> <p>You can use the typical Format String Syntax and the objects <code>recipient</code> and <code>mail</code> to access metadata to complement the template, e.g.:</p> <pre><code>Hello {recipient.address_as},\n\nWe hope it's ok to address you your first name rather than using your full name being {recipient.name}.\nHave you read the email's subject '{mail.subject}'? How is your work right now at {recipient.data.company}?\n\nCheers!\n</code></pre>"},{"location":"reference/pytanis/mailgun/mail/#pytanis.mailgun.mail.Mail.body","title":"<code>body: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/mailgun/mail/#pytanis.mailgun.mail.Mail.data","title":"<code>data: MetaData | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/mailgun/mail/#pytanis.mailgun.mail.Mail.recipients","title":"<code>recipients: list[Recipient]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/mailgun/mail/#pytanis.mailgun.mail.Mail.subject","title":"<code>subject: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/mailgun/mail/#pytanis.mailgun.mail.MailClient","title":"<code>MailClient(config: Config | None = None)</code>","text":"<p>Mail client for mass mails via Mailgun</p> Source code in <code>src/pytanis/mailgun/mail.py</code> <pre><code>def __init__(self, config: Config | None = None):\n    if config is None:\n        config = get_cfg()\n    self._config = config\n</code></pre>"},{"location":"reference/pytanis/mailgun/mail/#pytanis.mailgun.mail.MailClient.batch_size","title":"<code>batch_size: int = 10</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/mailgun/mail/#pytanis.mailgun.mail.MailClient.timeout","title":"<code>timeout: int = 10</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/mailgun/mail/#pytanis.mailgun.mail.MailClient.wait_time","title":"<code>wait_time: int = 20</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/mailgun/mail/#pytanis.mailgun.mail.MailClient.send","title":"<code>send(mail: Mail)</code>","text":"<p>Send a mail to all recipients using Mailgun</p> Source code in <code>src/pytanis/mailgun/mail.py</code> <pre><code>def send(self, mail: Mail):\n    \"\"\"Send a mail to all recipients using Mailgun\"\"\"\n    errors = []\n    responses = []\n\n    # TODO: improve Mailgun batch mailing by setting custom transactional variables\n    if self._config.Mailgun is None:\n        msg = 'Mailgun configuration is missing'\n        raise RuntimeError(msg)\n    for idx, recipient in enumerate(tqdm(mail.recipients), start=1):\n        try:\n            recipient_mail = mail.model_copy()\n            if self._config.Mailgun.token is None:\n                msg = 'API token for Mailgun is empty'\n                raise RuntimeError(msg)\n            if self._config.Mailgun.from_address is None:\n                msg = 'From Email for Mailgun is empty'\n                raise RuntimeError(msg)\n            if self._config.Mailgun.reply_to is None:\n                msg = 'Reply To Email for Mailgun is empty'\n                raise RuntimeError(msg)\n\n            response = requests.post(\n                'https://api.eu.mailgun.net/v3/mg.pycon.de/messages',\n                auth=('api', self._config.Mailgun.token),\n                data={\n                    'to': [recipient.email],\n                    'from': self._config.Mailgun.from_address,\n                    'subject': recipient_mail.subject.format(recipient=recipient, mail=mail),\n                    'text': recipient_mail.body.format(recipient=recipient, mail=mail),\n                    'h:Reply-To': self._config.Mailgun.reply_to,\n                },\n                timeout=self.timeout,\n            )\n            # check response status message and throw exception if not 200\n            response.raise_for_status()\n        except Exception as e:\n            errors.append((recipient, e))\n        else:\n            responses.append(response)\n\n        if idx % self.batch_size == 0:\n            time.sleep(self.wait_time)\n\n    return responses, errors\n</code></pre>"},{"location":"reference/pytanis/mailgun/mail/#pytanis.mailgun.mail.MetaData","title":"<code>MetaData</code>","text":"<p>Additional, arbitrary metadata provided by the user like for template filling</p>"},{"location":"reference/pytanis/mailgun/mail/#pytanis.mailgun.mail.MetaData.model_config","title":"<code>model_config = ConfigDict(extra='allow')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/mailgun/mail/#pytanis.mailgun.mail.Recipient","title":"<code>Recipient</code>","text":"<p>Details about the recipient</p> <p>Use the <code>data</code> field to store additional information</p>"},{"location":"reference/pytanis/mailgun/mail/#pytanis.mailgun.mail.Recipient.address_as","title":"<code>address_as: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/mailgun/mail/#pytanis.mailgun.mail.Recipient.data","title":"<code>data: MetaData | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/mailgun/mail/#pytanis.mailgun.mail.Recipient.email","title":"<code>email: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/mailgun/mail/#pytanis.mailgun.mail.Recipient.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/mailgun/mail/#pytanis.mailgun.mail.Recipient.fill_with_name","title":"<code>fill_with_name(v, values)</code>  <code>classmethod</code>","text":"Source code in <code>src/pytanis/mailgun/mail.py</code> <pre><code>@validator('address_as')\n@classmethod\ndef fill_with_name(cls, v, values):\n    if v is None:\n        v = values['name']\n    return v\n</code></pre>"},{"location":"reference/pytanis/pretalx/","title":"Pretalx","text":""},{"location":"reference/pytanis/pretalx/#pytanis.pretalx","title":"<code>pretalx</code>","text":"<p>Functionality around the Pretalx API</p>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.__all__","title":"<code>__all__ = ['PretalxClient', 'SimpleTalk', 'get_confirmed_talks_as_json', 'get_talks_as_json', 'reviews_as_df', 'save_confirmed_talks_to_json', 'save_talks_to_json', 'speakers_as_df', 'subs_as_df', 'talks_to_json']</code>  <code>module-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient","title":"<code>PretalxClient(config: Config | None = None, *, blocking: bool = False)</code>","text":"<p>Client for the Pretalx API</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def __init__(self, config: Config | None = None, *, blocking: bool = False):\n    if config is None:\n        config = get_cfg()\n    self._config = config\n    self._get_throttled = self._get\n    self.blocking = blocking\n    self.set_throttling(calls=2, seconds=1)  # we are nice by default and Pretalx doesn't allow many calls at once.\n\n    # Caches for expanded objects (session-only, not persisted)\n    self._speaker_cache: dict[str, dict] = {}\n    self._submission_type_cache: dict[int, dict] = {}\n    self._track_cache: dict[int, dict] = {}\n    self._answer_cache: dict[int, dict | None] = {}\n    self._question_cache: dict[int, dict] = {}\n    self._caches_populated: dict[str, bool] = {}  # Track which event caches are populated\n    self._use_cache_prepopulation: bool = True  # Enable cache pre-population by default\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.blocking","title":"<code>blocking = blocking</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.__validate","title":"<code>__validate(model_type, result)</code>  <code>classmethod</code>","text":"Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>@classmethod\ndef __validate(cls, model_type, result):\n    try:\n        validated = model_type.model_validate(result)\n        return validated\n    except Exception as e:\n        # introduced to deal with API changes\n        _logger.error('result', resp=e)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.answer","title":"<code>answer(event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Answer</code>","text":"<p>Returns a specific answer</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def answer(self, event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Answer:  # noqa: A002\n    \"\"\"Returns a specific answer\"\"\"\n    return self._endpoint_id(Answer, event_slug, 'answers', id, params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.answers","title":"<code>answers(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Answer]]</code>","text":"<p>Lists all answers and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def answers(self, event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Answer]]:\n    \"\"\"Lists all answers and their details\"\"\"\n    return self._endpoint_lst(Answer, event_slug, 'answers', params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.clear_caches","title":"<code>clear_caches() -&gt; None</code>","text":"<p>Clear all session caches.</p> <p>This is useful if you want to force fresh data to be fetched from the API. Note that caches are session-only and are not persisted between client instances.</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def clear_caches(self) -&gt; None:\n    \"\"\"Clear all session caches.\n\n    This is useful if you want to force fresh data to be fetched from the API.\n    Note that caches are session-only and are not persisted between client instances.\n    \"\"\"\n    self._speaker_cache.clear()\n    self._submission_type_cache.clear()\n    self._track_cache.clear()\n    self._answer_cache.clear()\n    self._question_cache.clear()\n    self._caches_populated.clear()\n    _logger.info('All caches cleared')\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.event","title":"<code>event(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; Event</code>","text":"<p>Returns detailed information about a specific event</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def event(self, event_slug: str, *, params: QueryParams | dict | None = None) -&gt; Event:\n    \"\"\"Returns detailed information about a specific event\"\"\"\n    endpoint = f'/api/events/{event_slug}/'\n    result = self._get_one(endpoint, params)\n    _logger.debug('result', resp=result)\n    return self.__validate(Event, result)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.events","title":"<code>events(*, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Event]]</code>","text":"<p>Lists all events and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def events(self, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Event]]:\n    \"\"\"Lists all events and their details\"\"\"\n    count, results = self._get_many('/api/events/', params)\n    events = iter(_logger.debug('result', resp=r) or Event.model_validate(r) for r in results)\n    return count, events\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.me","title":"<code>me() -&gt; Me</code>","text":"<p>Returns what Pretalx knows about myself</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def me(self) -&gt; Me:\n    \"\"\"Returns what Pretalx knows about myself\"\"\"\n    result = self._get_one('/api/me/')\n    return self.__validate(Me, result)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.question","title":"<code>question(event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Question</code>","text":"<p>Returns a specific question</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def question(self, event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Question:  # noqa: A002\n    \"\"\"Returns a specific question\"\"\"\n    return self._endpoint_id(Question, event_slug, 'questions', id, params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.questions","title":"<code>questions(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Question]]</code>","text":"<p>Lists all questions and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def questions(self, event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Question]]:\n    \"\"\"Lists all questions and their details\"\"\"\n    return self._endpoint_lst(Question, event_slug, 'questions', params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.review","title":"<code>review(event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Review</code>","text":"<p>Returns a specific review</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def review(self, event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Review:  # noqa: A002\n    \"\"\"Returns a specific review\"\"\"\n    return self._endpoint_id(Review, event_slug, 'reviews', id, params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.reviews","title":"<code>reviews(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Review]]</code>","text":"<p>Lists all reviews and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def reviews(self, event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Review]]:\n    \"\"\"Lists all reviews and their details\"\"\"\n    return self._endpoint_lst(Review, event_slug, 'reviews', params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.room","title":"<code>room(event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Room</code>","text":"<p>Returns a specific room</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def room(self, event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Room:  # noqa: A002\n    \"\"\"Returns a specific room\"\"\"\n    return self._endpoint_id(Room, event_slug, 'rooms', id, params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.rooms","title":"<code>rooms(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Room]]</code>","text":"<p>Lists all rooms and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def rooms(self, event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Room]]:\n    \"\"\"Lists all rooms and their details\"\"\"\n    return self._endpoint_lst(Room, event_slug, 'rooms', params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.set_cache_prepopulation","title":"<code>set_cache_prepopulation(enabled: bool) -&gt; None</code>","text":"<p>Enable or disable automatic cache pre-population for submissions.</p> <p>When enabled (default), the client will fetch all speakers, submission types, and tracks in bulk on the first submission to minimize API calls. Disable this if you're only fetching a few submissions.</p> <p>Parameters:</p> Name Type Description Default <code>enabled</code> <code>bool</code> <p>Whether to enable cache pre-population</p> required Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def set_cache_prepopulation(self, enabled: bool) -&gt; None:  # noqa: FBT001\n    \"\"\"Enable or disable automatic cache pre-population for submissions.\n\n    When enabled (default), the client will fetch all speakers, submission types,\n    and tracks in bulk on the first submission to minimize API calls.\n    Disable this if you're only fetching a few submissions.\n\n    Args:\n        enabled: Whether to enable cache pre-population\n    \"\"\"\n    self._use_cache_prepopulation = enabled\n    _logger.info(f'Cache pre-population {\"enabled\" if enabled else \"disabled\"}')\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.set_throttling","title":"<code>set_throttling(calls: int, seconds: int)</code>","text":"<p>Throttle the number of calls per seconds to the Pretalx API</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def set_throttling(self, calls: int, seconds: int):\n    \"\"\"Throttle the number of calls per seconds to the Pretalx API\"\"\"\n    _logger.info('throttling', calls=calls, seconds=seconds)\n    self._get_throttled = throttle(calls, seconds)(self._get)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.speaker","title":"<code>speaker(event_slug: str, code: str, *, params: QueryParams | dict | None = None) -&gt; Speaker</code>","text":"<p>Returns a specific speaker</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def speaker(self, event_slug: str, code: str, *, params: QueryParams | dict | None = None) -&gt; Speaker:\n    \"\"\"Returns a specific speaker\"\"\"\n    return self._endpoint_id(Speaker, event_slug, 'speakers', code, params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.speakers","title":"<code>speakers(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Speaker]]</code>","text":"<p>Lists all speakers and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def speakers(self, event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Speaker]]:\n    \"\"\"Lists all speakers and their details\"\"\"\n    return self._endpoint_lst(Speaker, event_slug, 'speakers', params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.submission","title":"<code>submission(event_slug: str, code: str, *, params: QueryParams | dict | None = None) -&gt; Submission</code>","text":"<p>Returns a specific submission</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def submission(self, event_slug: str, code: str, *, params: QueryParams | dict | None = None) -&gt; Submission:\n    \"\"\"Returns a specific submission\"\"\"\n    return self._endpoint_id(Submission, event_slug, 'submissions', code, params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.submission_type","title":"<code>submission_type(event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; SubmissionType</code>","text":"<p>Returns a specific submission type</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def submission_type(self, event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; SubmissionType:  # noqa: A002\n    \"\"\"Returns a specific submission type\"\"\"\n    return self._endpoint_id(SubmissionType, event_slug, 'submission-types', id, params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.submission_types","title":"<code>submission_types(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[SubmissionType]]</code>","text":"<p>Lists all submission types and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def submission_types(\n    self, event_slug: str, *, params: QueryParams | dict | None = None\n) -&gt; tuple[int, Iterator[SubmissionType]]:\n    \"\"\"Lists all submission types and their details\"\"\"\n    return self._endpoint_lst(SubmissionType, event_slug, 'submission-types', params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.submissions","title":"<code>submissions(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Submission]]</code>","text":"<p>Lists all submissions and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def submissions(\n    self, event_slug: str, *, params: QueryParams | dict | None = None\n) -&gt; tuple[int, Iterator[Submission]]:\n    \"\"\"Lists all submissions and their details\"\"\"\n    return self._endpoint_lst(Submission, event_slug, 'submissions', params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.tag","title":"<code>tag(event_slug: str, tag: str, *, params: QueryParams | dict | None = None) -&gt; Tag</code>","text":"<p>Returns a specific tag</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def tag(self, event_slug: str, tag: str, *, params: QueryParams | dict | None = None) -&gt; Tag:\n    \"\"\"Returns a specific tag\"\"\"\n    return self._endpoint_id(Tag, event_slug, 'tags', tag, params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.tags","title":"<code>tags(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Tag]]</code>","text":"<p>Lists all tags and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def tags(self, event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Tag]]:\n    \"\"\"Lists all tags and their details\"\"\"\n    return self._endpoint_lst(Tag, event_slug, 'tags', params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.talk","title":"<code>talk(event_slug: str, code: str, *, params: QueryParams | dict | None = None) -&gt; Talk</code>","text":"<p>Returns a specific talk</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def talk(self, event_slug: str, code: str, *, params: QueryParams | dict | None = None) -&gt; Talk:\n    \"\"\"Returns a specific talk\"\"\"\n    try:\n        return self._endpoint_id(Talk, event_slug, 'talks', code, params=params)\n    except httpx.HTTPStatusError as e:\n        if e.response.status_code == HTTP_NOT_FOUND:\n            _logger.info('talk endpoint not available, using submission endpoint')\n            # Use submission endpoint but validate as Talk object\n            return self._endpoint_id(Talk, event_slug, 'submissions', code, params=params)\n        raise\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.talks","title":"<code>talks(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Talk]]</code>","text":"<p>Lists all talks and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def talks(self, event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Talk]]:\n    \"\"\"Lists all talks and their details\"\"\"\n    try:\n        return self._endpoint_lst(Talk, event_slug, 'talks', params=params)\n    except httpx.HTTPStatusError as e:\n        if e.response.status_code == HTTP_NOT_FOUND:\n            _logger.info('talks endpoint not available, using submissions endpoint')\n            # Use submissions endpoint but validate as Talk objects\n            return self._endpoint_lst(Talk, event_slug, 'submissions', params=params)\n        raise\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.track","title":"<code>track(event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Track</code>","text":"<p>Returns a specific track</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def track(self, event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Track:  # noqa: A002\n    \"\"\"Returns a specific track\"\"\"\n    return self._endpoint_id(Track, event_slug, 'tracks', id, params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.tracks","title":"<code>tracks(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Track]]</code>","text":"<p>Lists all tracks and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def tracks(self, event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Track]]:\n    \"\"\"Lists all tracks and their details\"\"\"\n    return self._endpoint_lst(Track, event_slug, 'tracks', params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.SimpleTalk","title":"<code>SimpleTalk</code>","text":"<p>Simplified Talk model for generating JSON output</p> <p>This model contains only the essential information needed for display purposes.</p>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.SimpleTalk.abstract","title":"<code>abstract: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.SimpleTalk.code","title":"<code>code: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.SimpleTalk.description","title":"<code>description: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.SimpleTalk.domain_level","title":"<code>domain_level: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.SimpleTalk.duration","title":"<code>duration: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.SimpleTalk.organisation","title":"<code>organisation: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.SimpleTalk.prerequisites","title":"<code>prerequisites: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.SimpleTalk.python_level","title":"<code>python_level: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.SimpleTalk.speaker","title":"<code>speaker: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.SimpleTalk.title","title":"<code>title: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.SimpleTalk.track","title":"<code>track: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.get_confirmed_talks_as_json","title":"<code>get_confirmed_talks_as_json(pretalx_client: PretalxClient, event_slug: str, params: dict[str, Any] | None = None) -&gt; str</code>","text":"<p>Get confirmed talks from pretalx and convert them to JSON (legacy function for backward compatibility).</p> <p>Parameters:</p> Name Type Description Default <code>pretalx_client</code> <code>PretalxClient</code> <p>PretalxClient instance to fetch talk and speaker data</p> required <code>event_slug</code> <code>str</code> <p>Event slug for the pretalx event</p> required <code>params</code> <code>dict[str, Any] | None</code> <p>Additional parameters to pass to the pretalx API</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>A JSON string containing a list of SimpleTalk objects</p> Source code in <code>src/pytanis/pretalx/utils.py</code> <pre><code>def get_confirmed_talks_as_json(\n    pretalx_client: PretalxClient, event_slug: str, params: dict[str, Any] | None = None\n) -&gt; str:\n    \"\"\"\n    Get confirmed talks from pretalx and convert them to JSON (legacy function for backward compatibility).\n\n    Args:\n        pretalx_client: PretalxClient instance to fetch talk and speaker data\n        event_slug: Event slug for the pretalx event\n        params: Additional parameters to pass to the pretalx API\n\n    Returns:\n        A JSON string containing a list of SimpleTalk objects\n    \"\"\"\n    return get_talks_as_json(pretalx_client, event_slug, 'confirmed', params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.get_talks_as_json","title":"<code>get_talks_as_json(pretalx_client: PretalxClient, event_slug: str, state_value: str = 'confirmed', params: dict[str, Any] | None = None) -&gt; str</code>","text":"<p>Get talks from pretalx and convert them to a JSON list of SimpleTalk objects.</p> <p>This function fetches talks from pretalx based on the specified state, extracts the essential information, and returns a JSON string containing a list of simplified talk objects.</p> <p>Parameters:</p> Name Type Description Default <code>pretalx_client</code> <code>PretalxClient</code> <p>PretalxClient instance to fetch talk and speaker data</p> required <code>event_slug</code> <code>str</code> <p>Event slug for the pretalx event</p> required <code>state_value</code> <code>str</code> <p>State of talks to include (default: \"confirmed\")</p> <code>'confirmed'</code> <code>params</code> <code>dict[str, Any] | None</code> <p>Additional parameters to pass to the pretalx API</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>A JSON string containing a list of SimpleTalk objects</p> Source code in <code>src/pytanis/pretalx/utils.py</code> <pre><code>def get_talks_as_json(\n    pretalx_client: PretalxClient, event_slug: str, state_value: str = 'confirmed', params: dict[str, Any] | None = None\n) -&gt; str:\n    \"\"\"\n    Get talks from pretalx and convert them to a JSON list of SimpleTalk objects.\n\n    This function fetches talks from pretalx based on the specified state,\n    extracts the essential information, and returns a JSON string containing\n    a list of simplified talk objects.\n\n    Args:\n        pretalx_client: PretalxClient instance to fetch talk and speaker data\n        event_slug: Event slug for the pretalx event\n        state_value: State of talks to include (default: \"confirmed\")\n        params: Additional parameters to pass to the pretalx API\n\n    Returns:\n        A JSON string containing a list of SimpleTalk objects\n    \"\"\"\n    # Prepare parameters for the API call\n    if params is None:\n        params = {}\n\n    # Ensure we get all questions and filter by state\n    params['questions'] = 'all'\n    params['state'] = state_value\n\n    # Fetch talks from pretalx\n    _, talks_iter = pretalx_client.talks(event_slug, params=params)\n    talks = list(talks_iter)  # Materialize the iterator\n\n    return talks_to_json(talks, pretalx_client, event_slug)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.reviews_as_df","title":"<code>reviews_as_df(reviews: Iterable[Review]) -&gt; pd.DataFrame</code>","text":"<p>Convert the reviews to a dataframe</p> Source code in <code>src/pytanis/pretalx/utils.py</code> <pre><code>def reviews_as_df(reviews: Iterable[Review]) -&gt; pd.DataFrame:\n    \"\"\"Convert the reviews to a dataframe\"\"\"\n    df = pd.DataFrame([review.model_dump() for review in reviews])\n    # make first letter of column upper-case in accordance with our convention\n    df.rename(columns={col: col.title() for col in df.columns}, inplace=True)\n    # user is the speaker name to use for joining\n    df.rename(columns={'User': Col.pretalx_user, 'Score': Col.review_score}, inplace=True)\n\n    return df\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.save_confirmed_talks_to_json","title":"<code>save_confirmed_talks_to_json(talks: Iterable[Talk], file_path: str, pretalx_client: PretalxClient | None = None, event_slug: str | None = None) -&gt; None</code>","text":"<p>Save confirmed talks to a JSON file (legacy function for backward compatibility).</p> <p>Parameters:</p> Name Type Description Default <code>talks</code> <code>Iterable[Talk]</code> <p>An iterable of Talk objects, typically from pretalx_client.talks()</p> required <code>file_path</code> <code>str</code> <p>Path where the JSON file should be saved</p> required <code>pretalx_client</code> <code>PretalxClient | None</code> <p>Optional PretalxClient instance to fetch speaker data</p> <code>None</code> <code>event_slug</code> <code>str | None</code> <p>Optional event slug needed if pretalx_client is provided</p> <code>None</code> Source code in <code>src/pytanis/pretalx/utils.py</code> <pre><code>def save_confirmed_talks_to_json(\n    talks: Iterable[Talk], file_path: str, pretalx_client: PretalxClient | None = None, event_slug: str | None = None\n) -&gt; None:\n    \"\"\"\n    Save confirmed talks to a JSON file (legacy function for backward compatibility).\n\n    Args:\n        talks: An iterable of Talk objects, typically from pretalx_client.talks()\n        file_path: Path where the JSON file should be saved\n        pretalx_client: Optional PretalxClient instance to fetch speaker data\n        event_slug: Optional event slug needed if pretalx_client is provided\n    \"\"\"\n    json_data = talks_to_json([talk for talk in talks if talk.state.value == 'confirmed'], pretalx_client, event_slug)\n\n    with open(file_path, 'w', encoding='utf-8') as f:\n        f.write(json_data)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.save_talks_to_json","title":"<code>save_talks_to_json(pretalx_client: PretalxClient, event_slug: str, file_path: str, state_value: str = 'confirmed', params: dict[str, Any] | None = None) -&gt; None</code>","text":"<p>Fetch talks from pretalx and save them to a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>pretalx_client</code> <code>PretalxClient</code> <p>PretalxClient instance to fetch talk and speaker data</p> required <code>event_slug</code> <code>str</code> <p>Event slug for the pretalx event</p> required <code>file_path</code> <code>str</code> <p>Path where the JSON file should be saved</p> required <code>state_value</code> <code>str</code> <p>State of talks to include (default: \"confirmed\")</p> <code>'confirmed'</code> <code>params</code> <code>dict[str, Any] | None</code> <p>Additional parameters to pass to the pretalx API</p> <code>None</code> Source code in <code>src/pytanis/pretalx/utils.py</code> <pre><code>def save_talks_to_json(\n    pretalx_client: PretalxClient,\n    event_slug: str,\n    file_path: str,\n    state_value: str = 'confirmed',\n    params: dict[str, Any] | None = None,\n) -&gt; None:\n    \"\"\"\n    Fetch talks from pretalx and save them to a JSON file.\n\n    Args:\n        pretalx_client: PretalxClient instance to fetch talk and speaker data\n        event_slug: Event slug for the pretalx event\n        file_path: Path where the JSON file should be saved\n        state_value: State of talks to include (default: \"confirmed\")\n        params: Additional parameters to pass to the pretalx API\n    \"\"\"\n    json_data = get_talks_as_json(pretalx_client, event_slug, state_value, params)\n\n    with open(file_path, 'w', encoding='utf-8') as f:\n        f.write(json_data)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.speakers_as_df","title":"<code>speakers_as_df(speakers: Iterable[Speaker], *, with_questions: bool = False, question_prefix: str = 'Q: ') -&gt; pd.DataFrame</code>","text":"<p>Convert speakers into a dataframe</p> <p>Make sure to have <code>params={\"questions\": \"all\"}</code> for the PretalxAPI if <code>with_questions</code> is True.</p> Source code in <code>src/pytanis/pretalx/utils.py</code> <pre><code>def speakers_as_df(\n    speakers: Iterable[Speaker], *, with_questions: bool = False, question_prefix: str = 'Q: '\n) -&gt; pd.DataFrame:\n    \"\"\"Convert speakers into a dataframe\n\n    Make sure to have `params={\"questions\": \"all\"}` for the PretalxAPI if `with_questions` is True.\n    \"\"\"\n    rows = []\n    for speaker in speakers:\n        row = {\n            Col.speaker_code: speaker.code,\n            Col.speaker_name: speaker.name,\n            Col.email: speaker.email,\n            Col.biography: speaker.biography,\n            Col.submission: speaker.submissions,\n        }\n        if with_questions and speaker.answers is not None:\n            for answer in speaker.answers:\n                # The API returns also questions that are 'per proposal/submission', we get these using the\n                # submission endpoint and don't want them here due to ambiguity if several submission were made.\n                if answer.person is not None:\n                    row[f'{question_prefix}{answer.question.question.en}'] = answer.answer\n        rows.append(row)\n    return pd.DataFrame(rows)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.subs_as_df","title":"<code>subs_as_df(subs: Iterable[Submission], *, with_questions: bool = False, question_prefix: str = 'Q: ') -&gt; pd.DataFrame</code>","text":"<p>Convert submissions into a dataframe</p> <p>Make sure to have <code>params={\"questions\": \"all\"}</code> for the PretalxAPI if <code>with_questions</code> is True.</p> Source code in <code>src/pytanis/pretalx/utils.py</code> <pre><code>def subs_as_df(\n    subs: Iterable[Submission], *, with_questions: bool = False, question_prefix: str = 'Q: '\n) -&gt; pd.DataFrame:\n    \"\"\"Convert submissions into a dataframe\n\n    Make sure to have `params={\"questions\": \"all\"}` for the PretalxAPI if `with_questions` is True.\n    \"\"\"\n    rows = []\n    for sub in subs:\n        row = {\n            Col.submission: sub.code,\n            Col.title: sub.title,\n            Col.track: sub.track.en if sub.track else None,\n            Col.speaker_code: [speaker.code for speaker in sub.speakers],\n            Col.speaker_name: [speaker.name for speaker in sub.speakers],\n            Col.duration: sub.duration,\n            Col.submission_type: (\n                sub.submission_type.en if hasattr(sub.submission_type, 'en') else str(sub.submission_type)\n            ),\n            Col.submission_type_id: sub.submission_type_id,\n            Col.state: sub.state.value,\n            Col.pending_state: None if sub.pending_state is None else sub.pending_state.value,\n            Col.created: sub.created,\n        }\n        if with_questions and sub.answers is not None:\n            for answer in sub.answers:\n                row[f'{question_prefix}{answer.question.question.en}'] = answer.answer\n        rows.append(row)\n    return pd.DataFrame(rows)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.talks_to_json","title":"<code>talks_to_json(talks: Iterable[Talk], pretalx_client: PretalxClient | None = None, event_slug: str | None = None) -&gt; str</code>","text":"<p>Convert Talk objects to a JSON list of SimpleTalk objects.</p> <p>This function extracts the essential information from pretalx Talk objects and returns a JSON string containing a list of simplified talk objects.</p> <p>Parameters:</p> Name Type Description Default <code>talks</code> <code>Iterable[Talk]</code> <p>An iterable of Talk objects</p> required <code>pretalx_client</code> <code>PretalxClient | None</code> <p>Optional PretalxClient instance to fetch speaker data</p> <code>None</code> <code>event_slug</code> <code>str | None</code> <p>Optional event slug needed if pretalx_client is provided</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>A JSON string containing a list of SimpleTalk objects</p> Source code in <code>src/pytanis/pretalx/utils.py</code> <pre><code>def talks_to_json(\n    talks: Iterable[Talk], pretalx_client: PretalxClient | None = None, event_slug: str | None = None\n) -&gt; str:\n    \"\"\"\n    Convert Talk objects to a JSON list of SimpleTalk objects.\n\n    This function extracts the essential information from pretalx Talk objects\n    and returns a JSON string containing a list of simplified talk objects.\n\n    Args:\n        talks: An iterable of Talk objects\n        pretalx_client: Optional PretalxClient instance to fetch speaker data\n        event_slug: Optional event slug needed if pretalx_client is provided\n\n    Returns:\n        A JSON string containing a list of SimpleTalk objects\n    \"\"\"\n    simple_talks = []\n\n    # Store speaker data to avoid fetching the same speaker multiple times\n    speaker_data: dict[str, Speaker] = {}\n\n    for talk in talks:\n        # Create a SimpleTalk object with basic information\n        simple_talk = create_simple_talk_from_talk(talk)\n\n        # Extract expertise levels and prerequisites\n        extract_expertise_and_prerequisites(talk, simple_talk)\n\n        # Extract organisation information\n        if event_slug and pretalx_client:\n            extract_organisation(talk, simple_talk, pretalx_client, event_slug, speaker_data)\n\n        simple_talks.append(simple_talk)\n\n    # Convert to JSON\n    return json.dumps([talk.model_dump() for talk in simple_talks], indent=2)\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/","title":"Client","text":""},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client","title":"<code>client</code>","text":"<p>Client for the Pretalx API</p> <p>Documentation: https://docs.pretalx.org/api/resources/index.html</p> <p>ToDo</p> <ul> <li>add additional parameters explicitly like querying according to the API</li> </ul>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.HTTP_FORBIDDEN","title":"<code>HTTP_FORBIDDEN = 403</code>  <code>module-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.HTTP_NOT_FOUND","title":"<code>HTTP_NOT_FOUND = 404</code>  <code>module-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.HTTP_UNAUTHORIZED","title":"<code>HTTP_UNAUTHORIZED = 401</code>  <code>module-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.JSON","title":"<code>JSON: TypeAlias = JSONObj | JSONLst</code>  <code>module-attribute</code>","text":"<p>Type of the JSON response as returned by the Pretalx API</p>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.JSONLst","title":"<code>JSONLst: TypeAlias = list[JSONObj]</code>  <code>module-attribute</code>","text":"<p>Type of a JSON list of JSON objects</p>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.JSONObj","title":"<code>JSONObj: TypeAlias = dict[str, Any]</code>  <code>module-attribute</code>","text":"<p>Type of a JSON object (without recursion)</p>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.T","title":"<code>T = TypeVar('T', bound=BaseModel)</code>  <code>module-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient","title":"<code>PretalxClient(config: Config | None = None, *, blocking: bool = False)</code>","text":"<p>Client for the Pretalx API</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def __init__(self, config: Config | None = None, *, blocking: bool = False):\n    if config is None:\n        config = get_cfg()\n    self._config = config\n    self._get_throttled = self._get\n    self.blocking = blocking\n    self.set_throttling(calls=2, seconds=1)  # we are nice by default and Pretalx doesn't allow many calls at once.\n\n    # Caches for expanded objects (session-only, not persisted)\n    self._speaker_cache: dict[str, dict] = {}\n    self._submission_type_cache: dict[int, dict] = {}\n    self._track_cache: dict[int, dict] = {}\n    self._answer_cache: dict[int, dict | None] = {}\n    self._question_cache: dict[int, dict] = {}\n    self._caches_populated: dict[str, bool] = {}  # Track which event caches are populated\n    self._use_cache_prepopulation: bool = True  # Enable cache pre-population by default\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.blocking","title":"<code>blocking = blocking</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.__validate","title":"<code>__validate(model_type, result)</code>  <code>classmethod</code>","text":"Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>@classmethod\ndef __validate(cls, model_type, result):\n    try:\n        validated = model_type.model_validate(result)\n        return validated\n    except Exception as e:\n        # introduced to deal with API changes\n        _logger.error('result', resp=e)\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.answer","title":"<code>answer(event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Answer</code>","text":"<p>Returns a specific answer</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def answer(self, event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Answer:  # noqa: A002\n    \"\"\"Returns a specific answer\"\"\"\n    return self._endpoint_id(Answer, event_slug, 'answers', id, params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.answers","title":"<code>answers(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Answer]]</code>","text":"<p>Lists all answers and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def answers(self, event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Answer]]:\n    \"\"\"Lists all answers and their details\"\"\"\n    return self._endpoint_lst(Answer, event_slug, 'answers', params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.clear_caches","title":"<code>clear_caches() -&gt; None</code>","text":"<p>Clear all session caches.</p> <p>This is useful if you want to force fresh data to be fetched from the API. Note that caches are session-only and are not persisted between client instances.</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def clear_caches(self) -&gt; None:\n    \"\"\"Clear all session caches.\n\n    This is useful if you want to force fresh data to be fetched from the API.\n    Note that caches are session-only and are not persisted between client instances.\n    \"\"\"\n    self._speaker_cache.clear()\n    self._submission_type_cache.clear()\n    self._track_cache.clear()\n    self._answer_cache.clear()\n    self._question_cache.clear()\n    self._caches_populated.clear()\n    _logger.info('All caches cleared')\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.event","title":"<code>event(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; Event</code>","text":"<p>Returns detailed information about a specific event</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def event(self, event_slug: str, *, params: QueryParams | dict | None = None) -&gt; Event:\n    \"\"\"Returns detailed information about a specific event\"\"\"\n    endpoint = f'/api/events/{event_slug}/'\n    result = self._get_one(endpoint, params)\n    _logger.debug('result', resp=result)\n    return self.__validate(Event, result)\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.events","title":"<code>events(*, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Event]]</code>","text":"<p>Lists all events and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def events(self, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Event]]:\n    \"\"\"Lists all events and their details\"\"\"\n    count, results = self._get_many('/api/events/', params)\n    events = iter(_logger.debug('result', resp=r) or Event.model_validate(r) for r in results)\n    return count, events\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.me","title":"<code>me() -&gt; Me</code>","text":"<p>Returns what Pretalx knows about myself</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def me(self) -&gt; Me:\n    \"\"\"Returns what Pretalx knows about myself\"\"\"\n    result = self._get_one('/api/me/')\n    return self.__validate(Me, result)\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.question","title":"<code>question(event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Question</code>","text":"<p>Returns a specific question</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def question(self, event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Question:  # noqa: A002\n    \"\"\"Returns a specific question\"\"\"\n    return self._endpoint_id(Question, event_slug, 'questions', id, params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.questions","title":"<code>questions(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Question]]</code>","text":"<p>Lists all questions and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def questions(self, event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Question]]:\n    \"\"\"Lists all questions and their details\"\"\"\n    return self._endpoint_lst(Question, event_slug, 'questions', params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.review","title":"<code>review(event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Review</code>","text":"<p>Returns a specific review</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def review(self, event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Review:  # noqa: A002\n    \"\"\"Returns a specific review\"\"\"\n    return self._endpoint_id(Review, event_slug, 'reviews', id, params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.reviews","title":"<code>reviews(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Review]]</code>","text":"<p>Lists all reviews and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def reviews(self, event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Review]]:\n    \"\"\"Lists all reviews and their details\"\"\"\n    return self._endpoint_lst(Review, event_slug, 'reviews', params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.room","title":"<code>room(event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Room</code>","text":"<p>Returns a specific room</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def room(self, event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Room:  # noqa: A002\n    \"\"\"Returns a specific room\"\"\"\n    return self._endpoint_id(Room, event_slug, 'rooms', id, params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.rooms","title":"<code>rooms(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Room]]</code>","text":"<p>Lists all rooms and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def rooms(self, event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Room]]:\n    \"\"\"Lists all rooms and their details\"\"\"\n    return self._endpoint_lst(Room, event_slug, 'rooms', params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.set_cache_prepopulation","title":"<code>set_cache_prepopulation(enabled: bool) -&gt; None</code>","text":"<p>Enable or disable automatic cache pre-population for submissions.</p> <p>When enabled (default), the client will fetch all speakers, submission types, and tracks in bulk on the first submission to minimize API calls. Disable this if you're only fetching a few submissions.</p> <p>Parameters:</p> Name Type Description Default <code>enabled</code> <code>bool</code> <p>Whether to enable cache pre-population</p> required Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def set_cache_prepopulation(self, enabled: bool) -&gt; None:  # noqa: FBT001\n    \"\"\"Enable or disable automatic cache pre-population for submissions.\n\n    When enabled (default), the client will fetch all speakers, submission types,\n    and tracks in bulk on the first submission to minimize API calls.\n    Disable this if you're only fetching a few submissions.\n\n    Args:\n        enabled: Whether to enable cache pre-population\n    \"\"\"\n    self._use_cache_prepopulation = enabled\n    _logger.info(f'Cache pre-population {\"enabled\" if enabled else \"disabled\"}')\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.set_throttling","title":"<code>set_throttling(calls: int, seconds: int)</code>","text":"<p>Throttle the number of calls per seconds to the Pretalx API</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def set_throttling(self, calls: int, seconds: int):\n    \"\"\"Throttle the number of calls per seconds to the Pretalx API\"\"\"\n    _logger.info('throttling', calls=calls, seconds=seconds)\n    self._get_throttled = throttle(calls, seconds)(self._get)\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.speaker","title":"<code>speaker(event_slug: str, code: str, *, params: QueryParams | dict | None = None) -&gt; Speaker</code>","text":"<p>Returns a specific speaker</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def speaker(self, event_slug: str, code: str, *, params: QueryParams | dict | None = None) -&gt; Speaker:\n    \"\"\"Returns a specific speaker\"\"\"\n    return self._endpoint_id(Speaker, event_slug, 'speakers', code, params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.speakers","title":"<code>speakers(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Speaker]]</code>","text":"<p>Lists all speakers and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def speakers(self, event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Speaker]]:\n    \"\"\"Lists all speakers and their details\"\"\"\n    return self._endpoint_lst(Speaker, event_slug, 'speakers', params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.submission","title":"<code>submission(event_slug: str, code: str, *, params: QueryParams | dict | None = None) -&gt; Submission</code>","text":"<p>Returns a specific submission</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def submission(self, event_slug: str, code: str, *, params: QueryParams | dict | None = None) -&gt; Submission:\n    \"\"\"Returns a specific submission\"\"\"\n    return self._endpoint_id(Submission, event_slug, 'submissions', code, params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.submission_type","title":"<code>submission_type(event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; SubmissionType</code>","text":"<p>Returns a specific submission type</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def submission_type(self, event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; SubmissionType:  # noqa: A002\n    \"\"\"Returns a specific submission type\"\"\"\n    return self._endpoint_id(SubmissionType, event_slug, 'submission-types', id, params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.submission_types","title":"<code>submission_types(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[SubmissionType]]</code>","text":"<p>Lists all submission types and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def submission_types(\n    self, event_slug: str, *, params: QueryParams | dict | None = None\n) -&gt; tuple[int, Iterator[SubmissionType]]:\n    \"\"\"Lists all submission types and their details\"\"\"\n    return self._endpoint_lst(SubmissionType, event_slug, 'submission-types', params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.submissions","title":"<code>submissions(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Submission]]</code>","text":"<p>Lists all submissions and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def submissions(\n    self, event_slug: str, *, params: QueryParams | dict | None = None\n) -&gt; tuple[int, Iterator[Submission]]:\n    \"\"\"Lists all submissions and their details\"\"\"\n    return self._endpoint_lst(Submission, event_slug, 'submissions', params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.tag","title":"<code>tag(event_slug: str, tag: str, *, params: QueryParams | dict | None = None) -&gt; Tag</code>","text":"<p>Returns a specific tag</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def tag(self, event_slug: str, tag: str, *, params: QueryParams | dict | None = None) -&gt; Tag:\n    \"\"\"Returns a specific tag\"\"\"\n    return self._endpoint_id(Tag, event_slug, 'tags', tag, params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.tags","title":"<code>tags(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Tag]]</code>","text":"<p>Lists all tags and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def tags(self, event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Tag]]:\n    \"\"\"Lists all tags and their details\"\"\"\n    return self._endpoint_lst(Tag, event_slug, 'tags', params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.talk","title":"<code>talk(event_slug: str, code: str, *, params: QueryParams | dict | None = None) -&gt; Talk</code>","text":"<p>Returns a specific talk</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def talk(self, event_slug: str, code: str, *, params: QueryParams | dict | None = None) -&gt; Talk:\n    \"\"\"Returns a specific talk\"\"\"\n    try:\n        return self._endpoint_id(Talk, event_slug, 'talks', code, params=params)\n    except httpx.HTTPStatusError as e:\n        if e.response.status_code == HTTP_NOT_FOUND:\n            _logger.info('talk endpoint not available, using submission endpoint')\n            # Use submission endpoint but validate as Talk object\n            return self._endpoint_id(Talk, event_slug, 'submissions', code, params=params)\n        raise\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.talks","title":"<code>talks(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Talk]]</code>","text":"<p>Lists all talks and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def talks(self, event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Talk]]:\n    \"\"\"Lists all talks and their details\"\"\"\n    try:\n        return self._endpoint_lst(Talk, event_slug, 'talks', params=params)\n    except httpx.HTTPStatusError as e:\n        if e.response.status_code == HTTP_NOT_FOUND:\n            _logger.info('talks endpoint not available, using submissions endpoint')\n            # Use submissions endpoint but validate as Talk objects\n            return self._endpoint_lst(Talk, event_slug, 'submissions', params=params)\n        raise\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.track","title":"<code>track(event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Track</code>","text":"<p>Returns a specific track</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def track(self, event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Track:  # noqa: A002\n    \"\"\"Returns a specific track\"\"\"\n    return self._endpoint_id(Track, event_slug, 'tracks', id, params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.tracks","title":"<code>tracks(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Track]]</code>","text":"<p>Lists all tracks and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def tracks(self, event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Track]]:\n    \"\"\"Lists all tracks and their details\"\"\"\n    return self._endpoint_lst(Track, event_slug, 'tracks', params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/models/","title":"Models","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models","title":"<code>models</code>","text":"<p>Return types of the Pretalx API</p> <p>Documentation: https://docs.pretalx.org/api/resources/index.html</p> <p>Attention: Quite often the API docs and the actual results of the API differ!</p> <p>ToDo</p> <ul> <li>Find out why <code>extra=Extra.allow</code> causes mypy to fail. Seems like a bug in pydantic.</li> </ul>"},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Answer","title":"<code>Answer</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Answer.answer","title":"<code>answer: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Answer.answer_file","title":"<code>answer_file: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Answer.id","title":"<code>id: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Answer.options","title":"<code>options: list[Option] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Answer.person","title":"<code>person: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Answer.question","title":"<code>question: AnswerQuestionRef</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Answer.review","title":"<code>review: int | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Answer.submission","title":"<code>submission: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.AnswerQuestionRef","title":"<code>AnswerQuestionRef</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.AnswerQuestionRef.id","title":"<code>id: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.AnswerQuestionRef.question","title":"<code>question: MultiLingualStr</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Event","title":"<code>Event</code>","text":"<p>Event model for Pretalx API.</p> <p>Note: The 'urls' field was present in older API versions but is no longer provided by the API as of v1/v2. It's kept as optional for backward compatibility.</p>"},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Event.date_from","title":"<code>date_from: date</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Event.date_to","title":"<code>date_to: date | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Event.is_public","title":"<code>is_public: bool</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Event.name","title":"<code>name: MultiLingualStr</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Event.slug","title":"<code>slug: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Event.timezone","title":"<code>timezone: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Event.urls","title":"<code>urls: URLs | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Me","title":"<code>Me</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Me.email","title":"<code>email: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Me.local","title":"<code>local: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Me.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Me.timezone","title":"<code>timezone: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.MultiLingualStr","title":"<code>MultiLingualStr</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.MultiLingualStr.de","title":"<code>de: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.MultiLingualStr.en","title":"<code>en: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.MultiLingualStr.model_config","title":"<code>model_config = ConfigDict(extra='allow')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Option","title":"<code>Option</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Option.answer","title":"<code>answer: MultiLingualStr</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Option.id","title":"<code>id: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Question","title":"<code>Question</code>","text":"<p>Pretalx introduced breaking API changes in 06/2025 with API \"v1\": The attributes are not actively used, we fall back to defaults for now - required is missing now: is extrapolated from question_required - contains_personal_data: is missing although documented, defaults to False now - is_public: is missing although documented, defaults to False now - is_visible_to_reviewers: is missing although documented, defaults to False now</p>"},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Question.contains_personal_data","title":"<code>contains_personal_data: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Question.deadline","title":"<code>deadline: datetime | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Question.default_answer","title":"<code>default_answer: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Question.freeze_after","title":"<code>freeze_after: datetime | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Question.help_text","title":"<code>help_text: MultiLingualStr</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Question.id","title":"<code>id: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Question.is_public","title":"<code>is_public: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Question.is_visible_to_reviewers","title":"<code>is_visible_to_reviewers: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Question.max_length","title":"<code>max_length: int | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Question.min_length","title":"<code>min_length: int | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Question.options","title":"<code>options: list[Option]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Question.question","title":"<code>question: MultiLingualStr</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Question.question_required","title":"<code>question_required: QuestionRequirement</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Question.read_only","title":"<code>read_only: bool | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Question.required","title":"<code>required: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Question.target","title":"<code>target: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Question.variant","title":"<code>variant: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Question.is_required","title":"<code>is_required(model)</code>  <code>classmethod</code>","text":"Source code in <code>src/pytanis/pretalx/models.py</code> <pre><code>@model_validator(mode='after')\n@classmethod\ndef is_required(cls, model):\n    if model.question_required and model.question_required != QuestionRequirement.optional:\n        model.required = True\n    else:\n        model.required = False\n    return model\n</code></pre>"},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.QuestionRequirement","title":"<code>QuestionRequirement</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.QuestionRequirement.after_deadline","title":"<code>after_deadline = 'after deadline'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.QuestionRequirement.optional","title":"<code>optional = 'optional'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.QuestionRequirement.required","title":"<code>required = 'required'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Resource","title":"<code>Resource</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Resource.description","title":"<code>description: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Resource.resource","title":"<code>resource: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Review","title":"<code>Review</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Review.answers","title":"<code>answers: list[str]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Review.created","title":"<code>created: datetime</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Review.id","title":"<code>id: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Review.score","title":"<code>score: float | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Review.submission","title":"<code>submission: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Review.text","title":"<code>text: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Review.updated","title":"<code>updated: datetime</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Review.user","title":"<code>user: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Room","title":"<code>Room</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Room.availabilities","title":"<code>availabilities: list[RoomAvailability] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Room.capacity","title":"<code>capacity: int | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Room.description","title":"<code>description: MultiLingualStr</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Room.id","title":"<code>id: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Room.name","title":"<code>name: MultiLingualStr</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Room.position","title":"<code>position: int | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Room.speaker_info","title":"<code>speaker_info: MultiLingualStr | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.RoomAvailability","title":"<code>RoomAvailability</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.RoomAvailability.end","title":"<code>end: datetime</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.RoomAvailability.start","title":"<code>start: datetime</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.SimpleTalk","title":"<code>SimpleTalk</code>","text":"<p>Simplified Talk model for generating JSON output</p> <p>This model contains only the essential information needed for display purposes.</p>"},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.SimpleTalk.abstract","title":"<code>abstract: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.SimpleTalk.code","title":"<code>code: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.SimpleTalk.description","title":"<code>description: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.SimpleTalk.domain_level","title":"<code>domain_level: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.SimpleTalk.duration","title":"<code>duration: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.SimpleTalk.organisation","title":"<code>organisation: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.SimpleTalk.prerequisites","title":"<code>prerequisites: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.SimpleTalk.python_level","title":"<code>python_level: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.SimpleTalk.speaker","title":"<code>speaker: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.SimpleTalk.title","title":"<code>title: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.SimpleTalk.track","title":"<code>track: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Slot","title":"<code>Slot</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Slot.end","title":"<code>end: datetime | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Slot.room","title":"<code>room: MultiLingualStr | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Slot.room_id","title":"<code>room_id: int | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Slot.start","title":"<code>start: datetime | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Speaker","title":"<code>Speaker</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Speaker.answers","title":"<code>answers: list[Answer] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Speaker.availabilities","title":"<code>availabilities: list[SpeakerAvailability] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Speaker.submissions","title":"<code>submissions: list[str]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.SpeakerAvailability","title":"<code>SpeakerAvailability</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.SpeakerAvailability.allDay","title":"<code>allDay: str = Field(..., alias='all_day')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.SpeakerAvailability.end","title":"<code>end: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.SpeakerAvailability.id","title":"<code>id: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.SpeakerAvailability.start","title":"<code>start: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.State","title":"<code>State</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.State.accepted","title":"<code>accepted = 'accepted'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.State.canceled","title":"<code>canceled = 'canceled'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.State.confirmed","title":"<code>confirmed = 'confirmed'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.State.deleted","title":"<code>deleted = 'deleted'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.State.rejected","title":"<code>rejected = 'rejected'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.State.submitted","title":"<code>submitted = 'submitted'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.State.withdrawn","title":"<code>withdrawn = 'withdrawn'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Submission","title":"<code>Submission</code>","text":"<p>Pretalx introduced breaking API changes in 06/2025 with API \"v1\": - submission_type changed: TempSubmissionType can handle this now,   a validator will mangel the data back to the old format MultiLingualStr - submission_type_id: no longer exists, will be set via submission_type now - is_featured is documented but does not show, defaults to False now</p>"},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Submission.abstract","title":"<code>abstract: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Submission.answers","title":"<code>answers: list[Answer] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Submission.code","title":"<code>code: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Submission.created","title":"<code>created: datetime | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Submission.description","title":"<code>description: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Submission.do_not_record","title":"<code>do_not_record: bool</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Submission.duration","title":"<code>duration: int | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Submission.image","title":"<code>image: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Submission.internal_notes","title":"<code>internal_notes: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Submission.is_featured","title":"<code>is_featured: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Submission.notes","title":"<code>notes: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Submission.pending_state","title":"<code>pending_state: State | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Submission.resources","title":"<code>resources: list[Resource]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Submission.slot","title":"<code>slot: Slot | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Submission.slot_count","title":"<code>slot_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Submission.speakers","title":"<code>speakers: list[SubmissionSpeaker]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Submission.state","title":"<code>state: State</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Submission.submission_type","title":"<code>submission_type: TransSubmissionType | MultiLingualStr</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Submission.submission_type_id","title":"<code>submission_type_id: int | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Submission.tag_ids","title":"<code>tag_ids: list[int] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Submission.tags","title":"<code>tags: list[str] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Submission.title","title":"<code>title: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Submission.track","title":"<code>track: MultiLingualStr | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Submission.track_id","title":"<code>track_id: int | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Submission.mangle_submission_type","title":"<code>mangle_submission_type(model)</code>  <code>classmethod</code>","text":"Source code in <code>src/pytanis/pretalx/models.py</code> <pre><code>@model_validator(mode='after')\n@classmethod\ndef mangle_submission_type(cls, model):\n    # handle changes introduced via API v1\n    if model.submission_type:\n        model.submission_type_id = getattr(model.submission_type, 'id', None)\n        model.submission_type = getattr(model.submission_type, 'name', None)\n    return model\n</code></pre>"},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.SubmissionSpeaker","title":"<code>SubmissionSpeaker</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.SubmissionSpeaker.avatar","title":"<code>avatar: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.SubmissionSpeaker.biography","title":"<code>biography: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.SubmissionSpeaker.code","title":"<code>code: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.SubmissionSpeaker.email","title":"<code>email: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.SubmissionSpeaker.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.SubmissionType","title":"<code>SubmissionType</code>","text":"<p>Submission type model for internal use in caching</p>"},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.SubmissionType.default_duration","title":"<code>default_duration: int | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.SubmissionType.id","title":"<code>id: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.SubmissionType.name","title":"<code>name: MultiLingualStr</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Tag","title":"<code>Tag</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Tag.color","title":"<code>color: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Tag.description","title":"<code>description: MultiLingualStr</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Tag.tag","title":"<code>tag: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Talk","title":"<code>Talk</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Track","title":"<code>Track</code>","text":"<p>Track model for internal use in caching</p>"},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Track.color","title":"<code>color: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Track.description","title":"<code>description: MultiLingualStr | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Track.id","title":"<code>id: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Track.name","title":"<code>name: MultiLingualStr</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.TransSubmissionType","title":"<code>TransSubmissionType</code>","text":"<p>Model to handle compatibility</p>"},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.TransSubmissionType.id","title":"<code>id: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.TransSubmissionType.model_config","title":"<code>model_config = ConfigDict(extra='allow')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.TransSubmissionType.name","title":"<code>name: MultiLingualStr</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.URLs","title":"<code>URLs</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.URLs.base","title":"<code>base: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.URLs.feed","title":"<code>feed: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.URLs.login","title":"<code>login: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.URLs.schedule","title":"<code>schedule: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.User","title":"<code>User</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.User.email","title":"<code>email: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.User.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/utils/","title":"Utils","text":""},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils","title":"<code>utils</code>","text":"<p>Utilities related to Pretalx</p>"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col","title":"<code>Col</code>","text":"<p>Convention of Pretalx column names for the functions below.</p>"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.affiliation","title":"<code>affiliation = 'Affiliation'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.availability","title":"<code>availability = 'Availability'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.availability_comment","title":"<code>availability_comment = 'Availability Comment'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.biography","title":"<code>biography = 'Biography'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.comment","title":"<code>comment = 'Comment'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.created","title":"<code>created = 'Created'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.duration","title":"<code>duration = 'Duration'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.email","title":"<code>email = 'Email'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.nreviews","title":"<code>nreviews = '#Reviews'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.pending_state","title":"<code>pending_state = 'Pending state'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.pretalx_user","title":"<code>pretalx_user = 'Pretalx user'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.public","title":"<code>public = 'Public'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.review_score","title":"<code>review_score = 'Review Score'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.speaker_code","title":"<code>speaker_code = 'Speaker code'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.speaker_name","title":"<code>speaker_name = 'Speaker name'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.state","title":"<code>state = 'State'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.submission","title":"<code>submission = 'Submission'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.submission_type","title":"<code>submission_type = 'Submission type'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.submission_type_id","title":"<code>submission_type_id = 'Submission type id'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.title","title":"<code>title = 'Title'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.track","title":"<code>track = 'Track'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.create_simple_talk_from_talk","title":"<code>create_simple_talk_from_talk(talk: Talk) -&gt; SimpleTalk</code>","text":"<p>Create a SimpleTalk object with basic information from a Talk object.</p> Source code in <code>src/pytanis/pretalx/utils.py</code> <pre><code>def create_simple_talk_from_talk(talk: Talk) -&gt; SimpleTalk:\n    \"\"\"Create a SimpleTalk object with basic information from a Talk object.\"\"\"\n    track_value = ''\n    if talk.track is not None and talk.track.en is not None:\n        track_value = talk.track.en\n\n    return SimpleTalk(\n        code=talk.code,\n        title=talk.title,\n        speaker=', '.join([speaker.name for speaker in talk.speakers]),\n        track=track_value,\n        duration=str(talk.duration) if talk.duration else '',\n        abstract=talk.abstract,\n        description=talk.description,\n    )\n</code></pre>"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.extract_expertise_and_prerequisites","title":"<code>extract_expertise_and_prerequisites(talk: Talk, simple_talk: SimpleTalk) -&gt; None</code>","text":"<p>Extract expertise levels and prerequisites from talk answers.</p> Source code in <code>src/pytanis/pretalx/utils.py</code> <pre><code>def extract_expertise_and_prerequisites(talk: Talk, simple_talk: SimpleTalk) -&gt; None:\n    \"\"\"Extract expertise levels and prerequisites from talk answers.\"\"\"\n    if not talk.answers:\n        return\n\n    # Extract domain expertise level\n    domain_expertise = find_answer_by_pattern(talk.answers, 'Expected audience expertise: Domain')\n\n    # Extract Python expertise level\n    python_expertise = find_answer_by_pattern(talk.answers, 'Expected audience expertise: Python')\n\n    # Extract prerequisites using keywords\n    prerequisites = find_answer_by_pattern(\n        talk.answers, '', case_sensitive=False, keywords=['prerequisite', 'requirement', 'needed', 'necessary']\n    )\n\n    # Set the extracted values\n    simple_talk.domain_level = domain_expertise\n    simple_talk.python_level = python_expertise\n    simple_talk.prerequisites = prerequisites\n</code></pre>"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.extract_organisation","title":"<code>extract_organisation(talk: Talk, simple_talk: SimpleTalk, pretalx_client: PretalxClient, event_slug: str, speaker_data: dict[str, Speaker]) -&gt; None</code>","text":"<p>Extract organisation information from speaker data.</p> Source code in <code>src/pytanis/pretalx/utils.py</code> <pre><code>def extract_organisation(\n    talk: Talk,\n    simple_talk: SimpleTalk,\n    pretalx_client: PretalxClient,\n    event_slug: str,\n    speaker_data: dict[str, Speaker],\n) -&gt; None:\n    \"\"\"Extract organisation information from speaker data.\"\"\"\n    if not (pretalx_client and event_slug):\n        return\n\n    organisations = []\n\n    for speaker in talk.speakers:\n        # Check if we already have this speaker's data\n        if speaker.code not in speaker_data:\n            try:\n                # Fetch speaker data with answers\n                speaker_data[speaker.code] = pretalx_client.speaker(\n                    event_slug, speaker.code, params={'questions': 'all'}\n                )\n            except Exception as e:\n                # If there's an error fetching speaker data, just continue\n                _logger.error(f'Error fetching data for speaker {speaker.code}: {e}')\n                continue\n\n        # Get the speaker with full data including answers\n        full_speaker = speaker_data[speaker.code]\n\n        # Look for \"Company / Institute\" in speaker answers\n        if full_speaker.answers:\n            # Filter to only include speaker-specific answers\n            speaker_answers = [answer for answer in full_speaker.answers if answer.person is not None]\n\n            # Find the organisation using our helper function\n            organisation = find_answer_by_pattern(speaker_answers, 'Company / Institute')\n            if organisation.strip():\n                organisations.append(organisation.strip())\n\n    # If we found organisations in the speaker answers, use them\n    if organisations:\n        # Remove duplicates while preserving order\n        unique_organisations = []\n        for org in organisations:\n            if org not in unique_organisations:\n                unique_organisations.append(org)\n        simple_talk.organisation = ', '.join(unique_organisations)\n</code></pre>"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.find_answer_by_pattern","title":"<code>find_answer_by_pattern(answers: list[Answer], pattern: str, *, case_sensitive: bool = True, keywords: list[str] | None = None) -&gt; str</code>","text":"<p>Find an answer by matching a pattern or keywords in the question text.</p> <p>Parameters:</p> Name Type Description Default <code>answers</code> <code>list[Answer]</code> <p>List of Answer objects to search through</p> required <code>pattern</code> <code>str</code> <p>Exact pattern to search for in question text</p> required <code>case_sensitive</code> <code>bool</code> <p>Whether the pattern matching should be case sensitive</p> <code>True</code> <code>keywords</code> <code>list[str] | None</code> <p>List of keywords to search for in question text (case insensitive)</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The answer text if found, empty string otherwise</p> Source code in <code>src/pytanis/pretalx/utils.py</code> <pre><code>def find_answer_by_pattern(\n    answers: list[Answer], pattern: str, *, case_sensitive: bool = True, keywords: list[str] | None = None\n) -&gt; str:\n    \"\"\"Find an answer by matching a pattern or keywords in the question text.\n\n    Args:\n        answers: List of Answer objects to search through\n        pattern: Exact pattern to search for in question text\n        case_sensitive: Whether the pattern matching should be case sensitive\n        keywords: List of keywords to search for in question text (case insensitive)\n\n    Returns:\n        The answer text if found, empty string otherwise\n    \"\"\"\n    if not answers:\n        return ''\n\n    for answer in answers:\n        question_text = answer.question.question.en or ''\n\n        # Check for exact pattern match\n        if pattern:\n            if case_sensitive and pattern in question_text:\n                return answer.answer\n            elif not case_sensitive and pattern.lower() in question_text.lower():\n                return answer.answer\n\n        # Check for keywords match\n        if keywords and any(keyword.lower() in question_text.lower() for keyword in keywords):\n            return answer.answer\n\n    return ''\n</code></pre>"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.get_confirmed_talks_as_json","title":"<code>get_confirmed_talks_as_json(pretalx_client: PretalxClient, event_slug: str, params: dict[str, Any] | None = None) -&gt; str</code>","text":"<p>Get confirmed talks from pretalx and convert them to JSON (legacy function for backward compatibility).</p> <p>Parameters:</p> Name Type Description Default <code>pretalx_client</code> <code>PretalxClient</code> <p>PretalxClient instance to fetch talk and speaker data</p> required <code>event_slug</code> <code>str</code> <p>Event slug for the pretalx event</p> required <code>params</code> <code>dict[str, Any] | None</code> <p>Additional parameters to pass to the pretalx API</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>A JSON string containing a list of SimpleTalk objects</p> Source code in <code>src/pytanis/pretalx/utils.py</code> <pre><code>def get_confirmed_talks_as_json(\n    pretalx_client: PretalxClient, event_slug: str, params: dict[str, Any] | None = None\n) -&gt; str:\n    \"\"\"\n    Get confirmed talks from pretalx and convert them to JSON (legacy function for backward compatibility).\n\n    Args:\n        pretalx_client: PretalxClient instance to fetch talk and speaker data\n        event_slug: Event slug for the pretalx event\n        params: Additional parameters to pass to the pretalx API\n\n    Returns:\n        A JSON string containing a list of SimpleTalk objects\n    \"\"\"\n    return get_talks_as_json(pretalx_client, event_slug, 'confirmed', params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.get_talks_as_json","title":"<code>get_talks_as_json(pretalx_client: PretalxClient, event_slug: str, state_value: str = 'confirmed', params: dict[str, Any] | None = None) -&gt; str</code>","text":"<p>Get talks from pretalx and convert them to a JSON list of SimpleTalk objects.</p> <p>This function fetches talks from pretalx based on the specified state, extracts the essential information, and returns a JSON string containing a list of simplified talk objects.</p> <p>Parameters:</p> Name Type Description Default <code>pretalx_client</code> <code>PretalxClient</code> <p>PretalxClient instance to fetch talk and speaker data</p> required <code>event_slug</code> <code>str</code> <p>Event slug for the pretalx event</p> required <code>state_value</code> <code>str</code> <p>State of talks to include (default: \"confirmed\")</p> <code>'confirmed'</code> <code>params</code> <code>dict[str, Any] | None</code> <p>Additional parameters to pass to the pretalx API</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>A JSON string containing a list of SimpleTalk objects</p> Source code in <code>src/pytanis/pretalx/utils.py</code> <pre><code>def get_talks_as_json(\n    pretalx_client: PretalxClient, event_slug: str, state_value: str = 'confirmed', params: dict[str, Any] | None = None\n) -&gt; str:\n    \"\"\"\n    Get talks from pretalx and convert them to a JSON list of SimpleTalk objects.\n\n    This function fetches talks from pretalx based on the specified state,\n    extracts the essential information, and returns a JSON string containing\n    a list of simplified talk objects.\n\n    Args:\n        pretalx_client: PretalxClient instance to fetch talk and speaker data\n        event_slug: Event slug for the pretalx event\n        state_value: State of talks to include (default: \"confirmed\")\n        params: Additional parameters to pass to the pretalx API\n\n    Returns:\n        A JSON string containing a list of SimpleTalk objects\n    \"\"\"\n    # Prepare parameters for the API call\n    if params is None:\n        params = {}\n\n    # Ensure we get all questions and filter by state\n    params['questions'] = 'all'\n    params['state'] = state_value\n\n    # Fetch talks from pretalx\n    _, talks_iter = pretalx_client.talks(event_slug, params=params)\n    talks = list(talks_iter)  # Materialize the iterator\n\n    return talks_to_json(talks, pretalx_client, event_slug)\n</code></pre>"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.reviews_as_df","title":"<code>reviews_as_df(reviews: Iterable[Review]) -&gt; pd.DataFrame</code>","text":"<p>Convert the reviews to a dataframe</p> Source code in <code>src/pytanis/pretalx/utils.py</code> <pre><code>def reviews_as_df(reviews: Iterable[Review]) -&gt; pd.DataFrame:\n    \"\"\"Convert the reviews to a dataframe\"\"\"\n    df = pd.DataFrame([review.model_dump() for review in reviews])\n    # make first letter of column upper-case in accordance with our convention\n    df.rename(columns={col: col.title() for col in df.columns}, inplace=True)\n    # user is the speaker name to use for joining\n    df.rename(columns={'User': Col.pretalx_user, 'Score': Col.review_score}, inplace=True)\n\n    return df\n</code></pre>"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.save_confirmed_talks_to_json","title":"<code>save_confirmed_talks_to_json(talks: Iterable[Talk], file_path: str, pretalx_client: PretalxClient | None = None, event_slug: str | None = None) -&gt; None</code>","text":"<p>Save confirmed talks to a JSON file (legacy function for backward compatibility).</p> <p>Parameters:</p> Name Type Description Default <code>talks</code> <code>Iterable[Talk]</code> <p>An iterable of Talk objects, typically from pretalx_client.talks()</p> required <code>file_path</code> <code>str</code> <p>Path where the JSON file should be saved</p> required <code>pretalx_client</code> <code>PretalxClient | None</code> <p>Optional PretalxClient instance to fetch speaker data</p> <code>None</code> <code>event_slug</code> <code>str | None</code> <p>Optional event slug needed if pretalx_client is provided</p> <code>None</code> Source code in <code>src/pytanis/pretalx/utils.py</code> <pre><code>def save_confirmed_talks_to_json(\n    talks: Iterable[Talk], file_path: str, pretalx_client: PretalxClient | None = None, event_slug: str | None = None\n) -&gt; None:\n    \"\"\"\n    Save confirmed talks to a JSON file (legacy function for backward compatibility).\n\n    Args:\n        talks: An iterable of Talk objects, typically from pretalx_client.talks()\n        file_path: Path where the JSON file should be saved\n        pretalx_client: Optional PretalxClient instance to fetch speaker data\n        event_slug: Optional event slug needed if pretalx_client is provided\n    \"\"\"\n    json_data = talks_to_json([talk for talk in talks if talk.state.value == 'confirmed'], pretalx_client, event_slug)\n\n    with open(file_path, 'w', encoding='utf-8') as f:\n        f.write(json_data)\n</code></pre>"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.save_talks_to_json","title":"<code>save_talks_to_json(pretalx_client: PretalxClient, event_slug: str, file_path: str, state_value: str = 'confirmed', params: dict[str, Any] | None = None) -&gt; None</code>","text":"<p>Fetch talks from pretalx and save them to a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>pretalx_client</code> <code>PretalxClient</code> <p>PretalxClient instance to fetch talk and speaker data</p> required <code>event_slug</code> <code>str</code> <p>Event slug for the pretalx event</p> required <code>file_path</code> <code>str</code> <p>Path where the JSON file should be saved</p> required <code>state_value</code> <code>str</code> <p>State of talks to include (default: \"confirmed\")</p> <code>'confirmed'</code> <code>params</code> <code>dict[str, Any] | None</code> <p>Additional parameters to pass to the pretalx API</p> <code>None</code> Source code in <code>src/pytanis/pretalx/utils.py</code> <pre><code>def save_talks_to_json(\n    pretalx_client: PretalxClient,\n    event_slug: str,\n    file_path: str,\n    state_value: str = 'confirmed',\n    params: dict[str, Any] | None = None,\n) -&gt; None:\n    \"\"\"\n    Fetch talks from pretalx and save them to a JSON file.\n\n    Args:\n        pretalx_client: PretalxClient instance to fetch talk and speaker data\n        event_slug: Event slug for the pretalx event\n        file_path: Path where the JSON file should be saved\n        state_value: State of talks to include (default: \"confirmed\")\n        params: Additional parameters to pass to the pretalx API\n    \"\"\"\n    json_data = get_talks_as_json(pretalx_client, event_slug, state_value, params)\n\n    with open(file_path, 'w', encoding='utf-8') as f:\n        f.write(json_data)\n</code></pre>"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.speakers_as_df","title":"<code>speakers_as_df(speakers: Iterable[Speaker], *, with_questions: bool = False, question_prefix: str = 'Q: ') -&gt; pd.DataFrame</code>","text":"<p>Convert speakers into a dataframe</p> <p>Make sure to have <code>params={\"questions\": \"all\"}</code> for the PretalxAPI if <code>with_questions</code> is True.</p> Source code in <code>src/pytanis/pretalx/utils.py</code> <pre><code>def speakers_as_df(\n    speakers: Iterable[Speaker], *, with_questions: bool = False, question_prefix: str = 'Q: '\n) -&gt; pd.DataFrame:\n    \"\"\"Convert speakers into a dataframe\n\n    Make sure to have `params={\"questions\": \"all\"}` for the PretalxAPI if `with_questions` is True.\n    \"\"\"\n    rows = []\n    for speaker in speakers:\n        row = {\n            Col.speaker_code: speaker.code,\n            Col.speaker_name: speaker.name,\n            Col.email: speaker.email,\n            Col.biography: speaker.biography,\n            Col.submission: speaker.submissions,\n        }\n        if with_questions and speaker.answers is not None:\n            for answer in speaker.answers:\n                # The API returns also questions that are 'per proposal/submission', we get these using the\n                # submission endpoint and don't want them here due to ambiguity if several submission were made.\n                if answer.person is not None:\n                    row[f'{question_prefix}{answer.question.question.en}'] = answer.answer\n        rows.append(row)\n    return pd.DataFrame(rows)\n</code></pre>"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.subs_as_df","title":"<code>subs_as_df(subs: Iterable[Submission], *, with_questions: bool = False, question_prefix: str = 'Q: ') -&gt; pd.DataFrame</code>","text":"<p>Convert submissions into a dataframe</p> <p>Make sure to have <code>params={\"questions\": \"all\"}</code> for the PretalxAPI if <code>with_questions</code> is True.</p> Source code in <code>src/pytanis/pretalx/utils.py</code> <pre><code>def subs_as_df(\n    subs: Iterable[Submission], *, with_questions: bool = False, question_prefix: str = 'Q: '\n) -&gt; pd.DataFrame:\n    \"\"\"Convert submissions into a dataframe\n\n    Make sure to have `params={\"questions\": \"all\"}` for the PretalxAPI if `with_questions` is True.\n    \"\"\"\n    rows = []\n    for sub in subs:\n        row = {\n            Col.submission: sub.code,\n            Col.title: sub.title,\n            Col.track: sub.track.en if sub.track else None,\n            Col.speaker_code: [speaker.code for speaker in sub.speakers],\n            Col.speaker_name: [speaker.name for speaker in sub.speakers],\n            Col.duration: sub.duration,\n            Col.submission_type: (\n                sub.submission_type.en if hasattr(sub.submission_type, 'en') else str(sub.submission_type)\n            ),\n            Col.submission_type_id: sub.submission_type_id,\n            Col.state: sub.state.value,\n            Col.pending_state: None if sub.pending_state is None else sub.pending_state.value,\n            Col.created: sub.created,\n        }\n        if with_questions and sub.answers is not None:\n            for answer in sub.answers:\n                row[f'{question_prefix}{answer.question.question.en}'] = answer.answer\n        rows.append(row)\n    return pd.DataFrame(rows)\n</code></pre>"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.talks_to_json","title":"<code>talks_to_json(talks: Iterable[Talk], pretalx_client: PretalxClient | None = None, event_slug: str | None = None) -&gt; str</code>","text":"<p>Convert Talk objects to a JSON list of SimpleTalk objects.</p> <p>This function extracts the essential information from pretalx Talk objects and returns a JSON string containing a list of simplified talk objects.</p> <p>Parameters:</p> Name Type Description Default <code>talks</code> <code>Iterable[Talk]</code> <p>An iterable of Talk objects</p> required <code>pretalx_client</code> <code>PretalxClient | None</code> <p>Optional PretalxClient instance to fetch speaker data</p> <code>None</code> <code>event_slug</code> <code>str | None</code> <p>Optional event slug needed if pretalx_client is provided</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>A JSON string containing a list of SimpleTalk objects</p> Source code in <code>src/pytanis/pretalx/utils.py</code> <pre><code>def talks_to_json(\n    talks: Iterable[Talk], pretalx_client: PretalxClient | None = None, event_slug: str | None = None\n) -&gt; str:\n    \"\"\"\n    Convert Talk objects to a JSON list of SimpleTalk objects.\n\n    This function extracts the essential information from pretalx Talk objects\n    and returns a JSON string containing a list of simplified talk objects.\n\n    Args:\n        talks: An iterable of Talk objects\n        pretalx_client: Optional PretalxClient instance to fetch speaker data\n        event_slug: Optional event slug needed if pretalx_client is provided\n\n    Returns:\n        A JSON string containing a list of SimpleTalk objects\n    \"\"\"\n    simple_talks = []\n\n    # Store speaker data to avoid fetching the same speaker multiple times\n    speaker_data: dict[str, Speaker] = {}\n\n    for talk in talks:\n        # Create a SimpleTalk object with basic information\n        simple_talk = create_simple_talk_from_talk(talk)\n\n        # Extract expertise levels and prerequisites\n        extract_expertise_and_prerequisites(talk, simple_talk)\n\n        # Extract organisation information\n        if event_slug and pretalx_client:\n            extract_organisation(talk, simple_talk, pretalx_client, event_slug, speaker_data)\n\n        simple_talks.append(simple_talk)\n\n    # Convert to JSON\n    return json.dumps([talk.model_dump() for talk in simple_talks], indent=2)\n</code></pre>"},{"location":"reference/pytanis/storage/","title":"Storage","text":""},{"location":"reference/pytanis/storage/#pytanis.storage","title":"<code>storage</code>","text":"<p>Storage abstraction layer for Pytanis</p> <p>This module provides abstract base classes and implementations for storing and retrieving conference data in various formats and backends.</p>"},{"location":"reference/pytanis/storage/#pytanis.storage.__all__","title":"<code>__all__ = ['BaseSpreadsheetClient', 'BaseStorageClient', 'LocalFileClient']</code>  <code>module-attribute</code>","text":""},{"location":"reference/pytanis/storage/#pytanis.storage.BaseSpreadsheetClient","title":"<code>BaseSpreadsheetClient</code>","text":"<p>Abstract base class for spreadsheet-like storage</p> <p>This class defines the interface for working with tabular data in a spreadsheet-like format, supporting multiple worksheets/tabs.</p>"},{"location":"reference/pytanis/storage/#pytanis.storage.BaseSpreadsheetClient.create_spreadsheet","title":"<code>create_spreadsheet(name: str) -&gt; str</code>  <code>abstractmethod</code>","text":"<p>Create a new spreadsheet</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name for the new spreadsheet</p> required <p>Returns:</p> Type Description <code>str</code> <p>The identifier for the created spreadsheet</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If there's an error creating the spreadsheet</p> Source code in <code>src/pytanis/storage/base.py</code> <pre><code>@abstractmethod\ndef create_spreadsheet(self, name: str) -&gt; str:\n    \"\"\"Create a new spreadsheet\n\n    Args:\n        name: The name for the new spreadsheet\n\n    Returns:\n        The identifier for the created spreadsheet\n\n    Raises:\n        IOError: If there's an error creating the spreadsheet\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/pytanis/storage/#pytanis.storage.BaseSpreadsheetClient.delete_sheet","title":"<code>delete_sheet(spreadsheet_id: str, sheet_name: str) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Delete a sheet from a spreadsheet</p> <p>Parameters:</p> Name Type Description Default <code>spreadsheet_id</code> <code>str</code> <p>The identifier for the spreadsheet</p> required <code>sheet_name</code> <code>str</code> <p>The name of the sheet to delete</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the spreadsheet or sheet does not exist</p> <code>IOError</code> <p>If there's an error deleting the sheet</p> Source code in <code>src/pytanis/storage/base.py</code> <pre><code>@abstractmethod\ndef delete_sheet(self, spreadsheet_id: str, sheet_name: str) -&gt; None:\n    \"\"\"Delete a sheet from a spreadsheet\n\n    Args:\n        spreadsheet_id: The identifier for the spreadsheet\n        sheet_name: The name of the sheet to delete\n\n    Raises:\n        KeyError: If the spreadsheet or sheet does not exist\n        IOError: If there's an error deleting the sheet\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/pytanis/storage/#pytanis.storage.BaseSpreadsheetClient.list_sheets","title":"<code>list_sheets(spreadsheet_id: str) -&gt; list[str]</code>  <code>abstractmethod</code>","text":"<p>List all sheets in a spreadsheet</p> <p>Parameters:</p> Name Type Description Default <code>spreadsheet_id</code> <code>str</code> <p>The identifier for the spreadsheet</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>List of sheet names</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the spreadsheet does not exist</p> <code>IOError</code> <p>If there's an error listing sheets</p> Source code in <code>src/pytanis/storage/base.py</code> <pre><code>@abstractmethod\ndef list_sheets(self, spreadsheet_id: str) -&gt; list[str]:\n    \"\"\"List all sheets in a spreadsheet\n\n    Args:\n        spreadsheet_id: The identifier for the spreadsheet\n\n    Returns:\n        List of sheet names\n\n    Raises:\n        KeyError: If the spreadsheet does not exist\n        IOError: If there's an error listing sheets\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/pytanis/storage/#pytanis.storage.BaseSpreadsheetClient.read_all_sheets","title":"<code>read_all_sheets(spreadsheet_id: str) -&gt; dict[str, pd.DataFrame]</code>","text":"<p>Read all sheets from a spreadsheet</p> <p>Parameters:</p> Name Type Description Default <code>spreadsheet_id</code> <code>str</code> <p>The identifier for the spreadsheet</p> required <p>Returns:</p> Type Description <code>dict[str, DataFrame]</code> <p>Dictionary mapping sheet names to DataFrames</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the spreadsheet does not exist</p> <code>IOError</code> <p>If there's an error reading the data</p> Source code in <code>src/pytanis/storage/base.py</code> <pre><code>def read_all_sheets(self, spreadsheet_id: str) -&gt; dict[str, pd.DataFrame]:\n    \"\"\"Read all sheets from a spreadsheet\n\n    Args:\n        spreadsheet_id: The identifier for the spreadsheet\n\n    Returns:\n        Dictionary mapping sheet names to DataFrames\n\n    Raises:\n        KeyError: If the spreadsheet does not exist\n        IOError: If there's an error reading the data\n    \"\"\"\n    sheets = self.list_sheets(spreadsheet_id)\n    return {sheet: self.read_sheet(spreadsheet_id, sheet) for sheet in sheets}\n</code></pre>"},{"location":"reference/pytanis/storage/#pytanis.storage.BaseSpreadsheetClient.read_sheet","title":"<code>read_sheet(spreadsheet_id: str, sheet_name: str | None = None) -&gt; pd.DataFrame</code>  <code>abstractmethod</code>","text":"<p>Read a sheet as a pandas DataFrame</p> <p>Parameters:</p> Name Type Description Default <code>spreadsheet_id</code> <code>str</code> <p>The identifier for the spreadsheet</p> required <code>sheet_name</code> <code>str | None</code> <p>The name of the sheet to read (None for default/first sheet)</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>The sheet data as a DataFrame</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the spreadsheet or sheet does not exist</p> <code>IOError</code> <p>If there's an error reading the data</p> Source code in <code>src/pytanis/storage/base.py</code> <pre><code>@abstractmethod\ndef read_sheet(self, spreadsheet_id: str, sheet_name: str | None = None) -&gt; pd.DataFrame:\n    \"\"\"Read a sheet as a pandas DataFrame\n\n    Args:\n        spreadsheet_id: The identifier for the spreadsheet\n        sheet_name: The name of the sheet to read (None for default/first sheet)\n\n    Returns:\n        The sheet data as a DataFrame\n\n    Raises:\n        KeyError: If the spreadsheet or sheet does not exist\n        IOError: If there's an error reading the data\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/pytanis/storage/#pytanis.storage.BaseSpreadsheetClient.write_sheet","title":"<code>write_sheet(spreadsheet_id: str, data: pd.DataFrame, sheet_name: str | None = None, *, overwrite: bool = True) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Write a pandas DataFrame to a sheet</p> <p>Parameters:</p> Name Type Description Default <code>spreadsheet_id</code> <code>str</code> <p>The identifier for the spreadsheet</p> required <code>data</code> <code>DataFrame</code> <p>The DataFrame to write</p> required <code>sheet_name</code> <code>str | None</code> <p>The name of the sheet to write to</p> <code>None</code> <code>overwrite</code> <code>bool</code> <p>Whether to overwrite existing data</p> <code>True</code> <p>Raises:</p> Type Description <code>IOError</code> <p>If there's an error writing the data</p> Source code in <code>src/pytanis/storage/base.py</code> <pre><code>@abstractmethod\ndef write_sheet(\n    self, spreadsheet_id: str, data: pd.DataFrame, sheet_name: str | None = None, *, overwrite: bool = True\n) -&gt; None:\n    \"\"\"Write a pandas DataFrame to a sheet\n\n    Args:\n        spreadsheet_id: The identifier for the spreadsheet\n        data: The DataFrame to write\n        sheet_name: The name of the sheet to write to\n        overwrite: Whether to overwrite existing data\n\n    Raises:\n        IOError: If there's an error writing the data\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/pytanis/storage/#pytanis.storage.BaseStorageClient","title":"<code>BaseStorageClient</code>","text":"<p>Abstract base class for storage clients</p> <p>This class defines the interface for reading and writing data to various storage backends (e.g., local files, cloud storage, databases).</p>"},{"location":"reference/pytanis/storage/#pytanis.storage.BaseStorageClient.delete","title":"<code>delete(key: str) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Delete data from storage</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The storage key/path to delete</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the key does not exist</p> <code>IOError</code> <p>If there's an error deleting the data</p> Source code in <code>src/pytanis/storage/base.py</code> <pre><code>@abstractmethod\ndef delete(self, key: str) -&gt; None:\n    \"\"\"Delete data from storage\n\n    Args:\n        key: The storage key/path to delete\n\n    Raises:\n        KeyError: If the key does not exist\n        IOError: If there's an error deleting the data\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/pytanis/storage/#pytanis.storage.BaseStorageClient.exists","title":"<code>exists(key: str) -&gt; bool</code>  <code>abstractmethod</code>","text":"<p>Check if a key exists in storage</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The storage key/path to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the key exists, False otherwise</p> Source code in <code>src/pytanis/storage/base.py</code> <pre><code>@abstractmethod\ndef exists(self, key: str) -&gt; bool:\n    \"\"\"Check if a key exists in storage\n\n    Args:\n        key: The storage key/path to check\n\n    Returns:\n        True if the key exists, False otherwise\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/pytanis/storage/#pytanis.storage.BaseStorageClient.list_keys","title":"<code>list_keys(prefix: str = '') -&gt; list[str]</code>  <code>abstractmethod</code>","text":"<p>List all keys in storage with optional prefix filtering</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>Optional prefix to filter keys</p> <code>''</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of keys matching the prefix</p> Source code in <code>src/pytanis/storage/base.py</code> <pre><code>@abstractmethod\ndef list_keys(self, prefix: str = '') -&gt; list[str]:\n    \"\"\"List all keys in storage with optional prefix filtering\n\n    Args:\n        prefix: Optional prefix to filter keys\n\n    Returns:\n        List of keys matching the prefix\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/pytanis/storage/#pytanis.storage.BaseStorageClient.read","title":"<code>read(key: str) -&gt; Any</code>  <code>abstractmethod</code>","text":"<p>Read data from storage</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The storage key/path to read from</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The data stored at the given key</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the key does not exist</p> <code>IOError</code> <p>If there's an error reading the data</p> Source code in <code>src/pytanis/storage/base.py</code> <pre><code>@abstractmethod\ndef read(self, key: str) -&gt; Any:\n    \"\"\"Read data from storage\n\n    Args:\n        key: The storage key/path to read from\n\n    Returns:\n        The data stored at the given key\n\n    Raises:\n        KeyError: If the key does not exist\n        IOError: If there's an error reading the data\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/pytanis/storage/#pytanis.storage.BaseStorageClient.write","title":"<code>write(key: str, data: Any) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Write data to storage</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The storage key/path to write to</p> required <code>data</code> <code>Any</code> <p>The data to store</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If there's an error writing the data</p> Source code in <code>src/pytanis/storage/base.py</code> <pre><code>@abstractmethod\ndef write(self, key: str, data: Any) -&gt; None:\n    \"\"\"Write data to storage\n\n    Args:\n        key: The storage key/path to write to\n        data: The data to store\n\n    Raises:\n        IOError: If there's an error writing the data\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/pytanis/storage/#pytanis.storage.LocalFileClient","title":"<code>LocalFileClient(base_path: Path | str = '.')</code>","text":"<p>Local file storage client supporting various formats</p> <p>This client stores data as local files and supports: - JSON files for general data storage - CSV/Excel files for spreadsheet-like data</p> <p>Parameters:</p> Name Type Description Default <code>base_path</code> <code>Path | str</code> <p>Base directory for storing files</p> <code>'.'</code> Source code in <code>src/pytanis/storage/local.py</code> <pre><code>def __init__(self, base_path: Path | str = '.'):\n    \"\"\"Initialize the local file client\n\n    Args:\n        base_path: Base directory for storing files\n    \"\"\"\n    self.base_path = Path(base_path)\n    self.base_path.mkdir(parents=True, exist_ok=True)\n</code></pre>"},{"location":"reference/pytanis/storage/#pytanis.storage.LocalFileClient.base_path","title":"<code>base_path = Path(base_path)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/storage/#pytanis.storage.LocalFileClient.create_spreadsheet","title":"<code>create_spreadsheet(name: str) -&gt; str</code>","text":"<p>Create a new empty spreadsheet</p> Source code in <code>src/pytanis/storage/local.py</code> <pre><code>def create_spreadsheet(self, name: str) -&gt; str:\n    \"\"\"Create a new empty spreadsheet\"\"\"\n    if not name.endswith(('.xlsx', '.csv')):\n        name = f'{name}.xlsx'\n\n    path = self._get_path(name)\n    if path.exists():\n        raise OSError(f'Spreadsheet already exists: {name}')\n\n    # Create empty file\n    if path.suffix == '.csv':\n        pd.DataFrame().to_csv(path, index=False)\n    else:\n        with pd.ExcelWriter(path, mode='w') as writer:\n            pd.DataFrame().to_excel(writer, sheet_name='Sheet1', index=False)\n\n    return name\n</code></pre>"},{"location":"reference/pytanis/storage/#pytanis.storage.LocalFileClient.delete","title":"<code>delete(key: str) -&gt; None</code>","text":"<p>Delete a file</p> Source code in <code>src/pytanis/storage/local.py</code> <pre><code>def delete(self, key: str) -&gt; None:\n    \"\"\"Delete a file\"\"\"\n    path = self._get_path(key)\n    if not path.exists():\n        raise KeyError(f'File not found: {key}')\n\n    try:\n        path.unlink()\n    except Exception as e:\n        raise OSError(f'Error deleting file {key}: {e}') from e\n</code></pre>"},{"location":"reference/pytanis/storage/#pytanis.storage.LocalFileClient.delete_sheet","title":"<code>delete_sheet(spreadsheet_id: str, sheet_name: str) -&gt; None</code>","text":"<p>Delete a sheet from a spreadsheet</p> Source code in <code>src/pytanis/storage/local.py</code> <pre><code>def delete_sheet(self, spreadsheet_id: str, sheet_name: str) -&gt; None:\n    \"\"\"Delete a sheet from a spreadsheet\"\"\"\n    path = self._get_spreadsheet_path(spreadsheet_id)\n\n    if not path.exists():\n        raise KeyError(f'Spreadsheet not found: {spreadsheet_id}')\n\n    if path.suffix == '.csv':\n        raise OSError('Cannot delete sheets from CSV files')\n\n    try:\n        # Read all sheets except the one to delete\n        excel_file = pd.ExcelFile(path)\n        sheets_to_keep = {\n            name: pd.read_excel(excel_file, sheet_name=name)\n            for name in excel_file.sheet_names\n            if name != sheet_name\n        }\n\n        if sheet_name not in excel_file.sheet_names:\n            raise KeyError(f'Sheet not found: {sheet_name}')\n\n        if not sheets_to_keep:\n            raise OSError('Cannot delete the last sheet in a spreadsheet')\n\n        # Write back remaining sheets\n        with pd.ExcelWriter(path, mode='w') as writer:\n            for name, df in sheets_to_keep.items():\n                df.to_excel(writer, sheet_name=str(name), index=False)\n\n    except Exception as e:\n        if isinstance(e, KeyError | OSError):\n            raise\n        raise OSError(f'Error deleting sheet {sheet_name} from {spreadsheet_id}: {e}') from e\n</code></pre>"},{"location":"reference/pytanis/storage/#pytanis.storage.LocalFileClient.exists","title":"<code>exists(key: str) -&gt; bool</code>","text":"<p>Check if a file exists</p> Source code in <code>src/pytanis/storage/local.py</code> <pre><code>def exists(self, key: str) -&gt; bool:\n    \"\"\"Check if a file exists\"\"\"\n    return self._get_path(key).exists()\n</code></pre>"},{"location":"reference/pytanis/storage/#pytanis.storage.LocalFileClient.list_keys","title":"<code>list_keys(prefix: str = '') -&gt; list[str]</code>","text":"<p>List all files with optional prefix filtering</p> Source code in <code>src/pytanis/storage/local.py</code> <pre><code>def list_keys(self, prefix: str = '') -&gt; list[str]:\n    \"\"\"List all files with optional prefix filtering\"\"\"\n    pattern = f'{prefix}*' if prefix else '*'\n    paths = self.base_path.rglob(pattern)\n    return [str(p.relative_to(self.base_path)) for p in paths if p.is_file()]\n</code></pre>"},{"location":"reference/pytanis/storage/#pytanis.storage.LocalFileClient.list_sheets","title":"<code>list_sheets(spreadsheet_id: str) -&gt; list[str]</code>","text":"<p>List all sheets in a spreadsheet</p> Source code in <code>src/pytanis/storage/local.py</code> <pre><code>def list_sheets(self, spreadsheet_id: str) -&gt; list[str]:\n    \"\"\"List all sheets in a spreadsheet\"\"\"\n    path = self._get_spreadsheet_path(spreadsheet_id)\n\n    if not path.exists():\n        raise KeyError(f'Spreadsheet not found: {spreadsheet_id}')\n\n    if path.suffix == '.csv':\n        return ['default']  # CSV files don't have multiple sheets\n\n    try:\n        # For Excel files, read sheet names\n        excel_file = pd.ExcelFile(path)\n        # Convert all sheet names to strings\n        return [str(name) for name in excel_file.sheet_names]\n    except Exception as e:\n        raise OSError(f'Error listing sheets in {spreadsheet_id}: {e}') from e\n</code></pre>"},{"location":"reference/pytanis/storage/#pytanis.storage.LocalFileClient.read","title":"<code>read(key: str) -&gt; Any</code>","text":"<p>Read data from a JSON file</p> Source code in <code>src/pytanis/storage/local.py</code> <pre><code>def read(self, key: str) -&gt; Any:\n    \"\"\"Read data from a JSON file\"\"\"\n    path = self._get_path(key)\n    if not path.exists():\n        raise KeyError(f'File not found: {key}')\n\n    try:\n        with open(path, encoding='utf-8') as f:\n            return json.load(f)\n    except Exception as e:\n        raise OSError(f'Error reading file {key}: {e}') from e\n</code></pre>"},{"location":"reference/pytanis/storage/#pytanis.storage.LocalFileClient.read_sheet","title":"<code>read_sheet(spreadsheet_id: str, sheet_name: str | None = None) -&gt; pd.DataFrame</code>","text":"<p>Read a sheet from a CSV or Excel file</p> Source code in <code>src/pytanis/storage/local.py</code> <pre><code>def read_sheet(self, spreadsheet_id: str, sheet_name: str | None = None) -&gt; pd.DataFrame:\n    \"\"\"Read a sheet from a CSV or Excel file\"\"\"\n    path = self._get_spreadsheet_path(spreadsheet_id)\n\n    if not path.exists():\n        raise KeyError(f'Spreadsheet not found: {spreadsheet_id}')\n\n    try:\n        if path.suffix == '.csv':\n            if sheet_name is not None:\n                _logger.warning('Sheet name ignored for CSV files', sheet_name=sheet_name)\n            return pd.read_csv(path)\n        else:  # Excel\n            # Always specify sheet_name to ensure we get a DataFrame, not a dict\n            sheet_to_read: str | int = sheet_name if sheet_name is not None else 0\n            return pd.read_excel(path, sheet_name=sheet_to_read)\n    except Exception as e:\n        raise OSError(f'Error reading spreadsheet {spreadsheet_id}: {e}') from e\n</code></pre>"},{"location":"reference/pytanis/storage/#pytanis.storage.LocalFileClient.write","title":"<code>write(key: str, data: Any) -&gt; None</code>","text":"<p>Write data to a JSON file</p> Source code in <code>src/pytanis/storage/local.py</code> <pre><code>def write(self, key: str, data: Any) -&gt; None:\n    \"\"\"Write data to a JSON file\"\"\"\n    path = self._get_path(key)\n    try:\n        with open(path, 'w', encoding='utf-8') as f:\n            json.dump(data, f, indent=2, default=str)\n    except Exception as e:\n        raise OSError(f'Error writing file {key}: {e}') from e\n</code></pre>"},{"location":"reference/pytanis/storage/#pytanis.storage.LocalFileClient.write_sheet","title":"<code>write_sheet(spreadsheet_id: str, data: pd.DataFrame, sheet_name: str | None = None, *, overwrite: bool = True) -&gt; None</code>","text":"<p>Write a DataFrame to a CSV or Excel file</p> Source code in <code>src/pytanis/storage/local.py</code> <pre><code>def write_sheet(\n    self, spreadsheet_id: str, data: pd.DataFrame, sheet_name: str | None = None, *, overwrite: bool = True\n) -&gt; None:\n    \"\"\"Write a DataFrame to a CSV or Excel file\"\"\"\n    path = self._get_spreadsheet_path(spreadsheet_id)\n\n    try:\n        if path.suffix == '.csv':\n            if sheet_name is not None:\n                _logger.warning('Sheet name ignored for CSV files', sheet_name=sheet_name)\n            data.to_csv(path, index=False)\n        elif path.exists() and not overwrite:\n            # Append to existing Excel file\n            with pd.ExcelWriter(path, mode='a', if_sheet_exists='replace') as writer:\n                data.to_excel(writer, sheet_name=sheet_name or 'Sheet1', index=False)\n        else:\n            # Create new or overwrite\n            with pd.ExcelWriter(path, mode='w') as writer:\n                data.to_excel(writer, sheet_name=sheet_name or 'Sheet1', index=False)\n    except Exception as e:\n        raise OSError(f'Error writing spreadsheet {spreadsheet_id}: {e}') from e\n</code></pre>"},{"location":"reference/pytanis/storage/base/","title":"Base","text":""},{"location":"reference/pytanis/storage/base/#pytanis.storage.base","title":"<code>base</code>","text":"<p>Base classes for storage abstraction</p>"},{"location":"reference/pytanis/storage/base/#pytanis.storage.base.BaseSpreadsheetClient","title":"<code>BaseSpreadsheetClient</code>","text":"<p>Abstract base class for spreadsheet-like storage</p> <p>This class defines the interface for working with tabular data in a spreadsheet-like format, supporting multiple worksheets/tabs.</p>"},{"location":"reference/pytanis/storage/base/#pytanis.storage.base.BaseSpreadsheetClient.create_spreadsheet","title":"<code>create_spreadsheet(name: str) -&gt; str</code>  <code>abstractmethod</code>","text":"<p>Create a new spreadsheet</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name for the new spreadsheet</p> required <p>Returns:</p> Type Description <code>str</code> <p>The identifier for the created spreadsheet</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If there's an error creating the spreadsheet</p> Source code in <code>src/pytanis/storage/base.py</code> <pre><code>@abstractmethod\ndef create_spreadsheet(self, name: str) -&gt; str:\n    \"\"\"Create a new spreadsheet\n\n    Args:\n        name: The name for the new spreadsheet\n\n    Returns:\n        The identifier for the created spreadsheet\n\n    Raises:\n        IOError: If there's an error creating the spreadsheet\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/pytanis/storage/base/#pytanis.storage.base.BaseSpreadsheetClient.delete_sheet","title":"<code>delete_sheet(spreadsheet_id: str, sheet_name: str) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Delete a sheet from a spreadsheet</p> <p>Parameters:</p> Name Type Description Default <code>spreadsheet_id</code> <code>str</code> <p>The identifier for the spreadsheet</p> required <code>sheet_name</code> <code>str</code> <p>The name of the sheet to delete</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the spreadsheet or sheet does not exist</p> <code>IOError</code> <p>If there's an error deleting the sheet</p> Source code in <code>src/pytanis/storage/base.py</code> <pre><code>@abstractmethod\ndef delete_sheet(self, spreadsheet_id: str, sheet_name: str) -&gt; None:\n    \"\"\"Delete a sheet from a spreadsheet\n\n    Args:\n        spreadsheet_id: The identifier for the spreadsheet\n        sheet_name: The name of the sheet to delete\n\n    Raises:\n        KeyError: If the spreadsheet or sheet does not exist\n        IOError: If there's an error deleting the sheet\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/pytanis/storage/base/#pytanis.storage.base.BaseSpreadsheetClient.list_sheets","title":"<code>list_sheets(spreadsheet_id: str) -&gt; list[str]</code>  <code>abstractmethod</code>","text":"<p>List all sheets in a spreadsheet</p> <p>Parameters:</p> Name Type Description Default <code>spreadsheet_id</code> <code>str</code> <p>The identifier for the spreadsheet</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>List of sheet names</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the spreadsheet does not exist</p> <code>IOError</code> <p>If there's an error listing sheets</p> Source code in <code>src/pytanis/storage/base.py</code> <pre><code>@abstractmethod\ndef list_sheets(self, spreadsheet_id: str) -&gt; list[str]:\n    \"\"\"List all sheets in a spreadsheet\n\n    Args:\n        spreadsheet_id: The identifier for the spreadsheet\n\n    Returns:\n        List of sheet names\n\n    Raises:\n        KeyError: If the spreadsheet does not exist\n        IOError: If there's an error listing sheets\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/pytanis/storage/base/#pytanis.storage.base.BaseSpreadsheetClient.read_all_sheets","title":"<code>read_all_sheets(spreadsheet_id: str) -&gt; dict[str, pd.DataFrame]</code>","text":"<p>Read all sheets from a spreadsheet</p> <p>Parameters:</p> Name Type Description Default <code>spreadsheet_id</code> <code>str</code> <p>The identifier for the spreadsheet</p> required <p>Returns:</p> Type Description <code>dict[str, DataFrame]</code> <p>Dictionary mapping sheet names to DataFrames</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the spreadsheet does not exist</p> <code>IOError</code> <p>If there's an error reading the data</p> Source code in <code>src/pytanis/storage/base.py</code> <pre><code>def read_all_sheets(self, spreadsheet_id: str) -&gt; dict[str, pd.DataFrame]:\n    \"\"\"Read all sheets from a spreadsheet\n\n    Args:\n        spreadsheet_id: The identifier for the spreadsheet\n\n    Returns:\n        Dictionary mapping sheet names to DataFrames\n\n    Raises:\n        KeyError: If the spreadsheet does not exist\n        IOError: If there's an error reading the data\n    \"\"\"\n    sheets = self.list_sheets(spreadsheet_id)\n    return {sheet: self.read_sheet(spreadsheet_id, sheet) for sheet in sheets}\n</code></pre>"},{"location":"reference/pytanis/storage/base/#pytanis.storage.base.BaseSpreadsheetClient.read_sheet","title":"<code>read_sheet(spreadsheet_id: str, sheet_name: str | None = None) -&gt; pd.DataFrame</code>  <code>abstractmethod</code>","text":"<p>Read a sheet as a pandas DataFrame</p> <p>Parameters:</p> Name Type Description Default <code>spreadsheet_id</code> <code>str</code> <p>The identifier for the spreadsheet</p> required <code>sheet_name</code> <code>str | None</code> <p>The name of the sheet to read (None for default/first sheet)</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>The sheet data as a DataFrame</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the spreadsheet or sheet does not exist</p> <code>IOError</code> <p>If there's an error reading the data</p> Source code in <code>src/pytanis/storage/base.py</code> <pre><code>@abstractmethod\ndef read_sheet(self, spreadsheet_id: str, sheet_name: str | None = None) -&gt; pd.DataFrame:\n    \"\"\"Read a sheet as a pandas DataFrame\n\n    Args:\n        spreadsheet_id: The identifier for the spreadsheet\n        sheet_name: The name of the sheet to read (None for default/first sheet)\n\n    Returns:\n        The sheet data as a DataFrame\n\n    Raises:\n        KeyError: If the spreadsheet or sheet does not exist\n        IOError: If there's an error reading the data\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/pytanis/storage/base/#pytanis.storage.base.BaseSpreadsheetClient.write_sheet","title":"<code>write_sheet(spreadsheet_id: str, data: pd.DataFrame, sheet_name: str | None = None, *, overwrite: bool = True) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Write a pandas DataFrame to a sheet</p> <p>Parameters:</p> Name Type Description Default <code>spreadsheet_id</code> <code>str</code> <p>The identifier for the spreadsheet</p> required <code>data</code> <code>DataFrame</code> <p>The DataFrame to write</p> required <code>sheet_name</code> <code>str | None</code> <p>The name of the sheet to write to</p> <code>None</code> <code>overwrite</code> <code>bool</code> <p>Whether to overwrite existing data</p> <code>True</code> <p>Raises:</p> Type Description <code>IOError</code> <p>If there's an error writing the data</p> Source code in <code>src/pytanis/storage/base.py</code> <pre><code>@abstractmethod\ndef write_sheet(\n    self, spreadsheet_id: str, data: pd.DataFrame, sheet_name: str | None = None, *, overwrite: bool = True\n) -&gt; None:\n    \"\"\"Write a pandas DataFrame to a sheet\n\n    Args:\n        spreadsheet_id: The identifier for the spreadsheet\n        data: The DataFrame to write\n        sheet_name: The name of the sheet to write to\n        overwrite: Whether to overwrite existing data\n\n    Raises:\n        IOError: If there's an error writing the data\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/pytanis/storage/base/#pytanis.storage.base.BaseStorageClient","title":"<code>BaseStorageClient</code>","text":"<p>Abstract base class for storage clients</p> <p>This class defines the interface for reading and writing data to various storage backends (e.g., local files, cloud storage, databases).</p>"},{"location":"reference/pytanis/storage/base/#pytanis.storage.base.BaseStorageClient.delete","title":"<code>delete(key: str) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Delete data from storage</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The storage key/path to delete</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the key does not exist</p> <code>IOError</code> <p>If there's an error deleting the data</p> Source code in <code>src/pytanis/storage/base.py</code> <pre><code>@abstractmethod\ndef delete(self, key: str) -&gt; None:\n    \"\"\"Delete data from storage\n\n    Args:\n        key: The storage key/path to delete\n\n    Raises:\n        KeyError: If the key does not exist\n        IOError: If there's an error deleting the data\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/pytanis/storage/base/#pytanis.storage.base.BaseStorageClient.exists","title":"<code>exists(key: str) -&gt; bool</code>  <code>abstractmethod</code>","text":"<p>Check if a key exists in storage</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The storage key/path to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the key exists, False otherwise</p> Source code in <code>src/pytanis/storage/base.py</code> <pre><code>@abstractmethod\ndef exists(self, key: str) -&gt; bool:\n    \"\"\"Check if a key exists in storage\n\n    Args:\n        key: The storage key/path to check\n\n    Returns:\n        True if the key exists, False otherwise\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/pytanis/storage/base/#pytanis.storage.base.BaseStorageClient.list_keys","title":"<code>list_keys(prefix: str = '') -&gt; list[str]</code>  <code>abstractmethod</code>","text":"<p>List all keys in storage with optional prefix filtering</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>Optional prefix to filter keys</p> <code>''</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of keys matching the prefix</p> Source code in <code>src/pytanis/storage/base.py</code> <pre><code>@abstractmethod\ndef list_keys(self, prefix: str = '') -&gt; list[str]:\n    \"\"\"List all keys in storage with optional prefix filtering\n\n    Args:\n        prefix: Optional prefix to filter keys\n\n    Returns:\n        List of keys matching the prefix\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/pytanis/storage/base/#pytanis.storage.base.BaseStorageClient.read","title":"<code>read(key: str) -&gt; Any</code>  <code>abstractmethod</code>","text":"<p>Read data from storage</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The storage key/path to read from</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The data stored at the given key</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the key does not exist</p> <code>IOError</code> <p>If there's an error reading the data</p> Source code in <code>src/pytanis/storage/base.py</code> <pre><code>@abstractmethod\ndef read(self, key: str) -&gt; Any:\n    \"\"\"Read data from storage\n\n    Args:\n        key: The storage key/path to read from\n\n    Returns:\n        The data stored at the given key\n\n    Raises:\n        KeyError: If the key does not exist\n        IOError: If there's an error reading the data\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/pytanis/storage/base/#pytanis.storage.base.BaseStorageClient.write","title":"<code>write(key: str, data: Any) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Write data to storage</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The storage key/path to write to</p> required <code>data</code> <code>Any</code> <p>The data to store</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If there's an error writing the data</p> Source code in <code>src/pytanis/storage/base.py</code> <pre><code>@abstractmethod\ndef write(self, key: str, data: Any) -&gt; None:\n    \"\"\"Write data to storage\n\n    Args:\n        key: The storage key/path to write to\n        data: The data to store\n\n    Raises:\n        IOError: If there's an error writing the data\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/pytanis/storage/google/","title":"Google","text":""},{"location":"reference/pytanis/storage/google/#pytanis.storage.google","title":"<code>google</code>","text":"<p>Google Sheets storage implementation</p>"},{"location":"reference/pytanis/storage/google/#pytanis.storage.google.GoogleSheetsStorageClient","title":"<code>GoogleSheetsStorageClient(config: Any = None)</code>","text":"<p>Google Sheets storage adapter implementing the storage interface</p> <p>This class wraps the existing GSheetsClient to provide a consistent interface with other storage backends.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Any</code> <p>Configuration object (if None, will use get_cfg())</p> <code>None</code> Source code in <code>src/pytanis/storage/google.py</code> <pre><code>def __init__(self, config: Any = None):\n    \"\"\"Initialize the Google Sheets storage client\n\n    Args:\n        config: Configuration object (if None, will use get_cfg())\n    \"\"\"\n    # Lazy import to avoid dependency issues\n    try:\n        from pytanis.google import GSheetsClient\n    except ImportError as e:\n        raise ImportError(\n            'Google Sheets dependencies not installed. Install with: pip install pytanis[google]'\n        ) from e\n\n    self._client = GSheetsClient(config=config)\n</code></pre>"},{"location":"reference/pytanis/storage/google/#pytanis.storage.google.GoogleSheetsStorageClient.create_spreadsheet","title":"<code>create_spreadsheet(name: str) -&gt; str</code>","text":"<p>Create a new spreadsheet</p> Source code in <code>src/pytanis/storage/google.py</code> <pre><code>def create_spreadsheet(self, name: str) -&gt; str:\n    \"\"\"Create a new spreadsheet\"\"\"\n    try:\n        # Use the gspread client directly\n        spreadsheet = self._client.gc.create(name)\n        return spreadsheet.id\n    except Exception as e:\n        raise OSError(f'Error creating spreadsheet: {e}') from e\n</code></pre>"},{"location":"reference/pytanis/storage/google/#pytanis.storage.google.GoogleSheetsStorageClient.delete_sheet","title":"<code>delete_sheet(spreadsheet_id: str, sheet_name: str) -&gt; None</code>","text":"<p>Delete a sheet from a spreadsheet</p> Source code in <code>src/pytanis/storage/google.py</code> <pre><code>def delete_sheet(self, spreadsheet_id: str, sheet_name: str) -&gt; None:\n    \"\"\"Delete a sheet from a spreadsheet\"\"\"\n    try:\n        spreadsheet = self._client.gc.open_by_key(spreadsheet_id)\n        worksheet = spreadsheet.worksheet(sheet_name)\n        spreadsheet.del_worksheet(worksheet)\n    except Exception as e:\n        if 'not found' in str(e).lower():\n            raise KeyError(f'Sheet not found: {sheet_name}') from e\n        raise OSError(f'Error deleting sheet: {e}') from e\n</code></pre>"},{"location":"reference/pytanis/storage/google/#pytanis.storage.google.GoogleSheetsStorageClient.list_sheets","title":"<code>list_sheets(spreadsheet_id: str) -&gt; list[str]</code>","text":"<p>List all sheets in a spreadsheet</p> Source code in <code>src/pytanis/storage/google.py</code> <pre><code>def list_sheets(self, spreadsheet_id: str) -&gt; list[str]:\n    \"\"\"List all sheets in a spreadsheet\"\"\"\n    try:\n        spreadsheet = self._client.gc.open_by_key(spreadsheet_id)\n        return [ws.title for ws in spreadsheet.worksheets()]\n    except Exception as e:\n        if 'not found' in str(e).lower():\n            raise KeyError(f'Spreadsheet not found: {spreadsheet_id}') from e\n        raise OSError(f'Error listing sheets: {e}') from e\n</code></pre>"},{"location":"reference/pytanis/storage/google/#pytanis.storage.google.GoogleSheetsStorageClient.read_sheet","title":"<code>read_sheet(spreadsheet_id: str, sheet_name: str | None = None) -&gt; pd.DataFrame</code>","text":"<p>Read a sheet as a pandas DataFrame</p> Source code in <code>src/pytanis/storage/google.py</code> <pre><code>def read_sheet(self, spreadsheet_id: str, sheet_name: str | None = None) -&gt; pd.DataFrame:\n    \"\"\"Read a sheet as a pandas DataFrame\"\"\"\n    try:\n        sheet_name = sheet_name or 'Sheet1'\n        return self._client.gsheet_as_df(spreadsheet_id, sheet_name)\n    except Exception as e:\n        if 'not found' in str(e).lower():\n            raise KeyError(f'Spreadsheet or sheet not found: {spreadsheet_id}/{sheet_name}') from e\n        raise OSError(f'Error reading sheet: {e}') from e\n</code></pre>"},{"location":"reference/pytanis/storage/google/#pytanis.storage.google.GoogleSheetsStorageClient.write_sheet","title":"<code>write_sheet(spreadsheet_id: str, data: pd.DataFrame, sheet_name: str | None = None, *, overwrite: bool = True) -&gt; None</code>","text":"<p>Write a pandas DataFrame to a sheet</p> Source code in <code>src/pytanis/storage/google.py</code> <pre><code>def write_sheet(\n    self, spreadsheet_id: str, data: pd.DataFrame, sheet_name: str | None = None, *, overwrite: bool = True\n) -&gt; None:\n    \"\"\"Write a pandas DataFrame to a sheet\"\"\"\n    try:\n        sheet_name = sheet_name or 'Sheet1'\n        self._client.save_df_as_gsheet(data, spreadsheet_id, sheet_name, create_ws=True)\n    except Exception as e:\n        raise OSError(f'Error writing sheet: {e}') from e\n</code></pre>"},{"location":"reference/pytanis/storage/local/","title":"Local","text":""},{"location":"reference/pytanis/storage/local/#pytanis.storage.local","title":"<code>local</code>","text":"<p>Local file storage implementation</p>"},{"location":"reference/pytanis/storage/local/#pytanis.storage.local.LocalFileClient","title":"<code>LocalFileClient(base_path: Path | str = '.')</code>","text":"<p>Local file storage client supporting various formats</p> <p>This client stores data as local files and supports: - JSON files for general data storage - CSV/Excel files for spreadsheet-like data</p> <p>Parameters:</p> Name Type Description Default <code>base_path</code> <code>Path | str</code> <p>Base directory for storing files</p> <code>'.'</code> Source code in <code>src/pytanis/storage/local.py</code> <pre><code>def __init__(self, base_path: Path | str = '.'):\n    \"\"\"Initialize the local file client\n\n    Args:\n        base_path: Base directory for storing files\n    \"\"\"\n    self.base_path = Path(base_path)\n    self.base_path.mkdir(parents=True, exist_ok=True)\n</code></pre>"},{"location":"reference/pytanis/storage/local/#pytanis.storage.local.LocalFileClient.base_path","title":"<code>base_path = Path(base_path)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/storage/local/#pytanis.storage.local.LocalFileClient.create_spreadsheet","title":"<code>create_spreadsheet(name: str) -&gt; str</code>","text":"<p>Create a new empty spreadsheet</p> Source code in <code>src/pytanis/storage/local.py</code> <pre><code>def create_spreadsheet(self, name: str) -&gt; str:\n    \"\"\"Create a new empty spreadsheet\"\"\"\n    if not name.endswith(('.xlsx', '.csv')):\n        name = f'{name}.xlsx'\n\n    path = self._get_path(name)\n    if path.exists():\n        raise OSError(f'Spreadsheet already exists: {name}')\n\n    # Create empty file\n    if path.suffix == '.csv':\n        pd.DataFrame().to_csv(path, index=False)\n    else:\n        with pd.ExcelWriter(path, mode='w') as writer:\n            pd.DataFrame().to_excel(writer, sheet_name='Sheet1', index=False)\n\n    return name\n</code></pre>"},{"location":"reference/pytanis/storage/local/#pytanis.storage.local.LocalFileClient.delete","title":"<code>delete(key: str) -&gt; None</code>","text":"<p>Delete a file</p> Source code in <code>src/pytanis/storage/local.py</code> <pre><code>def delete(self, key: str) -&gt; None:\n    \"\"\"Delete a file\"\"\"\n    path = self._get_path(key)\n    if not path.exists():\n        raise KeyError(f'File not found: {key}')\n\n    try:\n        path.unlink()\n    except Exception as e:\n        raise OSError(f'Error deleting file {key}: {e}') from e\n</code></pre>"},{"location":"reference/pytanis/storage/local/#pytanis.storage.local.LocalFileClient.delete_sheet","title":"<code>delete_sheet(spreadsheet_id: str, sheet_name: str) -&gt; None</code>","text":"<p>Delete a sheet from a spreadsheet</p> Source code in <code>src/pytanis/storage/local.py</code> <pre><code>def delete_sheet(self, spreadsheet_id: str, sheet_name: str) -&gt; None:\n    \"\"\"Delete a sheet from a spreadsheet\"\"\"\n    path = self._get_spreadsheet_path(spreadsheet_id)\n\n    if not path.exists():\n        raise KeyError(f'Spreadsheet not found: {spreadsheet_id}')\n\n    if path.suffix == '.csv':\n        raise OSError('Cannot delete sheets from CSV files')\n\n    try:\n        # Read all sheets except the one to delete\n        excel_file = pd.ExcelFile(path)\n        sheets_to_keep = {\n            name: pd.read_excel(excel_file, sheet_name=name)\n            for name in excel_file.sheet_names\n            if name != sheet_name\n        }\n\n        if sheet_name not in excel_file.sheet_names:\n            raise KeyError(f'Sheet not found: {sheet_name}')\n\n        if not sheets_to_keep:\n            raise OSError('Cannot delete the last sheet in a spreadsheet')\n\n        # Write back remaining sheets\n        with pd.ExcelWriter(path, mode='w') as writer:\n            for name, df in sheets_to_keep.items():\n                df.to_excel(writer, sheet_name=str(name), index=False)\n\n    except Exception as e:\n        if isinstance(e, KeyError | OSError):\n            raise\n        raise OSError(f'Error deleting sheet {sheet_name} from {spreadsheet_id}: {e}') from e\n</code></pre>"},{"location":"reference/pytanis/storage/local/#pytanis.storage.local.LocalFileClient.exists","title":"<code>exists(key: str) -&gt; bool</code>","text":"<p>Check if a file exists</p> Source code in <code>src/pytanis/storage/local.py</code> <pre><code>def exists(self, key: str) -&gt; bool:\n    \"\"\"Check if a file exists\"\"\"\n    return self._get_path(key).exists()\n</code></pre>"},{"location":"reference/pytanis/storage/local/#pytanis.storage.local.LocalFileClient.list_keys","title":"<code>list_keys(prefix: str = '') -&gt; list[str]</code>","text":"<p>List all files with optional prefix filtering</p> Source code in <code>src/pytanis/storage/local.py</code> <pre><code>def list_keys(self, prefix: str = '') -&gt; list[str]:\n    \"\"\"List all files with optional prefix filtering\"\"\"\n    pattern = f'{prefix}*' if prefix else '*'\n    paths = self.base_path.rglob(pattern)\n    return [str(p.relative_to(self.base_path)) for p in paths if p.is_file()]\n</code></pre>"},{"location":"reference/pytanis/storage/local/#pytanis.storage.local.LocalFileClient.list_sheets","title":"<code>list_sheets(spreadsheet_id: str) -&gt; list[str]</code>","text":"<p>List all sheets in a spreadsheet</p> Source code in <code>src/pytanis/storage/local.py</code> <pre><code>def list_sheets(self, spreadsheet_id: str) -&gt; list[str]:\n    \"\"\"List all sheets in a spreadsheet\"\"\"\n    path = self._get_spreadsheet_path(spreadsheet_id)\n\n    if not path.exists():\n        raise KeyError(f'Spreadsheet not found: {spreadsheet_id}')\n\n    if path.suffix == '.csv':\n        return ['default']  # CSV files don't have multiple sheets\n\n    try:\n        # For Excel files, read sheet names\n        excel_file = pd.ExcelFile(path)\n        # Convert all sheet names to strings\n        return [str(name) for name in excel_file.sheet_names]\n    except Exception as e:\n        raise OSError(f'Error listing sheets in {spreadsheet_id}: {e}') from e\n</code></pre>"},{"location":"reference/pytanis/storage/local/#pytanis.storage.local.LocalFileClient.read","title":"<code>read(key: str) -&gt; Any</code>","text":"<p>Read data from a JSON file</p> Source code in <code>src/pytanis/storage/local.py</code> <pre><code>def read(self, key: str) -&gt; Any:\n    \"\"\"Read data from a JSON file\"\"\"\n    path = self._get_path(key)\n    if not path.exists():\n        raise KeyError(f'File not found: {key}')\n\n    try:\n        with open(path, encoding='utf-8') as f:\n            return json.load(f)\n    except Exception as e:\n        raise OSError(f'Error reading file {key}: {e}') from e\n</code></pre>"},{"location":"reference/pytanis/storage/local/#pytanis.storage.local.LocalFileClient.read_sheet","title":"<code>read_sheet(spreadsheet_id: str, sheet_name: str | None = None) -&gt; pd.DataFrame</code>","text":"<p>Read a sheet from a CSV or Excel file</p> Source code in <code>src/pytanis/storage/local.py</code> <pre><code>def read_sheet(self, spreadsheet_id: str, sheet_name: str | None = None) -&gt; pd.DataFrame:\n    \"\"\"Read a sheet from a CSV or Excel file\"\"\"\n    path = self._get_spreadsheet_path(spreadsheet_id)\n\n    if not path.exists():\n        raise KeyError(f'Spreadsheet not found: {spreadsheet_id}')\n\n    try:\n        if path.suffix == '.csv':\n            if sheet_name is not None:\n                _logger.warning('Sheet name ignored for CSV files', sheet_name=sheet_name)\n            return pd.read_csv(path)\n        else:  # Excel\n            # Always specify sheet_name to ensure we get a DataFrame, not a dict\n            sheet_to_read: str | int = sheet_name if sheet_name is not None else 0\n            return pd.read_excel(path, sheet_name=sheet_to_read)\n    except Exception as e:\n        raise OSError(f'Error reading spreadsheet {spreadsheet_id}: {e}') from e\n</code></pre>"},{"location":"reference/pytanis/storage/local/#pytanis.storage.local.LocalFileClient.write","title":"<code>write(key: str, data: Any) -&gt; None</code>","text":"<p>Write data to a JSON file</p> Source code in <code>src/pytanis/storage/local.py</code> <pre><code>def write(self, key: str, data: Any) -&gt; None:\n    \"\"\"Write data to a JSON file\"\"\"\n    path = self._get_path(key)\n    try:\n        with open(path, 'w', encoding='utf-8') as f:\n            json.dump(data, f, indent=2, default=str)\n    except Exception as e:\n        raise OSError(f'Error writing file {key}: {e}') from e\n</code></pre>"},{"location":"reference/pytanis/storage/local/#pytanis.storage.local.LocalFileClient.write_sheet","title":"<code>write_sheet(spreadsheet_id: str, data: pd.DataFrame, sheet_name: str | None = None, *, overwrite: bool = True) -&gt; None</code>","text":"<p>Write a DataFrame to a CSV or Excel file</p> Source code in <code>src/pytanis/storage/local.py</code> <pre><code>def write_sheet(\n    self, spreadsheet_id: str, data: pd.DataFrame, sheet_name: str | None = None, *, overwrite: bool = True\n) -&gt; None:\n    \"\"\"Write a DataFrame to a CSV or Excel file\"\"\"\n    path = self._get_spreadsheet_path(spreadsheet_id)\n\n    try:\n        if path.suffix == '.csv':\n            if sheet_name is not None:\n                _logger.warning('Sheet name ignored for CSV files', sheet_name=sheet_name)\n            data.to_csv(path, index=False)\n        elif path.exists() and not overwrite:\n            # Append to existing Excel file\n            with pd.ExcelWriter(path, mode='a', if_sheet_exists='replace') as writer:\n                data.to_excel(writer, sheet_name=sheet_name or 'Sheet1', index=False)\n        else:\n            # Create new or overwrite\n            with pd.ExcelWriter(path, mode='w') as writer:\n                data.to_excel(writer, sheet_name=sheet_name or 'Sheet1', index=False)\n    except Exception as e:\n        raise OSError(f'Error writing spreadsheet {spreadsheet_id}: {e}') from e\n</code></pre>"},{"location":"releases/","title":"Release Notes","text":"<p>This section contains detailed release notes for each version of Pytanis.</p>"},{"location":"releases/#current-release-candidate","title":"Current Release Candidate","text":"<ul> <li>v0.9.0rc - First release compatible with Pretalx versioned API v1</li> </ul>"},{"location":"releases/#previous-releases","title":"Previous Releases","text":"<ul> <li>v0.9.0alpha - Alpha release with storage abstraction</li> <li>v0.8.2 - Added Mailgun support</li> </ul>"},{"location":"releases/#migration-guides","title":"Migration Guides","text":"<ul> <li>Migration Guide - Guide for migrating from v0.8.x to v0.9.x</li> </ul> <p>For a complete list of all changes, see the Changelog.</p>"},{"location":"releases/migration_summary/","title":"Migration Summary: Making HelpDesk and Google Sheets Optional","text":""},{"location":"releases/migration_summary/#what-was-done","title":"What Was Done","text":""},{"location":"releases/migration_summary/#1-storage-abstraction-layer","title":"1. Storage Abstraction Layer","text":"<ul> <li>Created <code>src/pytanis/storage/</code> with abstract base classes</li> <li>Implemented <code>LocalFileClient</code> for CSV/Excel file storage</li> <li>Created <code>GoogleSheetsStorageClient</code> adapter for existing functionality</li> <li>All storage providers implement the same interface</li> </ul>"},{"location":"releases/migration_summary/#2-communication-abstraction-layer","title":"2. Communication Abstraction Layer","text":"<ul> <li>Created <code>src/pytanis/communication/</code> with abstract base classes</li> <li>Created adapters for existing Mailgun and HelpDesk clients</li> <li>Defined standard <code>EmailMessage</code> and <code>Ticket</code> data classes</li> </ul>"},{"location":"releases/migration_summary/#3-optional-dependencies","title":"3. Optional Dependencies","text":"<ul> <li>Updated <code>pyproject.toml</code> to move dependencies to extras:</li> <li><code>pytanis[google]</code> - Google Sheets support</li> <li><code>pytanis[helpdesk]</code> - HelpDesk support</li> <li><code>pytanis[mailgun]</code> - Mailgun support</li> <li><code>pytanis[jupyter]</code> - Jupyter notebooks</li> <li><code>pytanis[optimization]</code> - Schedule optimization</li> <li><code>pytanis[all]</code> - Everything</li> </ul>"},{"location":"releases/migration_summary/#4-configuration-updates","title":"4. Configuration Updates","text":"<ul> <li>Made Google, HelpDesk, and Mailgun sections optional in Config</li> <li>Added new Storage and Communication configuration sections</li> <li>Backward compatible - old configs still work</li> </ul>"},{"location":"releases/migration_summary/#5-lazy-loading","title":"5. Lazy Loading","text":"<ul> <li><code>GSheetsClient</code> and <code>HelpDeskClient</code> are now lazy-loaded</li> <li>Clear error messages when dependencies are missing</li> <li>Maintains backward compatibility</li> </ul>"},{"location":"releases/migration_summary/#6-factory-functions","title":"6. Factory Functions","text":"<ul> <li><code>get_storage_client()</code> - Returns appropriate storage backend</li> <li><code>get_mail_client()</code> - Returns appropriate email client</li> <li><code>get_ticket_client()</code> - Returns appropriate ticket client</li> </ul>"},{"location":"releases/migration_summary/#benefits","title":"Benefits","text":"<ol> <li>Reduced Dependencies: Core installation is much lighter</li> <li>Flexibility: Easy to switch between storage/communication providers</li> <li>Testing: Can use local storage for tests instead of Google Sheets</li> <li>Extensibility: Easy to add new providers</li> <li>Backward Compatible: Existing code continues to work</li> </ol>"},{"location":"releases/migration_summary/#migration-path","title":"Migration Path","text":"<p>For existing users: <pre><code># If using all features\npip install pytanis[all]\n\n# Or only what you need\npip install pytanis[google,mailgun]\n</code></pre></p> <p>New code can use the abstraction: <pre><code>from pytanis import get_storage_client\n\nstorage = get_storage_client()  # Uses config to determine provider\ndf = storage.read_sheet('data', 'Sheet1')\n</code></pre></p> <p>Old code still works: <pre><code>from pytanis import GSheetsClient  # Still works if pytanis[google] installed\nclient = GSheetsClient()\n</code></pre></p>"},{"location":"releases/v0.9.0alpha/","title":"Release Instructions for v0.9.0alpha","text":""},{"location":"releases/v0.9.0alpha/#summary-of-changes-since-v081","title":"Summary of Changes Since v0.8.1","text":"<p>This is an alpha release that includes significant improvements to the Pretalx API client:</p> <ol> <li>Backward Compatibility Layer: Transparent handling of Pretalx API changes</li> <li>Cache Optimization: 50-75x performance improvement for bulk operations</li> <li>Integration Testing: Comprehensive test suite for API validation</li> <li>Storage Abstraction: Flexible storage backend support (from 0.8.0)</li> </ol>"},{"location":"releases/v0.9.0alpha/#recent-commits-in-this-branch","title":"Recent Commits (in this branch)","text":"<pre><code>66557d5 fix: remove CLAUDE.md that should not be committed\ne4547f5 docs: update documentation for testing and API changes\nb316944 build: add integration test scripts and update dependencies\n8f832bb fix(storage): remove circular import in Google storage adapter\ne3e97e8 test: update tests for API changes and backward compatibility\nb50dff8 test(pretalx): add comprehensive integration testing framework\n431e904 feat(pretalx): add cache optimization for backward compatibility\n5ce5cd0 feat(pretalx): add backward compatibility layer for new API changes\n</code></pre>"},{"location":"releases/v0.9.0alpha/#pre-release-checklist","title":"Pre-release Checklist","text":"<ul> <li> All tests passing: <code>hatch run cov</code></li> <li> Integration tests validated: <code>hatch run integration</code></li> <li> Documentation updated</li> <li> CHANGELOG.md updated with v0.9.0alpha changes</li> <li> No sensitive information in commits</li> </ul>"},{"location":"releases/v0.9.0alpha/#release-commands","title":"Release Commands","text":"<pre><code># 1. Ensure you're on the main branch with all changes merged\ngit checkout main\ngit pull origin main\ngit merge pretalx_api_update_ah\n\n# 2. Run final tests\nhatch run cov\nhatch run lint:all\n\n# 3. Update CHANGELOG.md with the v0.9.0alpha section\n\n# 4. Commit the changelog\ngit add CHANGELOG.md\ngit commit -m \"docs: update CHANGELOG for v0.9.0alpha release\"\n\n# 5. Create and push the tag\ngit tag -a v0.9.0alpha -m \"Release v0.9.0alpha: Pretalx API compatibility and performance improvements\"\ngit push origin main\ngit push origin v0.9.0alpha\n\n# 6. Create GitHub release\n# - Go to https://github.com/PyCon-DE/pytanis/releases/new\n# - Select the v0.9.0alpha tag\n# - Check \"Set as a pre-release\"\n# - Use the CHANGELOG content for the release notes\n# - Publish the release\n\n# 7. Build and publish to PyPI (if you have permissions)\nhatch build\nhatch publish\n</code></pre>"},{"location":"releases/v0.9.0alpha/#post-release","title":"Post-release","text":"<ul> <li> Verify the package on PyPI</li> <li> Update any dependent projects</li> <li> Announce the release</li> </ul>"},{"location":"releases/v0.9.0rc/","title":"Release Notes for Pytanis v0.9.0rc","text":""},{"location":"releases/v0.9.0rc/#first-release-compatible-with-pretalx-versioned-api-v1","title":"\ud83c\udf89 First Release Compatible with Pretalx Versioned API v1","text":"<p>We're excited to announce the release candidate for Pytanis v0.9.0! This is the first version fully compatible with the new Pretalx versioned API v1, introduced in June 2025.</p>"},{"location":"releases/v0.9.0rc/#major-highlights","title":"Major Highlights","text":""},{"location":"releases/v0.9.0rc/#1-pretalx-api-v1-full-compatibility","title":"1. Pretalx API v1 Full Compatibility","text":"<ul> <li>Complete support for the new versioned API with proper <code>expand</code> parameter usage</li> <li>Automatic handling of API changes where nested objects were replaced with IDs</li> <li>Seamless backward compatibility for existing code</li> </ul>"},{"location":"releases/v0.9.0rc/#2-storage-communication-abstraction","title":"2. Storage &amp; Communication Abstraction","text":"<ul> <li>New abstraction layers for storage (local files, Google Sheets) and communication (email, tickets)</li> <li>Optional dependencies - install only what you need:   <pre><code>pip install pytanis[google]     # For Google Sheets\npip install pytanis[mailgun]    # For Mailgun\npip install pytanis[helpdesk]   # For HelpDesk\n</code></pre></li> </ul>"},{"location":"releases/v0.9.0rc/#3-performance-improvements","title":"3. Performance Improvements","text":"<ul> <li>50-75x performance boost for bulk operations through intelligent cache pre-population</li> <li>Reduced API calls when fetching submissions with speakers and metadata</li> </ul>"},{"location":"releases/v0.9.0rc/#4-enhanced-testing-framework","title":"4. Enhanced Testing Framework","text":"<ul> <li>New interactive integration test runner</li> <li>Structured logging with colored output for better visibility</li> <li>Comprehensive endpoint validation</li> </ul>"},{"location":"releases/v0.9.0rc/#breaking-changes","title":"Breaking Changes","text":"<p>None! This release maintains full backward compatibility while adding new features.</p>"},{"location":"releases/v0.9.0rc/#migration-guide","title":"Migration Guide","text":""},{"location":"releases/v0.9.0rc/#for-existing-users","title":"For Existing Users","text":"<p>Your code will continue to work without changes. To take advantage of new features:</p> <ol> <li> <p>Update to use optional dependencies:    <pre><code># Instead of installing everything\npip install pytanis\n\n# Install only what you need\npip install pytanis[google,mailgun]\n</code></pre></p> </li> <li> <p>Use the new abstraction layer (optional):    <pre><code># Old way (still works)\nfrom pytanis import GSheetsClient\nclient = GSheetsClient()\n\n# New way (recommended)\nfrom pytanis import get_storage_client\nstorage = get_storage_client()\n</code></pre></p> </li> </ol>"},{"location":"releases/v0.9.0rc/#for-new-users","title":"For New Users","text":"<p>Start with the minimal installation and add components as needed: <pre><code>pip install pytanis  # Core functionality\npip install pytanis[all]  # Everything\n</code></pre></p>"},{"location":"releases/v0.9.0rc/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Fixed 401 Unauthorized errors when fetching individual answers</li> <li>Fixed redirect issues with missing trailing slashes</li> <li>Fixed circular import issues in Google storage adapter</li> </ul>"},{"location":"releases/v0.9.0rc/#whats-next","title":"What's Next","text":"<p>This is a release candidate. Please test it with your workflows and report any issues. The final v0.9.0 release is planned for early July 2025.</p>"},{"location":"releases/v0.9.0rc/#installation","title":"Installation","text":"<pre><code>pip install pytanis==0.9.0rc\n</code></pre>"},{"location":"releases/v0.9.0rc/#acknowledgments","title":"Acknowledgments","text":"<p>Thanks to all contributors who made this release possible, especially for the feedback on API compatibility issues and testing.</p>"},{"location":"releases/v0.9.0rc/#links","title":"Links","text":"<ul> <li>Documentation</li> <li>GitHub Repository</li> <li>Issue Tracker</li> </ul>"},{"location":"tasks/cfp/","title":"The Call for Participation Process","text":""},{"location":"tasks/cfp/#overview","title":"Overview","text":"<p>The organisation of your conference programme starts with the Call for Participation/Proposals (CfP). Before you announce your CfP, obvious things to consider are:</p> <ul> <li>what is the audience we are trying to address? Beginners, experts, ... also first-time speakers, diverse &amp; underrepresented groups.</li> <li>what information do wee need to know about our speakers? Name, country, biography, affiliation, job &amp; position, social media, on-site availability, ...</li> <li>what are the topics of interest for our conference? How are those tracks named? E.g. PyCon: Libraries, PyData: Machine Learning &amp; Stats, ...</li> <li>what is the presentation format, i.e. session types? 30min, 45min talks (including 5min Q&amp;A), 90min tutorials...</li> <li>should a financial aid program be offered? Check out the Financial Aid Programme of PyconDE / PyData 2023 Berlin for an example.</li> <li>what are the rough milestones/deadlines of the whole process? See below for an example.</li> <li>what is the deadline of the CfP? Do we want to extend it later on? Do we have enough time for the reviews?</li> </ul> <p>An example CfP can be found on the Call for Proposals of the PyConDE / PyData 2023 Berlin. The actual CfP submission is handled easily by Pretalx as you can just fill out everything in the web UI. As these tasks are all purely organisational/conceptional, there is no need to use Pytanis for any of this.</p>"},{"location":"tasks/cfp/#example-milestones-of-pyconde-pydata-2023-berlin","title":"Example: Milestones of PyConDE / PyData 2023 Berlin","text":"<ul> <li>2022-12-11: (Sunday) CfP opens</li> <li>2022-12-14: Financial Aid Program opens</li> <li>2023-01-05: (Thursday) -&gt; Extension 2023-01-09 (Monday) CfP closes. [Voting can be prepared beforehand via Pretalx.]</li> <li>2023-01-06: (Friday) Open the Review for external Reviewers</li> <li>2023-01-11: Q&amp;A session 1 for external reviewers, 30min at 5pm</li> <li>2023-01-17: Q&amp;A session 2 for external reviewers, 30min at 5pm</li> <li>2022-01-16: Financial Aid Program closes (2 weeks to select)</li> <li>2023-01-16: Ticket sales opens</li> <li>2023-01-16: (Monday) till 2023-01-23 (Sunday) talk voting over Pretalx (1 week)</li> <li>2023-01-31: (Tuesday) deadline for external &amp; internal reviewers</li> <li>2023-02-13: (Monday) acceptance notices to speakers</li> <li>2023-02-14: (Tuesday) publish list of accepted talks</li> <li>2023-02-20: Financial Aid applicants will be notified by e-mail about acceptance or rejection</li> <li>2023-03-01: (Wednesday) publish talk schedule via Pretalx</li> <li>2022-03-07: Ticket prices increase to switch to late bird pricing</li> <li>2023-04-16: Set-up-day, the night before the conference \ud83c\udf89</li> <li>2023-04-17: (Monday) conference starts, we have a lift-off \ud83d\ude80</li> </ul> <p>Warning</p> <p>Obviously, you should never announce a CfP extension before the deadline of the original CfP is over \ud83d\ude1c. It is also useful to keep some of the above deadlines internally to avoid receiving a lot of emails when you have missed the deadline \ud83d\ude48.</p>"},{"location":"tasks/review/","title":"The Review Process","text":""},{"location":"tasks/review/#overview","title":"Overview","text":"<p>On a high-level, the review process of the proposals for a conference works as follows:</p> <ol> <li>find external reviewers and learn about their preferences,</li> <li>onboard reviewers in Pretalx,</li> <li>assign proposals to reviewers according to their preferences,</li> <li>communicate with the reviewers occasionally for updates,</li> <li>track the whole process.</li> </ol>"},{"location":"tasks/review/#1-find-external-reviewers-and-learn-about-their-preferences","title":"1. Find External Reviewers and Learn about their Preferences","text":"<p>For the PyConDE / PyData Berlin 2023, we were looking for about 50 external reviewers since we expected about 400 proposals, and we wanted to have 3 reviews per proposal. This would amount to about 25 proposals to review per person, which is manageable within a few weeks if you schedule 5-15 minutes per proposal.</p> <p>To get external reviewers, we decided that would only ask within our (Program Committee members') circle of trust and refer them to Google Forms. The form basically consisted of following questions with descriptions:</p> <ul> <li>Name [short answer]: Please write your name starting with your first name, e.g. Albert Einstein.</li> <li>Affiliation [short answer]: Please state the name or organisation you are affiliated with.</li> <li>Who do you know from the Committee? [short answer]: We believe in the ring of trust model. With this question, we really only   want to make sure that random people are not signing up with no connection to any member of the Program Committee.</li> <li>Availability during the Review Period [checkboxes]: The bulk of the review work will take place from January 5<sup>th</sup> to February   13<sup>th</sup>, 2023, so it is important that you are broadly available during this period. That being said, you will be quite   flexible in managing your time but being on vacation with no internet for 3 weeks might be suboptimal here ;-)   There was only one mandatory checkbox: Yes, I am broadly available during this period.</li> <li>Additional comments regarding your availability during the review period. [long answer]</li> <li>Topics you want to review: These are the topics you are interested in reviewing. The more you select the better.   Don't be shy, you don't have to be an expert in a topic to review a proposal. If you are interested in a topic and   have some knowledge about it, you are totally up for the job :-)   Each track in Pretalx corresponded to one checkbox in this form. At least 5 preferences needed to be chosen.</li> <li>Do you want your name to be listed as a reviewer on the conference website? [checkbox] Mandatory yes/no checkboxes</li> <li>Any additional comments for the Program Committee [long answer]</li> </ul> <p>Tip</p> <ul> <li>Google Form will use the separator <code>,</code> (comma, whitespace) for the selected checkboxes. Having the same separator   in your track name, e.g. \"General: Community, Diversity, Career, Life and everything else\", will make it a bit harder   to parse the resulting Google Sheet. So it's better to avoid them in track names.</li> <li>Depending on how you want to assign proposals to reviewers later, it might also make sense to ask the reviewers if   they only want to be assigned a single batch, or if they are also interested in getting more proposals to review after   their batch is done.</li> </ul> <p>Every submission of the Google Form is then automatically added to a Google Sheet, let's call it the volunteer sheet, which can be easily read with the help of Pytanis. Check out our Google Sheet docs and Pytanis' google module to learn about more functionality.</p>"},{"location":"tasks/review/#2-onboard-reviewers-in-pretalx","title":"2. Onboard Reviewers in Pretalx","text":"<p>In Pretalx select Organisers in the left menu bar (you need Admin-rights for that) and click the teams under your event name. You should see a list of all teams and it's a good idea to have one for all reviewers, e.g. <code>2023-Reviewers-ALL</code>. By clicking on the team name you get to a page that lists the names and corresponding e-mails of team members as well as an option to add new members at the bottom.</p> <p>You can now start typing in the e-mail addresses from the volunteer sheet to send out invitations to them. After volunteers accept the invitation they will show up with a user-name and e-mail in the team table. Now, here comes the tricky part that can cause a lot of confusion. If person A entered in the Google Form the e-mail address <code>work@mail.com</code>, and you added this in Pretalx, it might happen that person A accepts the team invitation with a different Pretalx account that is linked to the e-mail address <code>private@mail.com</code>. In this case, Pretalx will automatically replace <code>work@mail.com</code>, which was used for the invitation, with <code>private@mail.com</code> in the Pretalx table of team members. Unfortunately, Pretalx has no way of automatically tracking this change of mail addresses and this issue, as filed in #1417, is still unresolved.</p> <p>To work around this email issue and to be able to later join your volunteer sheet for instance with reviews, it makes sense to introduce a new column, e.g. \"Pretalx mail\", where you add the actual Pretalx account e-mail that was used by the invited user. Additionally, you should have a column for the Pretalx user-name, e.g. \"Pretalx user\", where you state the user-name by copying it over from the Pretalx team member table. This user-name column will be useful later to join our volunteer reviewers with the reviews they did, because the review-endpoint of Pretalx only returns the user-name, not the e-mail of a reviewer. This problem was also discussed in #1416 and is an intended behaviour.</p>"},{"location":"tasks/review/#3-assign-proposals-to-reviewers-according-to-their-preferences","title":"3. Assign Proposals to Reviewers according to their Preferences","text":"<p>Pretalx already provides a basic assignment feature so that proposals with the least number of reviews will show up earlier in the review queue so that they get more reviews. Additionally, Pretalx allows uploading a mapping JSON file so that you can assign certain proposals to a reviewer matching their preferences with the tracks of the proposals. Also, Pretalx is working on more elaborate automatic assignment features and some discussion about it can be found in issue #1331.</p> <p>Pytanis allows you to create JSON mapping files that can be uploaded in Pretalx under Review \u00bb Assign reviews. Then click Actions (upper right) \u00bb Import assignments and select the option <code>Assign proposals to reviewers</code>, choose the JSON file and make sure to always set <code>Replace current assignments</code> to <code>Yes</code>. Overwriting the current assignments makes sure that the assignment state in Pretalx is always consistent with what you expect. Also, be sure to always back up your assignment files somewhere in case you need to roll back later on. To make this easy, just name your files <code>assignments-YYYYMMDD_I.json</code>, where <code>YYYY</code> is the current year, <code>MM</code> the month, <code>DD</code> the day in the month and <code>I</code> the version increment, e.g. <code>1</code> or <code>2</code>, in case you need several assignments throughout the same day.</p> <p>So how do you create an assignment file using Pytanis? Currently, we have implemented in a notebook an initial simple algorithm that can be easily run. Fancier algorithms will come in the future and don't hesitate to contribute. The main idea of the algorithm is to set a goal of number of reviews for each proposal, e.g. 3 reviews, and a certain buffer, e.g. 1. This means every proposal is assigned to goal number of reviews + buffer - current review number in case the current review number is not already equal or greater than the goal number of reviews. Rerunning this assignment frequently helps to avoid overshooting as the buffer mainly addresses the fact that you will also have inactive reviewers or some that start on the last day before your review deadline. For each proposal and remaining review, the algorithm assigns the proposals to:</p> <ul> <li>not a person having already assigned the review for a proposal (no duplicates),</li> <li>to a person having a preference for the track with the least amount of current work,</li> <li>if no person has a preference for the track of the proposal, assign to someone with not much work.</li> </ul> <p>Be aware that some of your reviewers might have also make proposal submissions. Thus, it might happen by chance that someone gets assigned his/her own proposal using this approach but luckily Pretalx takes care of that--if the same Pretalx account was used.</p> <p>This quite simple algorithm can be found in the notebook 10_reviewer-assignment_v1. It uses Pytanis to pull the submission/proposals as well as the current reviews from Pretalx and joins them to get an overview of the current state of reviews. Then Pytanis is used to get the Google sheet of reviewers and their preferences, which is also joined with the data from Pretalx. Then the aforementioned algorithm is run and the assignment JSON file written.</p>"},{"location":"tasks/review/#4-communicate-with-the-reviewers-occasionally-for-updates","title":"4. Communicate with the Reviewers occasionally for Updates","text":"<p>From time to time, you want to get in contact with your reviewers to remind them of some deadline or just to say thank you for their work. Pytanis has an easy interface to HelpDesk that can be used as an e-mail client. For some practical examples, just check out the notebook 20_mail_to_reviewers_v1, the docs about mailing, as well as the Pytanis' mail references.</p>"},{"location":"tasks/review/#5-track-the-whole-process","title":"5. Track the whole process","text":"<p>During the review process it very important to keep track of review activity to make sure your internal deadlines for the review process are met. For instance, there might be reviewers that are having difficulties but have not reached out yet. So finding inactivate reviewers after a certain period of time and sending a nice supportive e-mail helps a lot. Also, some reviewers might have finished their batch of work early but might be up for more, thus identifying and getting in contact with them, is always a good idea. Many of those analyses are really individual, and you can check our examples in the notebook 10_reviewer-assignment_v1.</p>"},{"location":"tasks/schedule/","title":"Creating the Schedule","text":"<p>After all you talks and tutorials are confirmed, the next major milestone is to create a schedule so that each talk gets a time and place to be presented. Pretalx allows you to create a schedule by dragging &amp; dropping the talk blocks onto a schedule, where you can define the number of days and rooms. You can also specify breaks like lunch or coffee breaks and later on publish the schedule for everyone. So this feature is pretty need but for larger conferences with a lot of parallel sessions, i.e. many rooms, some help might be needed.</p> <p>Assuming that you had some blank schedule before that already defines the time slots with their lengths and when the breaks are, then surely following constraints must be satisfied:</p> <ul> <li>each talk must be assigned to a time slot,</li> <li>each room/time slot combination can only be occupied by one talk at most,</li> <li>the length of the time slot must match the length of the talk,</li> <li>if some talks/tutorials have several parts, e.g. part 1 &amp; 2, they must be consecutive.</li> </ul> <p>Besides those constraints you might want to optimize for several objectives:</p> <ol> <li>the preferences for day and time of the speakers are considered (if they provided some),</li> <li>the more popular a talk is (from the public voting data), the more capacity the assigned room should have,</li> <li>if many people are highly interested in seeing two talks (voting data), these talks should rather not be scheduled in parallel.    Also, sponsored talks should never be in parallel to avoid cannibalization,</li> <li>talks should have same main track, e.g. PyData, if they are in the same session (block of talks in one room),</li> <li>talks should have same sub track, e.g. PyData: Data Handling, if they are in the same session.</li> </ol> <p>The easiest way of dealing with multi-objective optimization is to create one new main objective by weighting and summing all objectives. For the objectives outlined above, it surely makes sense to choose the weights so that the importance is 1 &gt; 2 &gt; 3 &gt; 4 &gt; 5.</p> <p>In the notebook 50_scheduling_v1, you can find an example that uses Mixed-Integer-Programming (MIP) to generate a preliminary schedule that can be used as a starting point before creating the schedule in Pretalx. Although the constraints and objective from above may look quite simple, MIPs are not only hard, they are even NP-hard ;-) The example in the notebook uses Pyomo to formulate the problem and transform it into a standardized form, so that the solver HiGHS can do its job. In the concrete example, even after 24h no perfect solution was found, but the good thing is that the gap between best found feasible solution and the maximum possible objective value, i.e. the gap, was relatively small.</p> <p>Again, to visualize a solution like this, you can push it easily with the help of Pytanis to Google Sheets,  which is illustrated in the figure below.</p> <p>Tip</p> <p>If you want to also specify link previews, sometimes also called a social banners, then check out the notebook 40_talk_image_v1 on how Pytanis can help you to create them.</p>"},{"location":"tasks/selection/","title":"The Selection Process","text":""},{"location":"tasks/selection/#overview","title":"Overview","text":"<p>On a high-level, the selection process involves the following</p> <ol> <li>have an optional public voting for the proposals,</li> <li>decide on how many talks, tutorials in which length, track or skill level you want to have,</li> <li>get an overview of the proposals, the speakers, the reviewer scores, and optionally the vote scores,</li> <li>select in Pretalx which talks are accepted and which ones are not.</li> </ol>"},{"location":"tasks/selection/#1-optional-public-voting","title":"1. Optional Public Voting","text":"<p>The pretalx-public-voting plugin allows to vote for the proposals which is a nice signal if a talk is generally interesting to the audience or not, solely based on the title and abstract. If it is installed activate it in Pretalx under Settings \u00bb Public voting. After the end date of the voting has passed this is also the place where you can download the results as a csv file. Unfortunately, there is currently no API provided by Pretalx for this feature.</p>"},{"location":"tasks/selection/#2-decision-on-number-of-talks-and-rules-for-acceptance","title":"2. Decision on Number of Talks and Rules for Acceptance","text":"<p>Deciding on the rules of acceptance might be one of the hardest parts and no Software can support you with it. It is really important to do this early on since it will help with the actual selection process. In order to decide for instance for the number of talks/tutorials in various lengths, it's important to already have a blank schedule, i.e. just the time slots, at hand. Diversity is also an important topic, so one rule might be to over-represent the under-represented but by how much? And do you expect your audience to be rather advanced, even senior, and what does that mean for ratio of the various required skill levels of the talks? How about the tracks you defined? Are speakers allowed to give more than one talk? How to deal with talks that have been given before? It's best to decide on a few guidelines before you proceed with the next steps.</p>"},{"location":"tasks/selection/#3-overview-of-the-proposals","title":"3. Overview of the proposals","text":"<p>Getting an overview of all proposals, their features, their review score and optionally their public score, is crucial when it comes to make a selection. Luckily with the help of Pytanis this is really easy. You can pull all the data from Pretalx, join it with additional data like the voting scores and push it to a Google Sheet, where everyone can easily view it and add comments. Find a practical example on how Pytanis was used for the PyConDE / PyData 2023 in this notebook 30_selection_v1.</p>"},{"location":"tasks/selection/#4-final-selection-in-pretalx","title":"4. Final Selection in Pretalx","text":"<p>Selecting the talks/tutorials for your conference is an iterative process. Maybe there are some talks you definitely want to select and others so bad you surely want to reject. Then there might be some you want to preliminarily accept or reject. Fortunately, Pretalx allows all that and Pytanis can pull that information to mark the rows in your GSheet with a certain colour. Here is an example on how this might look like.</p> <p>This example is also part of the notebook 30_selection_v1. Also be aware that after you accepted a talk or tutorial the author(s) must confirm. In practice, it happens also that accepted talks are withdrawn, so make sure you always keep a buffer of talks that haven't gotten any feedback yet to be able to accept some more.</p>"},{"location":"usage/confirmed_talks/","title":"Working with Confirmed Talks","text":"<p>Pytanis provides functionality to easily extract confirmed talks from pretalx and convert them to a simplified JSON format that can be used for various purposes like displaying on websites, creating schedules, etc.</p>"},{"location":"usage/confirmed_talks/#basic-usage","title":"Basic Usage","text":"<p>The simplest way to get confirmed talks as JSON is to use the <code>get_confirmed_talks_as_json</code> function:</p> <pre><code>from pytanis import PretalxClient, get_confirmed_talks_as_json\n\n# Initialize the pretalx client\npretalx_client = PretalxClient()\n\n# Fetch all talks with their answers\nevent_slug = \"your-event-slug\"\n_, talks = pretalx_client.talks(event_slug, params={\"questions\": \"all\"})\n\n# Convert to list to materialize the iterator\ntalks_list = list(talks)\n\n# Get JSON string with confirmed talks\n# Pass the pretalx_client and event_slug to fetch speaker data for organisation information\njson_data = get_confirmed_talks_as_json(talks_list, pretalx_client, event_slug)\n\n# Print or use the JSON data\nprint(json_data)\n</code></pre>"},{"location":"usage/confirmed_talks/#saving-to-a-file","title":"Saving to a File","text":"<p>If you want to save the JSON data to a file, you can use the <code>save_confirmed_talks_to_json</code> function:</p> <pre><code>from pytanis import PretalxClient, save_confirmed_talks_to_json\n\n# Initialize the pretalx client\npretalx_client = PretalxClient()\n\n# Fetch all talks with their answers\nevent_slug = \"your-event-slug\"\n_, talks = pretalx_client.talks(event_slug, params={\"questions\": \"all\"})\n\n# Convert to list to materialize the iterator\ntalks_list = list(talks)\n\n# Save confirmed talks to a file\n# Pass the pretalx_client and event_slug to fetch speaker data for organisation information\noutput_file = \"confirmed_talks.json\"\nsave_confirmed_talks_to_json(talks_list, output_file, pretalx_client, event_slug)\n</code></pre>"},{"location":"usage/confirmed_talks/#the-simpletalk-model","title":"The SimpleTalk Model","text":"<p>The JSON output contains a list of <code>SimpleTalk</code> objects with the following structure:</p> <pre><code>[\n  {\n    \"title\": \"Talk Title\",\n    \"speaker\": \"Speaker Name 1, Speaker Name 2\",\n    \"organisation\": \"Company Name\",\n    \"track\": \"Track Name\",\n    \"domain_level\": \"Intermediate\",\n    \"python_level\": \"Advanced\",\n    \"duration\": \"45\",\n    \"abstract\": \"Short abstract of the talk\",\n    \"description\": \"Detailed description of the talk\",\n    \"prerequisites\": \"Required knowledge or tools\"\n  },\n  ...\n]\n</code></pre> <p>The fields are:</p> <ul> <li><code>title</code>: The title of the talk</li> <li><code>speaker</code>: A comma-separated list of speaker names</li> <li><code>organisation</code>: The company or institute of the speakers (if available)</li> <li><code>track</code>: The track name (if available)</li> <li><code>domain_level</code>: The domain expertise level (if available)</li> <li><code>python_level</code>: The Python expertise level (if available)</li> <li><code>duration</code>: The duration of the talk in minutes</li> <li><code>abstract</code>: The abstract of the talk</li> <li><code>description</code>: The detailed description of the talk</li> <li><code>prerequisites</code>: Any prerequisites for the talk (if available)</li> </ul>"},{"location":"usage/confirmed_talks/#using-the-simpletalk-model-directly","title":"Using the SimpleTalk Model Directly","text":"<p>You can also create <code>SimpleTalk</code> objects directly if needed:</p> <pre><code>from pytanis import SimpleTalk\n\ntalk = SimpleTalk(\n    title=\"My Talk\",\n    speaker=\"John Doe\",\n    organisation=\"Acme Inc.\",\n    track=\"Python\",\n    domain_level=\"Intermediate\",\n    python_level=\"Advanced\",\n    duration=\"30\",\n    abstract=\"This is a talk about Python\",\n    description=\"In this talk, we will explore Python features\",\n    prerequisites=\"Basic programming knowledge\"\n)\n\n# Convert to dict\ntalk_dict = talk.model_dump()\n</code></pre>"},{"location":"usage/confirmed_talks/#example-script","title":"Example Script","text":"<p>An example script is provided in the <code>examples</code> directory:</p> <pre><code>python examples/get_confirmed_talks.py your-event-slug output.json\n</code></pre> <p>This script fetches all talks for the specified event, filters for confirmed talks, and saves them to the specified output file.</p>"},{"location":"usage/gsheet/","title":"Google Sheets","text":""},{"location":"usage/gsheet/#basic-usage","title":"Basic Usage","text":"<p>Pytanis' Google Sheet client is really made for simplicity. Retrieving a worksheet of a Google sheet is as simple as: <pre><code>from pytanis import GSheetsClient\n\ngsheets_client = GSheetsClient()\ngsheet_df = gsheets_client.gsheet_as_df(SPREADSHEET_ID, WORKSHEET_NAME)\n</code></pre> where <code>SPREADSHEET_ID</code> is the ID taken from the spreadsheet's url, e.g. the ID is <code>17juVXM7V3p7Fgfi-9WkwPlMAYJB-DuxRhYCi_hastbB</code> if your spreadsheet's url is <code>https://docs.google.com/spreadsheets/d/17juVXM7V3p7Fgfi-9WkwPlMAYJB-DuxRhYCi_hastbB/edit#gid=1289752230</code>, and <code>WORKSHEET_NAME</code> is the name of the actual sheet, e.g. <code>Form responses 1</code>, that you find in the lower bar of your spreadsheet. The function <code>gsheet_as_df</code> returns a simple Pandas dataframe, which most users are surely familiar with.</p> <p>If you run the above script the first time, you will get a link to a Google consent page, or it will directly open up if you run this in a Jupyter notebook. Read it carefully and accept the access to your Google Sheet. This step is only necessary and everytime you change the access scope. For instance, if you also want to have write-access to a worksheet, run: <pre><code>gsheets_client = GSheetsClient(read_only=False)\ngsheets_client.recreate_token()\n</code></pre> and you will see the consent screen again, asking this time for write-access. Having accepted, you can now use <pre><code>gsheets_client.save_df_as_gsheet(subs_df, SPREADSHEET_ID, WORKSHEET_NAME)\n</code></pre> to upload a dataframe as Google sheet, overriding what's currently in there.</p> <p>Tip</p> <p>Google Sheet has a real useful version history that can be found under File \u00bb Version history \u00bb See version history. Even if you have accidentally overwritten you Google Sheet you can also restore an old version.</p>"},{"location":"usage/gsheet/#advanced-usage","title":"Advanced Usage","text":"<p>In case you want even more functionality and a dataframe is just not enough, you can use the <code>gsheet</code> method to get a Worksheet object or Spreadsheet object of GSpread. GSpread gives you full access to the API of Google Sheet and all the <code>gsheet_as_df</code> does is to basically use GSpread-Dataframe to convert this into a Pandas dataframe to simplify things for you. Also check out GSpread-Formatting if you want to use features like conditional formatting, colored cells, etc. Pytanis' google module gives you a complete reference of the current functionality within Pytanis but make sure to check out the GSpread ecosystem too as mentioned above.</p>"},{"location":"usage/installation/","title":"Getting Started","text":""},{"location":"usage/installation/#installation","title":"Installation","text":"<p>To install Pytanis simple run: <pre><code>pip install pytanis\n</code></pre> or to install all recommended additional dependencies: <pre><code>pip install 'pytanis[all]'\n</code></pre> Then create a configuration file and directory in your user's home directory. For Linux/MacOS/Unix use <code>~/.pytanis/config.toml</code> and for Windows <code>$HOME\\.pytanis\\config.toml</code>, where <code>$HOME</code> is e.g. <code>C:\\Users\\yourusername\\</code>. Use your favourite editor to open <code>config.toml</code> within the <code>.pytanis</code> directory and add the following content: <pre><code>[Pretalx]\napi_token = \"932ndsf9uk32nf9sdkn3454532nj32jn\"\napi_version = \"v1\"  # Optional, defaults to \"v1\" if not specified\n\n[Google]\nclient_secret_json = \"client_secret.json\"\ntoken_json = \"token.json\"\n\n[HelpDesk]\naccount = \"934jcjkdf-39df-9df-93kf-934jfhuuij39fd\"\nentity_id = \"email@host.com\"\ntoken = \"dal:Sx4id934C3Y-X934jldjdfjk\"\n</code></pre> where you need to replace the dummy values in the sections <code>[Pretalx]</code> and <code>[HelpDesk]</code> accordingly.</p> <p>Info</p> <p>You have to configure the credentials and tokens only for the sections you actually want to use. For instance, <code>[Pretalx]</code> and <code>[Google]</code> are the most important sections for users that want to interact with Pretalx and also Google Sheets. If for instance no access to HelpDesk is necessary, e.g. no mails need to be sent, you can just leave out the key/value pairs in the <code>[HelpDesk]</code> section.</p>"},{"location":"usage/installation/#retrieving-the-credentials-and-tokens","title":"Retrieving the Credentials and Tokens","text":"<ul> <li>Google: Follow the Python Quickstart for the Google API to generate and download the file <code>client_secret.json</code>. Move it to the <code>~/.pytanis</code> folder as <code>client_secret.json</code>. The file <code>token.json</code> will be automatically generated later. Note that <code>config.toml</code> references those two files relative to its own location.</li> <li>Pretalx: The API token can be found in the Pretalx user settings.</li> <li>HelpDesk: Log into the LiveChat Developer Console then go to Tools \u00bb Personal Access Tokens.   Hit Create new token +, enter a the name <code>Pytanis</code>, select all scopes and confirm. In the following screen   copy the <code>Account ID</code>, <code>Entity ID</code> and <code>Token</code> and paste them into <code>config.toml</code>.   In case there is any trouble with livechat, contact a helpdesk admin.</li> </ul>"},{"location":"usage/installation/#verifying-your-installation","title":"Verifying Your Installation","text":"<p>After installation and configuration, you can verify that everything is working correctly by running the integration tests. See the Testing Guide for detailed instructions on how to validate your setup and test API compatibility.</p>"},{"location":"usage/mail/","title":"Sending Mails","text":""},{"location":"usage/mail/#basic-usage","title":"Basic Usage","text":"<p>The usage of Pytanis' mail functionality is really simple. There are only three steps, you instantiate the mail client, create a mail object with your content and assemble a list of recipients.</p>"},{"location":"usage/mail/#team-agent-id","title":"Team &amp; Agent ID","text":"<p>But before we write an e-mail we have to determine the team and agent id so that the e-mails we send are assigned to the right roles as set up within HelpDesk. In order to do this, we can just do:</p> <p><pre><code>from pytanis import HelpDeskClient\n\nhelpdesk = HelpDeskClient()\n\nprint([agent.ID for agent in helpdesk.list_agents() if \"AGENTS EMAIL\" in agent.email])\nprint([team.ID for team in helpdesk.list_teams() if \"TEAM NAME\" in team.name])\n</code></pre> to find the right IDs with respect to the e-mail address <code>AGENTS EMAIL</code> and the corresponding <code>TEAM NAME</code>. We assume now that you stored those two values in <code>agent_id</code> and <code>team_id</code>, respectively.</p>"},{"location":"usage/mail/#defining-the-recipients","title":"Defining the Recipients","text":"<p>Defining the recipients means that you create a list of Recipient objects like: <pre><code>from pytanis.helpdesk import Recipient\n\nrecipients = [\n    Recipient(name=\"Peter Parker\", email=\"peter@parker.com\", address_as=\"Peter\"),\n    Recipient(name=\"Mary Watson\", email=\"marry-jane@watson.com\", address_as=\"Mary\"),\n]\n</code></pre> in most cases you will create this using a dataframe of some Google Sheet, and thus it will look more like: <pre><code>recipients = []\nrecip_df = google_sheet_df[[\"First name\", \"Last name\", \"E-mail\"]]\n\nfor _, row in recip_df.iterrows():\n    recipient = Recipient(\n        name=f\"{row['First name']} {row['Last name']}\",\n        email=row[\"E-mail\"],\n        address_as=row[\"First name\"],\n    )\n    recipients.append(recipient)\n</code></pre></p> <p>For more advanced usages, e.g. individual mails corresponding to certain individuals, you can use the <code>data</code> parameter of the <code>Recipient</code> that takes a dictionary. Let's say we want to add a special sentence later for Peter to pay his rent, we can define: <pre><code>Recipient(\n    name=\"Peter Parker\",\n    email=\"peter@parker.com\",\n    address_as=\"Peter\",\n    data={\"feedback\": \"Pay your rent, Parker!\"},\n)\n</code></pre> In the section, we will see how we can access this special attribute again.</p>"},{"location":"usage/mail/#writing-the-e-mail","title":"Writing the E-Mail","text":"<p>So now we can write the actual e-mail text, which just uses the basic string substitution functionality of Python: <pre><code>mail_body = \"\"\"\nHi {recipient.address_as}!\n\nThis is a message from the Program committee with the subject {mail.subject} :-)\n{recipient.data.feedback}\n\nThank you very much {recipient.address_as} for your support!\n\nAll the best,\nProgram Committee\n\"\"\"\n</code></pre> You see that we can use <code>recipient</code> and <code>mail</code> to access the attributes of the Recipient as well as the Mail object to personalize the e-mail.</p> <p>Now we create the Mail object with: <pre><code>from pytanis.helpdesk import Mail\n\nmail = Mail(\n    subject=\"Deadline is coming soon\",\n    text=mail_body,\n    team_id=team_id,\n    agent_id=agent_id,\n    status=\"solved\",\n    recipients=recipients,\n)\n</code></pre></p>"},{"location":"usage/mail/#sending-an-e-mail","title":"Sending an E-mail","text":"<p>Now we have everything assembled to send the e-mail with: <pre><code>from pytanis.helpdesk import MailClient\n\nmail_client = MailClient()\nresponses, errors = mail_client.send(mail, dry_run=True)\nassert not errors\n</code></pre> Having <code>dry_run=True</code> allows you to test you code and just print the resulting e-mails on your console to check if everything is like expected. Later set <code>dry_run=False</code> to actually send the e-mails via HelpDesk.</p> <p>The method <code>send</code> returns a list of successful <code>responses</code> and a hopefully empty list of <code>errors</code>. The <code>responses</code> list is a list of tuples where each tuple holds the Recipient as wells as the returned HelpDesk ticket. The <code>errors</code> list is a list of tuples with the Recipient and the corresponding exception object which occured when sending the mail to the recipient.</p>"},{"location":"usage/mail/#advanced-usage","title":"Advanced Usage","text":"<p>For more details, check out Pytanis' mail references and also the notebook 20_mail_to_reviewers_v1.</p> <p>Tip</p> <p>For contacting your (potential) speakers, Pretalx itself has pretty advanced templating and mailing features so there is no need to use this functionality here. Just make sure that you refer always to HelpDesk in your mails, so that you have a single point of managing mails and tickets.</p>"},{"location":"usage/optional_components/","title":"Optional Components","text":"<p>Starting with version 0.8.0, Pytanis has been refactored to make external dependencies optional. This allows you to install only the components you need, reducing the overall dependency footprint.</p>"},{"location":"usage/optional_components/#installation","title":"Installation","text":""},{"location":"usage/optional_components/#core-installation","title":"Core Installation","text":"<p>The core installation includes only the essential dependencies: <pre><code>pip install pytanis\n</code></pre></p> <p>This gives you: - Pretalx client for conference management - Local file storage (CSV/Excel) - Core utilities and configuration</p>"},{"location":"usage/optional_components/#optional-components_1","title":"Optional Components","text":"<p>Install additional components as needed:</p> <pre><code># Google Sheets support\npip install pytanis[google]\n\n# HelpDesk support\npip install pytanis[helpdesk]\n\n# Mailgun support\npip install pytanis[mailgun]\n\n# Jupyter notebooks and visualization\npip install pytanis[jupyter]\n\n# Schedule optimization\npip install pytanis[optimization]\n\n# Everything\npip install pytanis[all]\n</code></pre>"},{"location":"usage/optional_components/#storage-abstraction","title":"Storage Abstraction","text":"<p>Pytanis now provides a storage abstraction layer that allows you to choose between different storage backends.</p>"},{"location":"usage/optional_components/#configuration","title":"Configuration","text":"<p>Configure your storage provider in <code>config.toml</code>:</p> <pre><code>[Storage]\nprovider = \"local\"  # or \"google\"\nlocal_path = \"./data\"  # for local storage\n\n[Google]  # Only needed if using Google storage\nclient_secret_json = \"client_secret.json\"\ntoken_json = \"token.json\"\n</code></pre>"},{"location":"usage/optional_components/#using-the-storage-api","title":"Using the Storage API","text":"<pre><code>from pytanis import get_storage_client\nimport pandas as pd\n\n# Get storage client based on configuration\nstorage = get_storage_client()\n\n# Create a DataFrame\ndf = pd.DataFrame({'name': ['Alice', 'Bob'], 'score': [95, 87]})\n\n# Write to storage (works with both local and Google)\nstorage.write_sheet('my_data', df, sheet_name='results')\n\n# Read from storage\ndf_read = storage.read_sheet('my_data', 'results')\n\n# List available sheets\nsheets = storage.list_sheets('my_data')\n</code></pre>"},{"location":"usage/optional_components/#local-storage","title":"Local Storage","text":"<p>When using local storage: - Files are stored as Excel (.xlsx) or CSV files - Spreadsheet IDs map to filenames - Multiple sheets are supported for Excel files</p>"},{"location":"usage/optional_components/#google-sheets-storage","title":"Google Sheets Storage","text":"<p>When using Google Sheets: - Requires <code>pytanis[google]</code> installation - Uses the same API as local storage - Spreadsheet IDs are Google Sheets IDs</p>"},{"location":"usage/optional_components/#communication-abstraction","title":"Communication Abstraction","text":"<p>Pytanis provides abstraction for email and ticket systems.</p>"},{"location":"usage/optional_components/#configuration_1","title":"Configuration","text":"<pre><code>[Communication]\nemail_provider = \"mailgun\"  # or \"helpdesk\"\nticket_provider = \"helpdesk\"\n\n[Mailgun]  # If using Mailgun\ntoken = \"your-token\"\nfrom_address = \"noreply@example.com\"\n\n[HelpDesk]  # If using HelpDesk\naccount = \"your-account\"\nentity_id = \"your-entity\"\ntoken = \"your-token\"\n</code></pre>"},{"location":"usage/optional_components/#using-the-communication-api","title":"Using the Communication API","text":"<pre><code>from pytanis import get_mail_client\nfrom pytanis.communication import EmailMessage\n\n# Get mail client based on configuration\nmail_client = get_mail_client()\n\n# Create and send an email\nmessage = EmailMessage(\n    to=['recipient@example.com'],\n    subject='Conference Update',\n    body='Your talk has been accepted!',\n    html_body='&lt;p&gt;Your talk has been accepted!&lt;/p&gt;'\n)\n\nmessage_id = mail_client.send_email(message)\n</code></pre>"},{"location":"usage/optional_components/#backward-compatibility","title":"Backward Compatibility","text":"<p>The original APIs (<code>GSheetsClient</code>, <code>HelpDeskClient</code>) are still available and work as before. They are now lazy-loaded, meaning dependencies are only required when you actually use them.</p> <pre><code># This still works but requires pytanis[google]\nfrom pytanis import GSheetsClient\nclient = GSheetsClient()\n\n# This still works but requires pytanis[helpdesk]\nfrom pytanis import HelpDeskClient\nclient = HelpDeskClient()\n</code></pre>"},{"location":"usage/optional_components/#migration-guide","title":"Migration Guide","text":""},{"location":"usage/optional_components/#for-existing-projects","title":"For Existing Projects","text":"<ol> <li> <p>Update your installation:    <pre><code># If you use all features\npip install pytanis[all]\n\n# Or install only what you need\npip install pytanis[google,mailgun]\n</code></pre></p> </li> <li> <p>Update your configuration (optional):    Add the new sections to use the abstraction layer:    <pre><code>[Storage]\nprovider = \"google\"  # Keep using Google Sheets\n\n[Communication]\nemail_provider = \"mailgun\"  # Keep using Mailgun\n</code></pre></p> </li> <li> <p>Update your code (optional):    You can continue using the old APIs or migrate to the new abstraction:    <pre><code># Old way (still works)\nfrom pytanis import GSheetsClient\nclient = GSheetsClient()\n\n# New way (recommended)\nfrom pytanis import get_storage_client\nstorage = get_storage_client()\n</code></pre></p> </li> </ol>"},{"location":"usage/optional_components/#for-new-projects","title":"For New Projects","text":"<ol> <li>Install only what you need</li> <li>Use the new abstraction APIs</li> <li>Configure providers in <code>config.toml</code></li> </ol>"},{"location":"usage/optional_components/#benefits","title":"Benefits","text":"<ul> <li>Lighter installations: Only install dependencies you actually use</li> <li>Flexibility: Easy to switch between providers</li> <li>Testing: Use local storage for tests, Google Sheets for production</li> <li>Future-proof: Easy to add new providers without changing your code</li> </ul>"},{"location":"usage/pretalx/","title":"Pretalx Client","text":""},{"location":"usage/pretalx/#basic-usage","title":"Basic Usage","text":"<p>Pytanis offers easy access to the Pretalx API and the usage is quite self-explanatory. Let's look at some basic example: <pre><code>from pytanis import PretalxClient\n\nevent_name = \"pyconde-pydata-berlin-2023\"\n\npretalx_client = PretalxClient()\nsubs_count, subs = pretalx_client.submissions(event_name)\n</code></pre> This simple code will return the total number of submissions as <code>subs_count</code> and an iterator of all submissions <code>subs</code>. When iterating over <code>subs</code> new requests will be made internally to the Pretalx server to retrieve more result pages. This method of retrieving partial results is called pagination. Quite often you will just use <code>subs = list(subs)</code> to retrieve all submissions and get a list instead for easier handling. If you want to retrieve always all results directly, i.e. in a blocking way, you can tell this to the client via <code>PretalxClient(blocking=True)</code> but be aware that you must still call <code>subs = list(subs)</code>.</p> <p>All endpoints of the Pretalx API are implemented in Pytanis and the method name corresponds to the name of the endpoint. Additional parameters can be passed using the <code>params</code> argument like e.g.: <pre><code>subs_count, subs = pretalx_client.submissions(\n    event_name, params={\"questions\": \"all\", \"state\": \"submitted\"}\n)\n</code></pre> Check the Pretalx API for a list of options.</p>"},{"location":"usage/pretalx/#api-version-configuration","title":"API Version Configuration","text":"<p>Pytanis supports configuring the Pretalx API version through the configuration file. By default, it uses API version \"v1\", but you can change this if needed:</p> <pre><code>[Pretalx]\napi_token = \"your-api-token\"\napi_version = \"v2\"  # Use a different API version\n</code></pre> <p>The <code>api_version</code> setting is optional. If not specified in your <code>~/.pytanis/config.toml</code>, it will default to \"v1\". This version is sent in the <code>Pretalx-Version</code> header with each API request.</p>"},{"location":"usage/pretalx/#advanced-usage","title":"Advanced Usage","text":"<p>Find out more about the client's capabilities, e.g. throttling, by looking at Pytanis' reference of the pretalx client module.</p>"},{"location":"usage/talks/","title":"Working with Talks","text":"<p>Pytanis provides functionality to easily extract talks from pretalx and convert them to a simplified JSON format that can be used for various purposes like displaying on websites, creating schedules, etc.</p>"},{"location":"usage/talks/#basic-usage","title":"Basic Usage","text":"<p>The simplest way to get talks as JSON is to use the <code>get_talks_as_json</code> function:</p> <pre><code>from pytanis import PretalxClient, get_talks_as_json\n\n# Initialize the pretalx client\npretalx_client = PretalxClient()\n\n# Get JSON string with talks (default: confirmed talks)\nevent_slug = \"your-event-slug\"\njson_data = get_talks_as_json(pretalx_client, event_slug)\n\n# Get JSON string with talks in a different state (e.g., accepted)\njson_data = get_talks_as_json(pretalx_client, event_slug, state_value=\"accepted\")\n\n# Print or use the JSON data\nprint(json_data)\n</code></pre>"},{"location":"usage/talks/#saving-to-a-file","title":"Saving to a File","text":"<p>If you want to save the JSON data to a file, you can use the <code>save_talks_to_json</code> function:</p> <pre><code>from pytanis import PretalxClient, save_talks_to_json\n\n# Initialize the pretalx client\npretalx_client = PretalxClient()\n\n# Save talks to a file (default: confirmed talks)\nevent_slug = \"your-event-slug\"\noutput_file = \"talks.json\"\nsave_talks_to_json(pretalx_client, event_slug, output_file)\n\n# Save talks in a different state (e.g., accepted)\nsave_talks_to_json(pretalx_client, event_slug, \"accepted_talks.json\", state_value=\"accepted\")\n</code></pre>"},{"location":"usage/talks/#the-simpletalk-model","title":"The SimpleTalk Model","text":"<p>The JSON output contains a list of <code>SimpleTalk</code> objects with the following structure:</p> <pre><code>[\n  {\n    \"code\": \"ABC123\",\n    \"title\": \"Talk Title\",\n    \"speaker\": \"Speaker Name 1, Speaker Name 2\",\n    \"organisation\": \"Company Name\",\n    \"track\": \"Track Name\",\n    \"domain_level\": \"Intermediate\",\n    \"python_level\": \"Advanced\",\n    \"duration\": \"45\",\n    \"abstract\": \"Short abstract of the talk\",\n    \"description\": \"Detailed description of the talk\",\n    \"prerequisites\": \"Required knowledge or tools\"\n  },\n  ...\n]\n</code></pre> <p>The fields are:</p> <ul> <li><code>code</code>: The unique code of the talk</li> <li><code>title</code>: The title of the talk</li> <li><code>speaker</code>: A comma-separated list of speaker names</li> <li><code>organisation</code>: The company or institute of the speakers (if available)</li> <li><code>track</code>: The track name (if available)</li> <li><code>domain_level</code>: The domain expertise level (if available)</li> <li><code>python_level</code>: The Python expertise level (if available)</li> <li><code>duration</code>: The duration of the talk in minutes</li> <li><code>abstract</code>: The abstract of the talk</li> <li><code>description</code>: The detailed description of the talk</li> <li><code>prerequisites</code>: Any prerequisites for the talk (if available)</li> </ul>"},{"location":"usage/talks/#using-the-simpletalk-model-directly","title":"Using the SimpleTalk Model Directly","text":"<p>You can also create <code>SimpleTalk</code> objects directly if needed:</p> <pre><code>from pytanis import SimpleTalk\n\ntalk = SimpleTalk(\n    code=\"ABC123\",\n    title=\"My Talk\",\n    speaker=\"John Doe\",\n    organisation=\"Acme Inc.\",\n    track=\"Python\",\n    domain_level=\"Intermediate\",\n    python_level=\"Advanced\",\n    duration=\"30\",\n    abstract=\"This is a talk about Python\",\n    description=\"In this talk, we will explore Python features\",\n    prerequisites=\"Basic programming knowledge\"\n)\n\n# Convert to dict\ntalk_dict = talk.model_dump()\n</code></pre>"},{"location":"usage/talks/#example-script","title":"Example Script","text":"<p>An example script is provided in the <code>examples</code> directory:</p> <pre><code># Get confirmed talks\npython examples/get_talks.py your-event-slug output.json\n\n# Get talks in a specific state\npython examples/get_talks.py your-event-slug output.json accepted\n</code></pre> <p>This script fetches talks for the specified event and state, and saves them to the specified output file.</p>"},{"location":"usage/talks/#advanced-usage","title":"Advanced Usage","text":"<p>If you already have Talk objects and want to convert them to JSON, you can use the <code>talks_to_json</code> function:</p> <pre><code>from pytanis import PretalxClient, talks_to_json\n\n# Initialize the pretalx client\npretalx_client = PretalxClient()\n\n# Fetch talks\nevent_slug = \"your-event-slug\"\n_, talks = pretalx_client.talks(event_slug, params={\"questions\": \"all\"})\n\n# Convert to list to materialize the iterator\ntalks_list = list(talks)\n\n# Convert to JSON\njson_data = talks_to_json(talks_list, pretalx_client, event_slug)\n</code></pre>"},{"location":"usage/talks/#backward-compatibility","title":"Backward Compatibility","text":"<p>For backward compatibility, the following functions are still available:</p> <ul> <li><code>get_confirmed_talks_as_json</code>: Alias for <code>talks_to_json</code></li> <li><code>save_confirmed_talks_to_json</code>: Similar to <code>save_talks_to_json</code> but with a different parameter order</li> </ul>"},{"location":"usage/testing/","title":"Testing","text":"<p>Pytanis includes comprehensive testing tools to ensure compatibility with the Pretalx API. This guide covers how to use the integration tests to validate your setup and API compatibility.</p>"},{"location":"usage/testing/#integration-tests","title":"Integration Tests","text":"<p>The integration tests are designed to validate that all Pytanis data models work correctly with live Pretalx API responses. These tests are particularly useful:</p> <ul> <li>Before upgrading Pytanis to ensure compatibility</li> <li>When the Pretalx API changes</li> <li>To validate your API credentials and permissions</li> <li>To test against different Pretalx events or API versions</li> </ul>"},{"location":"usage/testing/#prerequisites","title":"Prerequisites","text":"<p>To run integration tests, you need:</p> <ol> <li>A valid Pretalx API token</li> <li>An event slug to test against (e.g., <code>pyconde-pydata-2025</code>)</li> <li>Network access to the Pretalx API</li> </ol>"},{"location":"usage/testing/#running-integration-tests","title":"Running Integration Tests","text":""},{"location":"usage/testing/#interactive-mode-recommended","title":"Interactive Mode (Recommended)","text":"<p>The easiest way to run integration tests is using the interactive CLI:</p> <pre><code># From the project root\npython scripts/run_pretalx_integration_tests.py\n</code></pre> <p>This will: 1. Prompt you for your API token (securely, without displaying it) 2. Prompt you for the event slug (default: <code>pyconde-pydata-2025</code>) 3. Prompt you for the API version (default: <code>v1</code>) 4. Show your configuration and ask for confirmation 5. Run the comprehensive integration tests</p> <p>Example interactive session: <pre><code>============================================================\nPretalx Integration Test Runner\n============================================================\n\nThis tool will run comprehensive integration tests against the Pretalx API.\nYou will need:\n1. A valid Pretalx API token\n2. An event slug to test against\n\nPress Ctrl+C at any time to cancel.\n\nEnter Pretalx API token (required): *******\nEnter event slug [default: pyconde-pydata-2025]:\nEnter Pretalx API version [default: v1]: v2\n\nConfiguration:\n- API Token: Provided \u2713\n- Event: pyconde-pydata-2025\n- API Version: v2\n\nDo you want to proceed with these settings? [Y/n]: Y\n\nRunning integration tests...\n</code></pre></p>"},{"location":"usage/testing/#non-interactive-mode","title":"Non-Interactive Mode","text":"<p>For automated testing or CI/CD pipelines, you can provide all parameters via command line:</p> <pre><code># Basic usage with token and event\npython scripts/run_pretalx_integration_tests.py \\\n    --token YOUR_TOKEN \\\n    --event pyconde-pydata-2025\n\n# With specific API version\npython scripts/run_pretalx_integration_tests.py \\\n    --token YOUR_TOKEN \\\n    --event pyconde-pydata-2025 \\\n    --api-version v2\n\n# Run specific test only\npython scripts/run_pretalx_integration_tests.py \\\n    --token YOUR_TOKEN \\\n    --event EVENT \\\n    --test test_all_endpoints\n\n# Quiet mode (less verbose)\npython scripts/run_pretalx_integration_tests.py \\\n    --token YOUR_TOKEN \\\n    --event EVENT \\\n    --quiet\n</code></pre>"},{"location":"usage/testing/#understanding-test-output","title":"Understanding Test Output","text":"<p>The integration test will:</p> <ol> <li>First validate your authentication token and event slug</li> <li>Display detailed API calls including URLs and headers</li> <li>Test each Pretalx endpoint systematically</li> <li>Show real-time results for each endpoint:</li> <li>\u2713 Success with item count for list endpoints</li> <li>\u2717 Failure with error details</li> <li>Test backward compatibility features</li> <li>Provide a summary with success rate</li> </ol> <p>Example output: <pre><code>================================================================================\nVALIDATING TEST CONFIGURATION\n================================================================================\n\nConfiguration:\n  API Version: v2\n  API Token: Provided\n  Event Slug: pyconde-pydata-2025\n\n1. Testing authentication token...\n\n\ud83c\udf10 API Call:\n   URL: https://pretalx.com/api/me\n   Headers: {'Pretalx-Version': 'v2', 'Authorization': 'Token 12345678...'}\n   Response: 200 OK\n   \u2713 Authentication successful! Logged in as: John Doe (john@example.com)\n\n2. Validating event 'pyconde-pydata-2025'...\n\n\ud83c\udf10 API Call:\n   URL: https://pretalx.com/api/events/pyconde-pydata-2025/\n   Headers: {'Pretalx-Version': 'v2', 'Authorization': 'Token 12345678...'}\n   Response: 200 OK\n   \u2713 Event found: PyCon DE &amp; PyData 2025\n     Date: 2025-04-28 to 2025-04-30\n     Timezone: Europe/Berlin\n     Status: Public\n\n\u2713 All validations passed! Proceeding with endpoint tests...\n================================================================================\n\n================================================================================\nCOMPREHENSIVE PRETALX ENDPOINT TEST\nEvent: pyconde-pydata-2025\nAPI Version: v2\nAuthenticated: Yes\n================================================================================\n\n----------------------------------------\nTesting EVENT endpoints...\n----------------------------------------\n\n\ud83c\udf10 API Call:\n   URL: https://pretalx.com/api/events/?limit=5\n   Headers: {'Pretalx-Version': 'v2', 'Authorization': 'Token 12345678...'}\n   Response: 200 OK\n\u2713 /api/events/: SUCCESS (found 5 items)\n\n[... more endpoints with API call details ...]\n\n================================================================================\nTEST SUMMARY\n================================================================================\n\nEndpoints Tested: 25\n\u2713 Successful: 23\n\u2717 Failed: 2\n\nFailed endpoints:\n  - /api/events/pyconde-pydata-2025/reviews/: HTTP 403\n  - /api/events/pyconde-pydata-2025/reviews/1/: HTTP 403\n\nTest Environment:\n  API Version: v2\n  Event: pyconde-pydata-2025\n  Authentication: Yes\n\nSuccess rate: 92.0%\n</code></pre></p>"},{"location":"usage/testing/#interpreting-results","title":"Interpreting Results","text":"<ul> <li>Success Rate: A success rate of 70% or higher is considered passing. Some endpoints may require special permissions.</li> <li>Expected Failures:</li> <li>401/403 errors for protected endpoints without proper permissions</li> <li>404 errors for endpoints that don't exist in your Pretalx instance</li> <li>Backward Compatibility: Tests verify that ID references are properly expanded to full objects</li> </ul>"},{"location":"usage/testing/#using-environment-variables","title":"Using Environment Variables","text":"<p>You can also set environment variables instead of using command-line arguments:</p> <pre><code>export PRETALX_API_TOKEN=\"your-token\"\nexport PRETALX_TEST_EVENT=\"pyconde-pydata-2025\"\nexport PRETALX_API_VERSION=\"v2\"\n\npython scripts/run_pretalx_integration_tests.py\n</code></pre>"},{"location":"usage/testing/#using-hatch-for-development","title":"Using Hatch for Development","text":"<p>If you're contributing to Pytanis, you can use Hatch to run integration tests in a properly configured environment:</p> <pre><code># Run integration tests interactively\nhatch run integration\n\n# Run with arguments\nhatch run integration --token YOUR_TOKEN --event pyconde-pydata-2025\n\n# Quick run with environment variables\nexport PRETALX_API_TOKEN=\"your-token\"\nexport PRETALX_TEST_EVENT=\"pyconde-pydata-2025\"\nhatch run integration-quick\n\n# Run pytest directly with more control\nhatch run test-endpoints\n\n# Run specific test\nhatch run test-endpoints -k test_all_endpoints\n\n# Enter hatch shell for multiple commands\nhatch shell\npython scripts/run_pretalx_integration_tests.py\n</code></pre>"},{"location":"usage/testing/#direct-pytest-usage","title":"Direct pytest Usage","text":"<p>For more control, you can run the tests directly with pytest:</p> <pre><code># Set environment variables first\nexport PRETALX_API_TOKEN=\"your-token\"\nexport PRETALX_TEST_EVENT=\"pyconde-pydata-2025\"\nexport PRETALX_API_VERSION=\"v2\"\n\n# Run all integration tests\npytest tests/pretalx/test_all_endpoints_integration.py -v -s\n\n# Run with specific markers\npytest -m integration -v -s\n</code></pre>"},{"location":"usage/testing/#troubleshooting","title":"Troubleshooting","text":"<p>\"API token is required\" error - Integration tests require a valid API token to test all endpoints properly - Obtain a token from your Pretalx account settings</p> <p>Timeout errors - The Pretalx API can be slow, especially for large events - Consider testing with a smaller event first - Use the <code>--test</code> option to run specific tests</p> <p>High failure rate - Check your API token has the necessary permissions - Verify the event slug exists and is accessible - Some endpoints may not be available in your Pretalx instance</p> <p>SSL/Certificate errors - Ensure your system certificates are up to date - Check if you're behind a corporate proxy</p>"},{"location":"usage/testing/#best-practices","title":"Best Practices","text":"<ol> <li>Regular Testing: Run integration tests before upgrading Pytanis or when you suspect API changes</li> <li>Event Selection: Use a test event with moderate data for faster testing</li> <li>API Version: Always test with the API version you plan to use in production</li> <li>Token Security: Never commit your API token to version control</li> <li>CI/CD Integration: Include integration tests in your deployment pipeline with proper secret management</li> </ol>"},{"location":"usage/testing/#unit-tests","title":"Unit Tests","text":"<p>To run the standard unit tests:</p> <pre><code># Run all tests\npytest\n\n# Run with coverage\npytest --cov=pytanis\n\n# Run specific test file\npytest tests/pretalx/test_models.py\n</code></pre> <p>For more information about testing, see the development guide.</p>"}]}
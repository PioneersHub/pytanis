{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\u200b","text":"<p>Pytanis includes a Pretalx client and all the tooling you need for conferences using Pretalx, from handling the initial call for papers to creating the final program.</p> <p>Trivia: The name Pytanis is a reference to Prytanis using the typical py prefix of Python tools. Prytanis was the name given  to the leading members of the government of a city (polis) in ancient Greece.  Offices that used this title usually had responsibility for presiding over councils of some kind, which met in the Prytaneion. Romani ite domum!</p>"},{"location":"#features","title":"Features","text":"<ul> <li> simple configuration management with a config folder in your home directory, just like many other tools do</li> <li> easily access Google Sheets, potentially filled by some Google Forms, and download sheets as data frames</li> <li> easy to use Pretalx client that returns proper Python objects thanks to the power of pydantic</li> <li> simple e-mail clients for batch mails, e.g. to your reviewers, via Mailgun and HelpDesk</li> <li> awesome documentation with best practices for the program committee of any community-based conference</li> <li> tools to assign proposals to reviewers based on constraints like preferences</li> <li> tools to support the final selection process of proposals</li> <li> tools to support the creation of the final program schedule</li> </ul>"},{"location":"#license","title":"License","text":"<p>Pytanis is distributed under the terms of the MIT license.</p>"},{"location":"#navigation","title":"Navigation","text":"<p>Documentation for specific <code>MAJOR.MINOR</code> versions can be chosen by using the dropdown on the top of every page. The <code>dev</code> version reflects changes that have not yet been released.</p> <p>Also, desktop readers can use special keyboard shortcuts:</p> Keys Action <ul><li>, (comma)</li><li>p</li></ul> Navigate to the \"previous\" page <ul><li>. (period)</li><li>n</li></ul> Navigate to the \"next\" page <ul><li>/</li><li>s</li></ul> Display the search modal"},{"location":"authors/","title":"Contributors","text":"<ul> <li>Florian Wilhelm</li> <li>Alexander Hendorf</li> <li>Paula Gonz\u00e1lez Avalos</li> <li>Christopher Schultz</li> <li>Theodore Meynard</li> <li>Nils Finke</li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#version-092-2025-08-10","title":"Version 0.9.2 (2025-08-10)","text":"<ul> <li>Updated requirements &amp; typos thanks to @jbsilva</li> <li>Speaker.answers update to fit Pretalx API v1: can handle now both non-expanded and expanded answers</li> </ul>"},{"location":"changelog/#version-091-2025-08-09","title":"Version 0.9.1 (2025-08-09)","text":"<ul> <li>Removed support for Python pre-3.12: build problems with hatch / httpx</li> <li>Speaker slot: update to fit Pretalx API v1, reduction to one slot for simplification</li> <li>Added timeouts to httpx requests</li> </ul>"},{"location":"changelog/#version-090-2025-06-26","title":"Version 0.9.0 (2025-06-26)","text":""},{"location":"changelog/#release-compatible-with-pretalx-versioned-api-v1","title":"Release Compatible with Pretalx Versioned API v1","text":"<p>This is the first release fully compatible with the new Pretalx versioned API v1 introduced in May 2025.</p>"},{"location":"changelog/#major-features","title":"Major Features","text":"<ul> <li>Communication abstraction layer: Unified interface for email (Mailgun) and ticket (HelpDesk) providers</li> <li>Factory functions: Simplified client creation with <code>get_ticket_client()</code> and <code>get_mail_client()</code></li> <li>Optional dependencies: Install only what you need with <code>pytanis[google]</code>, <code>pytanis[helpdesk]</code>, <code>pytanis[mailgun]</code></li> </ul>"},{"location":"changelog/#pretalx-api-improvements","title":"Pretalx API Improvements","text":"<ul> <li>API v1 Compatibility: Full support for Pretalx versioned API v1 with proper <code>expand</code> parameter usage</li> <li>api_version: Added configurable Pretalx API version support via <code>api_version</code> config parameter (defaults to \"v1\")</li> </ul>"},{"location":"changelog/#testing-quality","title":"Testing &amp; Quality","text":"<ul> <li>Comprehensive integration test framework with interactive CLI</li> <li>Structured logging with <code>structlog</code> for better test output visibility</li> <li>Support for multiple Pretalx API versions</li> <li>Improved test coverage and documentation</li> </ul>"},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":"<p>none</p>"},{"location":"changelog/#version-08-2024-12-30","title":"Version 0.8 (2024-12-30)","text":"<ul> <li>Added support for Mailgun, thanks to Nils Mohr</li> <li>Added new notebook for calculating submission statistics, thanks to Nils Mohr</li> <li>Added devcontainer for easier development, thanks to Nils Mohr</li> <li>Updated all dependencies, added support for Python 3.13</li> </ul>"},{"location":"changelog/#version-072-2024-06-18","title":"Version 0.7.2 (2024-06-18)","text":"<ul> <li>Matplotlib replaced with webcolors, thanks Alexander Hendorf</li> <li>Updated ruff, pre-commit, mypy etc.</li> </ul>"},{"location":"changelog/#version-071-2024-01-29","title":"Version 0.7.1 (2024-01-29)","text":"<ul> <li>Pin gspread to &lt;6.0 because API was broken</li> </ul>"},{"location":"changelog/#version-07-2024-01-01","title":"Version 0.7 (2024-01-01)","text":"<ul> <li>Switched for reproducability to hatch-pip-compile</li> <li>A few fixes to make mypy happy</li> <li>Some more pydantic v2 deprecations migrated to new API</li> <li>Renamed <code>GSheetClient</code> to <code>GSheetsClient</code></li> <li>Added Gspread service user authentication</li> </ul>"},{"location":"changelog/#version-061-2023-12-10","title":"Version 0.6.1 (2023-12-10)","text":"<ul> <li>Fixed a deadlock problem in <code>utils.throttle</code></li> </ul>"},{"location":"changelog/#version-06-2023-12-04","title":"Version 0.6 (2023-12-04)","text":"<ul> <li>Migrate to Pydantic v2</li> <li>Require mininum Python version of 3.10</li> </ul>"},{"location":"changelog/#version-05-2023-04-10","title":"Version 0.5 (2023-04-10)","text":"<ul> <li>Change the start/end time of a slot to a datetime</li> </ul>"},{"location":"changelog/#version-041-2023-03-25","title":"Version 0.4.1 (2023-03-25)","text":"<ul> <li>Additional documentation about the CfP and some minor fixes</li> </ul>"},{"location":"changelog/#version-04-2023-03-10","title":"Version 0.4 (2023-03-10)","text":"<ul> <li>More functionality regarding the proposal selection process like <code>mark_rows</code></li> <li>Pretalx submissions states are now proper Enums.</li> <li><code>GSheetClient.save_df_as_gsheet</code> also applies some default <code>BasicFormatter</code> for nicer headlines etc.</li> <li>Added some MIP helpers (<code>highs</code>) to support the scheduling process</li> <li>Extended the documentation quite a bit</li> </ul>"},{"location":"changelog/#version-03-2023-02-17","title":"Version 0.3 (2023-02-17)","text":"<ul> <li>Allow creating a worksheet from <code>GSheetClient</code></li> <li>Make <code>get_cfg</code> importable from <code>pytanis</code></li> <li>Fix bug in <code>PretalxClient</code> that returned wrong number of results if a list was passed as <code>params</code> in conjunction with   pagination.</li> </ul>"},{"location":"changelog/#version-02-2023-02-11","title":"Version 0.2 (2023-02-11)","text":"<ul> <li>have a progress bar for long-running commands when possible</li> <li>switched to gspread for handling the low-level GoogleAPI</li> <li>using gspread-dataframe for converting a worksheet into a dataframe</li> <li>timeout of 60s for PretalxAPI as it is really slow, which caused a lot of timeout errors</li> <li>rename <code>*API</code> to <code>*Client</code> as it's rather a client for an API</li> <li>moved some functionality from <code>review</code> to <code>pretalx.utils</code></li> <li><code>GSheetClient</code> allows now uploading dataframes as Google Sheets</li> <li>an awesome logo created by Paula Gonz\u00e1lez Avalos</li> <li>way more usage documentation</li> </ul>"},{"location":"changelog/#version-011-2023-01-16","title":"Version 0.1.1 (2023-01-16)","text":"<ul> <li>fix typo <code>sent</code> -&gt; <code>send</code> in MailClient</li> </ul>"},{"location":"changelog/#version-01-2023-01-15","title":"Version 0.1 (2023-01-15)","text":"<ul> <li>First alpha version that can be used</li> <li>Google client to retrieve Google Sheets implemented</li> <li>Pretalx client implement</li> <li>A very basic HelpDesk client (minimal functionality) implemented</li> <li>Basic e-mail client implemented to send mails via HelpDesk</li> <li>Central configuration management for secrets and credentials implemented</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>Welcome to the contributor guide of Pytanis.</p> <p>This document focuses on getting any potential contributor familiarized with the development processes, but other kinds of contributions are also appreciated.</p> <p>If you are new to using git or have never collaborated on a project previously, please have a look at contribution-guide.org. Other resources are also listed in the excellent guide created by Freecodecamp<sup>1</sup>.</p> <p>Please note: all users and contributors are expected to be open, considerate, reasonable, and respectful. When in doubt, Python Software Foundation's Code of Conduct is a good reference in terms of behavior guidelines.</p>"},{"location":"contributing/#issue-reports","title":"Issue Reports","text":"<p>If you experience bugs or general issues with Pytanis, please have a look at the issue tracker. If you don't see anything useful there, please feel free to file an issue report.</p> <p>Tip</p> <p>Please don't forget to include the closed issues in your search. Sometimes a solution will have been reported already and the problem is considered solved.</p> <p>New issue reports should include information about your programming environment (e.g., operating system, Python version) and steps to reproduce the problem. Please try also to simplify the reproduction steps to a very minimal example that still illustrates the problem you are facing. By removing other factors, you help us to identify the root cause of the issue.</p>"},{"location":"contributing/#documentation-improvements","title":"Documentation improvements","text":"<p>You can contribute to the documentation of Pytanis by making them more readable and coherent, or by adding missing information and correcting mistakes.</p> <p>The documentation uses mkdocs as its main documentation compiler. This means that the docs are kept in the same repository as the project code, and that any documentation update is done in the same way was a code contribution.</p> <p>Tip</p> <p>Please note that the GitHub web interface provides a quick way of   propose changes in <code>Pytanis</code>' files. While this mechanism can   be tricky for normal code contributions, it works perfectly fine for   contributing to the docs, and can be quite handy.</p> <p>If you are interested in trying this method out, please navigate to   the <code>docs</code> folder in the source repository, find which file you   would like to propose changes and click in the little pencil icon at the   top to open GitHub's code editor. Once you finish editing the file,   please write a message in the form at the bottom of the page describing   which changes have you made and what are the motivations behind them and   submit your proposal.</p> <p>When working on documentation changes in your local machine, you can build and serve them using hatch with <code>hatch run docs:build</code> and <code>hatch run docs:serve</code>, respectively.</p>"},{"location":"contributing/#code-contributions","title":"Code Contributions","text":""},{"location":"contributing/#submit-an-issue","title":"Submit an issue","text":"<p>Before you work on any non-trivial code contribution it's best to first create a report in the issue tracker to start a discussion on the subject. This often provides additional considerations and avoids unnecessary work.</p>"},{"location":"contributing/#clone-the-repository","title":"Clone the repository","text":"<ol> <li> <p>Create a user account on GitHub if you do not already have one.</p> </li> <li> <p>Fork the project repository: click on the Fork button near the top of the    page. This creates a copy of the code under your account on GitHub.</p> </li> <li> <p>Clone this copy to your local disk:    <pre><code>git clone git@github.com:YourLogin/pytanis.git\ncd pytanis\n</code></pre></p> </li> <li> <p>Make sure hatch is installed using pipx:    <pre><code>pipx install hatch\n</code></pre></p> </li> <li> <p>[only once] install pre-commit hooks in the default environment with:    <pre><code>hatch run pre-commit install\n</code></pre></p> </li> </ol>"},{"location":"contributing/#implement-your-changes","title":"Implement your changes","text":"<ol> <li> <p>Create a branch to hold your changes:    <pre><code>git checkout -b my-feature\n</code></pre>    and start making changes. Never work on the main branch!</p> </li> <li> <p>Start your work on this branch. Don't forget to add docstrings in Google style    to new functions, modules and classes, especially if they are part of public APIs.</p> </li> <li> <p>Add yourself to the list of contributors in <code>AUTHORS.md</code>.</p> </li> <li> <p>When you\u2019re done editing, do:    <pre><code>git add &lt;MODIFIED FILES&gt;\ngit commit\n</code></pre>    to record your changes in git.        Please make sure to see the validation messages from pre-commit and fix    any eventual issues.    This should automatically use flake8/black to check/fix the code style    in a way that is compatible with the project.</p> <p>Info</p> <p>Don't forget to add unit tests and documentation in case your contribution adds a feature and is not just a bugfix.</p> <p>Moreover, writing an descriptive commit message is highly recommended. In case of doubt, you can check the commit history with: <pre><code>git log --graph --decorate --pretty=oneline --abbrev-commit --all\n</code></pre> to look for recurring communication patterns.</p> </li> <li> <p>Please check that your changes don't break any unit tests with <code>hatch run cov</code> or    <code>hatch run no-cov</code> to run the unitest with or without coverage reports, respectively.</p> </li> <li>For code hygiene, execute <code>hatch run lint:all</code> in order to run flake8, isort, black, mypy, etc.</li> <li>If your changes affect the Pretalx integration, run the integration tests to ensure compatibility:    <pre><code>hatch run integration\n# or with your credentials:\nhatch run integration --token YOUR_TOKEN --event pyconde-pydata-2025\n</code></pre>    See the Testing documentation for more details.</li> </ol>"},{"location":"contributing/#pre-push-verification","title":"Pre-push verification","text":"<p>Before pushing your changes, our pre-push hooks will automatically run to ensure code quality:</p> <ol> <li>Automatic checks: When you run <code>git push</code>, the following checks will run automatically:</li> <li>Pre-commit hooks (formatting, linting, security)</li> <li>Full linting suite (<code>hatch run lint:all</code>)</li> <li> <p>Test suite (<code>hatch run no-cov</code>)</p> </li> <li> <p>Security checks: The following security tools are integrated:</p> </li> <li>Bandit: Scans for common security issues in Python code</li> <li>detect-private-key: Prevents committing private keys</li> <li> <p>Additional security-focused pre-commit hooks</p> </li> <li> <p>Manual verification: You can run these checks manually before pushing:    <pre><code># Run all pre-push checks\n./scripts/pre-push-check.sh\n\n# Or run individual steps:\npre-commit run --all-files  # Run pre-commit hooks (includes security)\nhatch run lint:all          # Run full linting\nhatch run no-cov           # Run tests\n\n# Run only security checks:\npre-commit run bandit --all-files\n</code></pre></p> </li> <li> <p>Bypassing checks: While you can use <code>git push --no-verify</code> to skip these checks,    this is strongly discouraged as it may cause CI failures.</p> </li> </ol>"},{"location":"contributing/#submit-your-contribution","title":"Submit your contribution","text":"<ol> <li>If everything works fine and all checks pass, push your local branch to the remote server with:</li> </ol> <pre><code>git push -u origin my-feature\n</code></pre> <ol> <li>Go to the web page of your fork and click \"Create pull request\"    to send your changes for review.</li> </ol> <p>Find more detailed information in creating a PR. You might also want to open    the PR as a draft first and mark it as ready for review after the feedbacks    from the continuous integration (CI) system or any required fixes.</p> <ol> <li> <p>Even though these resources focus on open source projects and communities, the general ideas behind collaborating with other developers to collectively create software are general and can be applied to all sorts of environments, including private companies and proprietary code bases.\u00a0\u21a9</p> </li> </ol>"},{"location":"license/","title":"License","text":"<p>The MIT License (MIT)</p> <p>Copyright \u00a9 2023 Florian Wilhelm</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"reference/SUMMARY/","title":"Summary","text":"<ul> <li>pytanis<ul> <li>communication<ul> <li>base</li> <li>helpdesk_adapter</li> <li>mailgun_adapter</li> </ul> </li> <li>config</li> <li>factory</li> <li>google</li> <li>helpdesk<ul> <li>client</li> <li>mail</li> <li>models</li> </ul> </li> <li>highs</li> <li>mailgun<ul> <li>mail</li> </ul> </li> <li>pretalx<ul> <li>client</li> <li>models</li> <li>utils</li> </ul> </li> <li>review</li> <li>utils</li> </ul> </li> </ul>"},{"location":"reference/pytanis/","title":"Pytanis","text":""},{"location":"reference/pytanis/#pytanis","title":"<code>pytanis</code>","text":"<p>PyTanis - Python client for Pretalx.</p>"},{"location":"reference/pytanis/#pytanis.__all__","title":"<code>__all__ = ['GSheetsClient', 'HelpDeskClient', 'PretalxClient', 'SimpleTalk', '__version__', 'get_cfg', 'get_confirmed_talks_as_json', 'get_mail_client', 'get_talks_as_json', 'get_ticket_client', 'save_confirmed_talks_to_json', 'save_talks_to_json', 'talks_to_json']</code>  <code>module-attribute</code>","text":""},{"location":"reference/pytanis/#pytanis.__version__","title":"<code>__version__ = version('pytanis')</code>  <code>module-attribute</code>","text":""},{"location":"reference/pytanis/#pytanis.GSheetsClient","title":"<code>GSheetsClient(config: Config | None = None, *, read_only: bool = True)</code>","text":"<p>Google API to easily handle GSheets and other files on GDrive</p> <p>By default, only the least permissive scope <code>GSHEET_RO</code> in case of <code>read_only = True</code> is used.</p> Source code in <code>src/pytanis/google.py</code> <pre><code>def __init__(self, config: Config | None = None, *, read_only: bool = True):\n    self._read_only = read_only\n    if read_only:\n        self._scopes = [Scope.GSHEET_RO]\n    else:\n        self._scopes = [Scope.GSHEET_RW]\n    if config is None:\n        config = get_cfg()\n    self._config = config\n    self.gc = gspread_client(self._scopes, config)  # gspread client for more functionality\n</code></pre>"},{"location":"reference/pytanis/#pytanis.GSheetsClient.gc","title":"<code>gc = gspread_client(self._scopes, config)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/#pytanis.GSheetsClient.clear_gsheet","title":"<code>clear_gsheet(spreadsheet_id: str, worksheet_name: str)</code>","text":"<p>Clear the worksheet including values, formatting, filtering, etc.</p> Source code in <code>src/pytanis/google.py</code> <pre><code>def clear_gsheet(self, spreadsheet_id: str, worksheet_name: str):\n    \"\"\"Clear the worksheet including values, formatting, filtering, etc.\"\"\"\n    worksheet = self.gsheet(spreadsheet_id, worksheet_name, create_ws=False)\n    default_fmt = get_default_format(worksheet.spreadsheet)\n    wrange = worksheet_range(worksheet)\n    try:\n        worksheet.clear()\n        worksheet.clear_basic_filter()\n        format_cell_range(worksheet, wrange, default_fmt)\n        rules = get_conditional_format_rules(worksheet)\n        rules.clear()\n        rules.save()\n        set_data_validation_for_cell_range(worksheet, wrange, None)\n    except APIError as error:\n        self._exception_feedback(error)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.GSheetsClient.gsheet","title":"<code>gsheet(spreadsheet_id: str, worksheet_name: str | None = None, *, create_ws: bool = False) -&gt; Worksheet | Spreadsheet</code>","text":"<p>Retrieve a Google sheet by its id and the name</p> <p>Open a Google sheet in your browser and check the URL to retrieve the id, e.g.: https://docs.google.com/spreadsheets/d/SPREEDSHEET_ID/edit...</p> <p>If the spreadsheet as several worksheets (check the lower bar) then <code>worksheet_name</code> can be used to specify a specific one.</p> Source code in <code>src/pytanis/google.py</code> <pre><code>def gsheet(\n    self, spreadsheet_id: str, worksheet_name: str | None = None, *, create_ws: bool = False\n) -&gt; Worksheet | Spreadsheet:\n    \"\"\"Retrieve a Google sheet by its id and the name\n\n    Open a Google sheet in your browser and check the URL to retrieve the id, e.g.:\n    https://docs.google.com/spreadsheets/d/SPREEDSHEET_ID/edit...\n\n    If the spreadsheet as several worksheets (check the lower bar) then `worksheet_name` can be used to\n    specify a specific one.\n    \"\"\"\n    spreadsheet = self.gc.open_by_key(spreadsheet_id)\n    if worksheet_name is None:\n        return spreadsheet\n    elif worksheet_name in [ws.title for ws in spreadsheet.worksheets()]:\n        return spreadsheet.worksheet(worksheet_name)\n    elif create_ws:\n        worksheet = spreadsheet.add_worksheet(title=worksheet_name, rows=100, cols=20)\n        self._wait_for_worksheet(spreadsheet_id, worksheet_name)\n        return worksheet\n    else:\n        return spreadsheet.worksheet(worksheet_name)  # raises exception\n</code></pre>"},{"location":"reference/pytanis/#pytanis.GSheetsClient.gsheet_as_df","title":"<code>gsheet_as_df(spreadsheet_id: str, worksheet_name: str, **kwargs: str | bool | int) -&gt; pd.DataFrame</code>","text":"<p>Returns a worksheet as dataframe</p> Source code in <code>src/pytanis/google.py</code> <pre><code>def gsheet_as_df(self, spreadsheet_id: str, worksheet_name: str, **kwargs: str | bool | int) -&gt; pd.DataFrame:\n    \"\"\"Returns a worksheet as dataframe\"\"\"\n    worksheet = self.gsheet(spreadsheet_id, worksheet_name)\n    df = get_as_dataframe(worksheet, **kwargs)\n    # remove Nan rows &amp; columns as they are exported by default\n    df.dropna(how='all', inplace=True, axis=0)\n    df.dropna(how='all', inplace=True, axis=1)\n    return df\n</code></pre>"},{"location":"reference/pytanis/#pytanis.GSheetsClient.recreate_token","title":"<code>recreate_token()</code>","text":"<p>Recreate the current token using the scopes given at initialization</p> Source code in <code>src/pytanis/google.py</code> <pre><code>def recreate_token(self):\n    \"\"\"Recreate the current token using the scopes given at initialization\"\"\"\n    self._config.Google.token_json.unlink(missing_ok=True)\n    self.gc = gspread_client(self._scopes, self._config)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.GSheetsClient.save_df_as_gsheet","title":"<code>save_df_as_gsheet(df: pd.DataFrame, spreadsheet_id: str, worksheet_name: str, *, create_ws: bool = False, default_fmt: bool = True, **kwargs: str | (bool | int))</code>","text":"<p>Save the given dataframe as worksheet in a spreadsheet</p> <p>Make sure that the scope passed gives you write permissions</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>dataframe to save</p> required <code>spreadsheet_id</code> <code>str</code> <p>id of the Google spreadsheet</p> required <code>worksheet_name</code> <code>str</code> <p>name of the worksheet within the spreadsheet</p> required <code>create_ws</code> <code>bool</code> <p>create the worksheet if non-existent</p> <code>False</code> <code>default_fmt</code> <code>bool</code> <p>apply default formatter <code>BasicFormatter</code></p> <code>True</code> <code>**kwargs</code> <code>str | (bool | int)</code> <p>extra keyword arguments passed to <code>set_with_dataframe</code></p> <code>{}</code> Source code in <code>src/pytanis/google.py</code> <pre><code>def save_df_as_gsheet(\n    self,\n    df: pd.DataFrame,\n    spreadsheet_id: str,\n    worksheet_name: str,\n    *,\n    create_ws: bool = False,\n    default_fmt: bool = True,\n    **kwargs: str | (bool | int),\n):\n    \"\"\"Save the given dataframe as worksheet in a spreadsheet\n\n    Make sure that the scope passed gives you write permissions\n\n    Args:\n        df: dataframe to save\n        spreadsheet_id: id of the Google spreadsheet\n        worksheet_name: name of the worksheet within the spreadsheet\n        create_ws: create the worksheet if non-existent\n        default_fmt: apply default formatter `BasicFormatter`\n        **kwargs: extra keyword arguments passed to `set_with_dataframe`\n    \"\"\"\n    worksheet = self.gsheet(spreadsheet_id, worksheet_name, create_ws=create_ws)\n    # make sure it's really only the dataframe, not some residue\n    self.clear_gsheet(spreadsheet_id, worksheet_name)\n    params = {'resize': True} | dict(**kwargs)  # set sane defaults\n    try:\n        set_with_dataframe(worksheet, df, **params)\n        if default_fmt:\n            format_with_dataframe(worksheet, df)\n    except APIError as error:\n        self._exception_feedback(error)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.HelpDeskClient","title":"<code>HelpDeskClient(config: Config | None = None)</code>","text":"Source code in <code>src/pytanis/helpdesk/client.py</code> <pre><code>def __init__(self, config: Config | None = None):\n    if config is None:\n        config = get_cfg()\n    self._config = config\n    # Important: Always use a custom User-Agent, never a generic one.\n    # Generic User-Agents are filtered by helpdesk to reduce spam.\n    self._headers = {'User-Agent': 'Pytanis'}\n\n    self._get_throttled = self._get\n    self._post_throttled = self._post\n    self.set_throttling(calls=1, seconds=10)  # Helpdesk is really strange when it comes to this\n</code></pre>"},{"location":"reference/pytanis/#pytanis.HelpDeskClient.create_ticket","title":"<code>create_ticket(ticket: NewTicket)</code>","text":"Source code in <code>src/pytanis/helpdesk/client.py</code> <pre><code>def create_ticket(self, ticket: NewTicket):\n    return self.post('tickets', data=ticket.model_dump())\n</code></pre>"},{"location":"reference/pytanis/#pytanis.HelpDeskClient.get","title":"<code>get(endpoint: str, params: QueryParams | None = None) -&gt; JSON</code>","text":"<p>Retrieve data via throttled GET request and return the JSON</p> Source code in <code>src/pytanis/helpdesk/client.py</code> <pre><code>def get(self, endpoint: str, params: QueryParams | None = None) -&gt; JSON:\n    \"\"\"Retrieve data via throttled GET request and return the JSON\"\"\"\n    resp = self._get_throttled(endpoint, params)\n    resp.raise_for_status()\n    return resp.json()\n</code></pre>"},{"location":"reference/pytanis/#pytanis.HelpDeskClient.list_agents","title":"<code>list_agents() -&gt; list[Agent]</code>","text":"Source code in <code>src/pytanis/helpdesk/client.py</code> <pre><code>def list_agents(self) -&gt; list[Agent]:\n    agents = self.get('agents')\n    if not isinstance(agents, list):\n        msg = 'Received JSON is not a list object'\n        raise ValueError(msg)\n    return [Agent.model_validate(dct) for dct in agents]\n</code></pre>"},{"location":"reference/pytanis/#pytanis.HelpDeskClient.list_teams","title":"<code>list_teams() -&gt; list[Team]</code>","text":"Source code in <code>src/pytanis/helpdesk/client.py</code> <pre><code>def list_teams(self) -&gt; list[Team]:\n    teams = self.get('teams')\n    if not isinstance(teams, list):\n        msg = 'Received JSON is not a list object'\n        raise ValueError(msg)\n    return [Team.model_validate(dct) for dct in teams]\n</code></pre>"},{"location":"reference/pytanis/#pytanis.HelpDeskClient.post","title":"<code>post(endpoint: str, data: dict[str, Any], params: QueryParams | None = None) -&gt; JSON</code>","text":"Source code in <code>src/pytanis/helpdesk/client.py</code> <pre><code>def post(self, endpoint: str, data: dict[str, Any], params: QueryParams | None = None) -&gt; JSON:\n    resp = self._post_throttled(endpoint, data, params)\n    resp.raise_for_status()\n    return resp.json()\n</code></pre>"},{"location":"reference/pytanis/#pytanis.HelpDeskClient.set_throttling","title":"<code>set_throttling(calls: int, seconds: int)</code>","text":"<p>Throttle the number of calls per seconds to the Pretalx API</p> Source code in <code>src/pytanis/helpdesk/client.py</code> <pre><code>def set_throttling(self, calls: int, seconds: int):\n    \"\"\"Throttle the number of calls per seconds to the Pretalx API\"\"\"\n    _logger.debug('throttling', calls=calls, seconds=seconds)\n    self._get_throttled = throttle(calls, seconds)(self._get)\n    self._post_throttled = throttle(calls, seconds)(self._post)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient","title":"<code>PretalxClient(config: Config | None = None, *, blocking: bool = False)</code>","text":"<p>Client for the Pretalx API</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def __init__(self, config: Config | None = None, *, blocking: bool = False):\n    if config is None:\n        config = get_cfg()\n    self._config = config\n    self._get_throttled = self._get\n    self.blocking = blocking\n    self.set_throttling(calls=2, seconds=1)  # we are nice by default and Pretalx doesn't allow many calls at once.\n\n    # Caches for expanded objects (session-only, not persisted)\n    self._speaker_cache: dict[str, dict] = {}\n    self._submission_type_cache: dict[int, dict] = {}\n    self._track_cache: dict[int, dict] = {}\n    self._answer_cache: dict[int, dict | None] = {}\n    self._question_cache: dict[int, dict] = {}\n    self._caches_populated: dict[str, bool] = {}  # Track which event caches are populated\n    self._use_cache_prepopulation: bool = True  # Enable cache pre-population by default\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient.blocking","title":"<code>blocking = blocking</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/#pytanis.PretalxClient.__validate","title":"<code>__validate(model_type, result)</code>  <code>classmethod</code>","text":"Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>@classmethod\ndef __validate(cls, model_type, result):\n    try:\n        validated = model_type.model_validate(result)\n        return validated\n    except Exception as e:\n        # introduced to deal with API changes\n        _logger.error('result', resp=e)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient.answer","title":"<code>answer(event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Answer</code>","text":"<p>Returns a specific answer</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def answer(self, event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Answer:  # noqa: A002\n    \"\"\"Returns a specific answer\"\"\"\n    return self._endpoint_id(Answer, event_slug, 'answers', id, params=params)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient.answers","title":"<code>answers(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Answer]]</code>","text":"<p>Lists all answers and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def answers(self, event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Answer]]:\n    \"\"\"Lists all answers and their details\"\"\"\n    return self._endpoint_lst(Answer, event_slug, 'answers', params=params)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient.clear_caches","title":"<code>clear_caches() -&gt; None</code>","text":"<p>Clear all session caches.</p> <p>This is useful if you want to force fresh data to be fetched from the API. Note that caches are session-only and are not persisted between client instances.</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def clear_caches(self) -&gt; None:\n    \"\"\"Clear all session caches.\n\n    This is useful if you want to force fresh data to be fetched from the API.\n    Note that caches are session-only and are not persisted between client instances.\n    \"\"\"\n    self._speaker_cache.clear()\n    self._submission_type_cache.clear()\n    self._track_cache.clear()\n    self._answer_cache.clear()\n    self._question_cache.clear()\n    self._caches_populated.clear()\n    _logger.info('All caches cleared')\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient.event","title":"<code>event(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; Event</code>","text":"<p>Returns detailed information about a specific event</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def event(self, event_slug: str, *, params: QueryParams | dict | None = None) -&gt; Event:\n    \"\"\"Returns detailed information about a specific event\"\"\"\n    endpoint = f'/api/events/{event_slug}/'\n    result = self._get_one(endpoint, params)\n    _logger.debug('result', resp=result)\n    return self.__validate(Event, result)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient.events","title":"<code>events(*, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Event]]</code>","text":"<p>Lists all events and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def events(self, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Event]]:\n    \"\"\"Lists all events and their details\"\"\"\n    count, results = self._get_many('/api/events/', params)\n    events = iter(_logger.debug('result', resp=r) or Event.model_validate(r) for r in results)\n    return count, events\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient.me","title":"<code>me() -&gt; Me</code>  <code>classmethod</code>","text":"<p>Returns what Pretalx knows about myself</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>@classmethod\ndef me(cls) -&gt; Me:\n    \"\"\"Returns what Pretalx knows about myself\"\"\"\n    # removed in API update v1\n    msg = 'This endpoint is no longer provided since API v1.'\n    raise RuntimeError(msg)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient.question","title":"<code>question(event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Question</code>","text":"<p>Returns a specific question</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def question(self, event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Question:  # noqa: A002\n    \"\"\"Returns a specific question\"\"\"\n    return self._endpoint_id(Question, event_slug, 'questions', id, params=params)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient.questions","title":"<code>questions(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Question]]</code>","text":"<p>Lists all questions and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def questions(self, event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Question]]:\n    \"\"\"Lists all questions and their details\"\"\"\n    return self._endpoint_lst(Question, event_slug, 'questions', params=params)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient.review","title":"<code>review(event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Review</code>","text":"<p>Returns a specific review</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def review(self, event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Review:  # noqa: A002\n    \"\"\"Returns a specific review\"\"\"\n    return self._endpoint_id(Review, event_slug, 'reviews', id, params=params)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient.reviews","title":"<code>reviews(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Review]]</code>","text":"<p>Lists all reviews and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def reviews(self, event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Review]]:\n    \"\"\"Lists all reviews and their details\"\"\"\n    return self._endpoint_lst(Review, event_slug, 'reviews', params=params)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient.room","title":"<code>room(event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Room</code>","text":"<p>Returns a specific room</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def room(self, event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Room:  # noqa: A002\n    \"\"\"Returns a specific room\"\"\"\n    return self._endpoint_id(Room, event_slug, 'rooms', id, params=params)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient.rooms","title":"<code>rooms(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Room]]</code>","text":"<p>Lists all rooms and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def rooms(self, event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Room]]:\n    \"\"\"Lists all rooms and their details\"\"\"\n    return self._endpoint_lst(Room, event_slug, 'rooms', params=params)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient.set_cache_prepopulation","title":"<code>set_cache_prepopulation(enabled: bool) -&gt; None</code>","text":"<p>Enable or disable automatic cache pre-population for submissions.</p> <p>When enabled (default), the client will fetch all speakers, submission types, and tracks in bulk on the first submission to minimize API calls. Disable this if you're only fetching a few submissions.</p> <p>Parameters:</p> Name Type Description Default <code>enabled</code> <code>bool</code> <p>Whether to enable cache pre-population</p> required Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def set_cache_prepopulation(self, enabled: bool) -&gt; None:  # noqa: FBT001\n    \"\"\"Enable or disable automatic cache pre-population for submissions.\n\n    When enabled (default), the client will fetch all speakers, submission types,\n    and tracks in bulk on the first submission to minimize API calls.\n    Disable this if you're only fetching a few submissions.\n\n    Args:\n        enabled: Whether to enable cache pre-population\n    \"\"\"\n    self._use_cache_prepopulation = enabled\n    _logger.info(f'Cache pre-population {\"enabled\" if enabled else \"disabled\"}')\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient.set_throttling","title":"<code>set_throttling(calls: int, seconds: int)</code>","text":"<p>Throttle the number of calls per seconds to the Pretalx API</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def set_throttling(self, calls: int, seconds: int):\n    \"\"\"Throttle the number of calls per seconds to the Pretalx API\"\"\"\n    _logger.info('throttling', calls=calls, seconds=seconds)\n    self._get_throttled = throttle(calls, seconds)(self._get)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient.speaker","title":"<code>speaker(event_slug: str, code: str, *, params: QueryParams | dict | None = None) -&gt; Speaker</code>","text":"<p>Returns a specific speaker</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def speaker(self, event_slug: str, code: str, *, params: QueryParams | dict | None = None) -&gt; Speaker:\n    \"\"\"Returns a specific speaker\"\"\"\n    return self._endpoint_id(Speaker, event_slug, 'speakers', code, params=params)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient.speakers","title":"<code>speakers(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Speaker]]</code>","text":"<p>Lists all speakers and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def speakers(self, event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Speaker]]:\n    \"\"\"Lists all speakers and their details\"\"\"\n    return self._endpoint_lst(Speaker, event_slug, 'speakers', params=params)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient.submission","title":"<code>submission(event_slug: str, code: str, *, params: QueryParams | dict | None = None) -&gt; Submission</code>","text":"<p>Returns a specific submission</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def submission(self, event_slug: str, code: str, *, params: QueryParams | dict | None = None) -&gt; Submission:\n    \"\"\"Returns a specific submission\"\"\"\n    return self._endpoint_id(Submission, event_slug, 'submissions', code, params=params)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient.submission_type","title":"<code>submission_type(event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; SubmissionType</code>","text":"<p>Returns a specific submission type</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def submission_type(self, event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; SubmissionType:  # noqa: A002\n    \"\"\"Returns a specific submission type\"\"\"\n    return self._endpoint_id(SubmissionType, event_slug, 'submission-types', id, params=params)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient.submission_types","title":"<code>submission_types(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[SubmissionType]]</code>","text":"<p>Lists all submission types and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def submission_types(\n    self, event_slug: str, *, params: QueryParams | dict | None = None\n) -&gt; tuple[int, Iterator[SubmissionType]]:\n    \"\"\"Lists all submission types and their details\"\"\"\n    return self._endpoint_lst(SubmissionType, event_slug, 'submission-types', params=params)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient.submissions","title":"<code>submissions(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Submission]]</code>","text":"<p>Lists all submissions and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def submissions(\n    self, event_slug: str, *, params: QueryParams | dict | None = None\n) -&gt; tuple[int, Iterator[Submission]]:\n    \"\"\"Lists all submissions and their details\"\"\"\n    return self._endpoint_lst(Submission, event_slug, 'submissions', params=params)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient.tag","title":"<code>tag(event_slug: str, tag: str, *, params: QueryParams | dict | None = None) -&gt; Tag</code>","text":"<p>Returns a specific tag</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def tag(self, event_slug: str, tag: str, *, params: QueryParams | dict | None = None) -&gt; Tag:\n    \"\"\"Returns a specific tag\"\"\"\n    return self._endpoint_id(Tag, event_slug, 'tags', tag, params=params)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient.tags","title":"<code>tags(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Tag]]</code>","text":"<p>Lists all tags and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def tags(self, event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Tag]]:\n    \"\"\"Lists all tags and their details\"\"\"\n    return self._endpoint_lst(Tag, event_slug, 'tags', params=params)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient.talk","title":"<code>talk(event_slug: str, code: str, *, params: QueryParams | dict | None = None) -&gt; Talk</code>","text":"<p>Returns a specific talk</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def talk(self, event_slug: str, code: str, *, params: QueryParams | dict | None = None) -&gt; Talk:\n    \"\"\"Returns a specific talk\"\"\"\n    try:\n        return self._endpoint_id(Talk, event_slug, 'talks', code, params=params)\n    except httpx.HTTPStatusError as e:\n        if e.response.status_code == HTTPStatus.NOT_FOUND:\n            _logger.info('talk endpoint not available, using submission endpoint')\n            # Use submission endpoint but validate as Talk object\n            return self._endpoint_id(Talk, event_slug, 'submissions', code, params=params)\n        raise\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient.talks","title":"<code>talks(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Talk]]</code>","text":"<p>Lists all talks and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def talks(self, event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Talk]]:\n    \"\"\"Lists all talks and their details\"\"\"\n    try:\n        return self._endpoint_lst(Talk, event_slug, 'talks', params=params)\n    except httpx.HTTPStatusError as e:\n        if e.response.status_code == HTTPStatus.NOT_FOUND:\n            _logger.info('talks endpoint not available, using submissions endpoint')\n            # Use submissions endpoint but validate as Talk objects\n            return self._endpoint_lst(Talk, event_slug, 'submissions', params=params)\n        raise\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient.track","title":"<code>track(event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Track</code>","text":"<p>Returns a specific track</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def track(self, event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Track:  # noqa: A002\n    \"\"\"Returns a specific track\"\"\"\n    return self._endpoint_id(Track, event_slug, 'tracks', id, params=params)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.PretalxClient.tracks","title":"<code>tracks(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Track]]</code>","text":"<p>Lists all tracks and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def tracks(self, event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Track]]:\n    \"\"\"Lists all tracks and their details\"\"\"\n    return self._endpoint_lst(Track, event_slug, 'tracks', params=params)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.SimpleTalk","title":"<code>SimpleTalk</code>","text":"<p>Simplified Talk model for generating JSON output</p> <p>This model contains only the essential information needed for display purposes.</p>"},{"location":"reference/pytanis/#pytanis.SimpleTalk.abstract","title":"<code>abstract: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/#pytanis.SimpleTalk.code","title":"<code>code: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/#pytanis.SimpleTalk.description","title":"<code>description: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/#pytanis.SimpleTalk.domain_level","title":"<code>domain_level: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/#pytanis.SimpleTalk.duration","title":"<code>duration: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/#pytanis.SimpleTalk.organisation","title":"<code>organisation: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/#pytanis.SimpleTalk.prerequisites","title":"<code>prerequisites: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/#pytanis.SimpleTalk.python_level","title":"<code>python_level: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/#pytanis.SimpleTalk.speaker","title":"<code>speaker: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/#pytanis.SimpleTalk.title","title":"<code>title: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/#pytanis.SimpleTalk.track","title":"<code>track: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/#pytanis.__getattr__","title":"<code>__getattr__(name)</code>","text":"<p>Lazy load optional components</p> Source code in <code>src/pytanis/__init__.py</code> <pre><code>def __getattr__(name):\n    \"\"\"Lazy load optional components\"\"\"\n    if name == 'GSheetsClient':\n        try:\n            from pytanis.google import GSheetsClient  # noqa: PLC0415\n\n            return GSheetsClient\n        except ImportError as e:\n            msg = 'Google Sheets dependencies not installed. Install with: pip install pytanis[google]'\n            raise ImportError(msg) from e\n    elif name == 'HelpDeskClient':\n        try:\n            from pytanis.helpdesk import HelpDeskClient  # noqa: PLC0415\n\n            return HelpDeskClient\n        except ImportError as e:\n            msg = 'HelpDesk dependencies not installed. Install with: pip install pytanis[helpdesk]'\n            raise ImportError(msg) from e\n    msg = f\"module '{__name__}' has no attribute '{name}'\"\n    raise AttributeError(msg)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.get_cfg","title":"<code>get_cfg() -&gt; Config</code>","text":"<p>Returns the configuration as an object</p> Source code in <code>src/pytanis/config.py</code> <pre><code>def get_cfg() -&gt; Config:\n    \"\"\"Returns the configuration as an object\"\"\"\n    cfg_path = get_cfg_file()\n    with open(cfg_path, 'rb') as fh:\n        cfg_dict = tomli.load(fh)\n\n    # add config path to later resolve relative paths of config values\n    cfg_dict['cfg_path'] = cfg_path\n\n    # Ensure Pretalx section exists (it's required)\n    if 'Pretalx' not in cfg_dict:\n        cfg_dict['Pretalx'] = {}\n\n    # Optional sections will default to None if not present\n    return Config.model_validate(cfg_dict)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.get_confirmed_talks_as_json","title":"<code>get_confirmed_talks_as_json(pretalx_client: PretalxClient, event_slug: str, params: dict[str, Any] | None = None) -&gt; str</code>","text":"<p>Get confirmed talks from pretalx and convert them to JSON (legacy function for backward compatibility).</p> <p>Parameters:</p> Name Type Description Default <code>pretalx_client</code> <code>PretalxClient</code> <p>PretalxClient instance to fetch talk and speaker data</p> required <code>event_slug</code> <code>str</code> <p>Event slug for the pretalx event</p> required <code>params</code> <code>dict[str, Any] | None</code> <p>Additional parameters to pass to the pretalx API</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>A JSON string containing a list of SimpleTalk objects</p> Source code in <code>src/pytanis/pretalx/utils.py</code> <pre><code>def get_confirmed_talks_as_json(\n    pretalx_client: PretalxClient, event_slug: str, params: dict[str, Any] | None = None\n) -&gt; str:\n    \"\"\"\n    Get confirmed talks from pretalx and convert them to JSON (legacy function for backward compatibility).\n\n    Args:\n        pretalx_client: PretalxClient instance to fetch talk and speaker data\n        event_slug: Event slug for the pretalx event\n        params: Additional parameters to pass to the pretalx API\n\n    Returns:\n        A JSON string containing a list of SimpleTalk objects\n    \"\"\"\n    return get_talks_as_json(pretalx_client, event_slug, 'confirmed', params)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.get_mail_client","title":"<code>get_mail_client(config: Config | None = None) -&gt; BaseMailClient</code>","text":"<p>Get a mail client based on configuration</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config | None</code> <p>Configuration object (if None, will use get_cfg())</p> <code>None</code> <p>Returns:</p> Type Description <code>BaseMailClient</code> <p>A mail client instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no email provider is configured or if it's not supported</p> <code>ImportError</code> <p>If the provider's dependencies are not installed</p> Source code in <code>src/pytanis/factory.py</code> <pre><code>def get_mail_client(config: Config | None = None) -&gt; BaseMailClient:\n    \"\"\"Get a mail client based on configuration\n\n    Args:\n        config: Configuration object (if None, will use get_cfg())\n\n    Returns:\n        A mail client instance\n\n    Raises:\n        ValueError: If no email provider is configured or if it's not supported\n        ImportError: If the provider's dependencies are not installed\n    \"\"\"\n    if config is None:\n        config = get_cfg()\n\n    # Get communication configuration\n    comm_cfg = config.Communication\n    if comm_cfg is None or comm_cfg.email_provider is None:\n        # Check legacy configuration\n        if config.Mailgun is not None and config.Mailgun.token is not None:\n            _logger.info('Using Mailgun from legacy configuration')\n            provider = 'mailgun'\n        elif config.HelpDesk is not None and config.HelpDesk.token is not None:\n            _logger.info('Using HelpDesk from legacy configuration')\n            provider = 'helpdesk'\n        else:\n            msg = 'No email provider configured'\n            raise ValueError(msg)\n    else:\n        provider = comm_cfg.email_provider.lower()\n\n    if provider == 'mailgun':\n        return MailgunAdapter(config=config)\n\n    elif provider == 'helpdesk':\n        return HelpDeskMailAdapter(config=config)\n    else:\n        msg = f'Unknown email provider: {provider}'\n        raise ValueError(msg)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.get_talks_as_json","title":"<code>get_talks_as_json(pretalx_client: PretalxClient, event_slug: str, state_value: str = 'confirmed', params: dict[str, Any] | None = None) -&gt; str</code>","text":"<p>Get talks from pretalx and convert them to a JSON list of SimpleTalk objects.</p> <p>This function fetches talks from pretalx based on the specified state, extracts the essential information, and returns a JSON string containing a list of simplified talk objects.</p> <p>Parameters:</p> Name Type Description Default <code>pretalx_client</code> <code>PretalxClient</code> <p>PretalxClient instance to fetch talk and speaker data</p> required <code>event_slug</code> <code>str</code> <p>Event slug for the pretalx event</p> required <code>state_value</code> <code>str</code> <p>State of talks to include (default: \"confirmed\")</p> <code>'confirmed'</code> <code>params</code> <code>dict[str, Any] | None</code> <p>Additional parameters to pass to the pretalx API</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>A JSON string containing a list of SimpleTalk objects</p> Source code in <code>src/pytanis/pretalx/utils.py</code> <pre><code>def get_talks_as_json(\n    pretalx_client: PretalxClient, event_slug: str, state_value: str = 'confirmed', params: dict[str, Any] | None = None\n) -&gt; str:\n    \"\"\"\n    Get talks from pretalx and convert them to a JSON list of SimpleTalk objects.\n\n    This function fetches talks from pretalx based on the specified state,\n    extracts the essential information, and returns a JSON string containing\n    a list of simplified talk objects.\n\n    Args:\n        pretalx_client: PretalxClient instance to fetch talk and speaker data\n        event_slug: Event slug for the pretalx event\n        state_value: State of talks to include (default: \"confirmed\")\n        params: Additional parameters to pass to the pretalx API\n\n    Returns:\n        A JSON string containing a list of SimpleTalk objects\n    \"\"\"\n    # Prepare parameters for the API call\n    if params is None:\n        params = {}\n\n    # Ensure we get all questions and filter by state\n    params['questions'] = 'all'\n    params['state'] = state_value\n\n    # Fetch talks from pretalx\n    _, talks_iter = pretalx_client.talks(event_slug, params=params)\n    talks = list(talks_iter)  # Materialize the iterator\n\n    return talks_to_json(talks, pretalx_client, event_slug)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.get_ticket_client","title":"<code>get_ticket_client(config: Config | None = None) -&gt; BaseTicketClient</code>","text":"<p>Get a ticket client based on configuration</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config | None</code> <p>Configuration object (if None, will use get_cfg())</p> <code>None</code> <p>Returns:</p> Type Description <code>BaseTicketClient</code> <p>A ticket client instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no ticket provider is configured or if it's not supported</p> <code>ImportError</code> <p>If the provider's dependencies are not installed</p> Source code in <code>src/pytanis/factory.py</code> <pre><code>def get_ticket_client(config: Config | None = None) -&gt; BaseTicketClient:\n    \"\"\"Get a ticket client based on configuration\n\n    Args:\n        config: Configuration object (if None, will use get_cfg())\n\n    Returns:\n        A ticket client instance\n\n    Raises:\n        ValueError: If no ticket provider is configured or if it's not supported\n        ImportError: If the provider's dependencies are not installed\n    \"\"\"\n    if config is None:\n        config = get_cfg()\n\n    # Get communication configuration\n    comm_cfg = config.Communication\n    if comm_cfg is None or comm_cfg.ticket_provider is None:\n        # Check legacy configuration\n        if config.HelpDesk is not None and config.HelpDesk.token is not None:\n            _logger.info('Using HelpDesk from legacy configuration')\n            provider = 'helpdesk'\n        else:\n            msg = 'No ticket provider configured'\n            raise ValueError(msg)\n    else:\n        provider = comm_cfg.ticket_provider.lower()\n\n    if provider != 'helpdesk':\n        msg = f'Unknown ticket provider: {provider}'\n        raise ValueError(msg)\n\n    else:\n        return HelpDeskTicketAdapter(config=config)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.save_confirmed_talks_to_json","title":"<code>save_confirmed_talks_to_json(talks: Iterable[Talk], file_path: str, pretalx_client: PretalxClient | None = None, event_slug: str | None = None) -&gt; None</code>","text":"<p>Save confirmed talks to a JSON file (legacy function for backward compatibility).</p> <p>Parameters:</p> Name Type Description Default <code>talks</code> <code>Iterable[Talk]</code> <p>An iterable of Talk objects, typically from pretalx_client.talks()</p> required <code>file_path</code> <code>str</code> <p>Path where the JSON file should be saved</p> required <code>pretalx_client</code> <code>PretalxClient | None</code> <p>Optional PretalxClient instance to fetch speaker data</p> <code>None</code> <code>event_slug</code> <code>str | None</code> <p>Optional event slug needed if pretalx_client is provided</p> <code>None</code> Source code in <code>src/pytanis/pretalx/utils.py</code> <pre><code>def save_confirmed_talks_to_json(\n    talks: Iterable[Talk], file_path: str, pretalx_client: PretalxClient | None = None, event_slug: str | None = None\n) -&gt; None:\n    \"\"\"\n    Save confirmed talks to a JSON file (legacy function for backward compatibility).\n\n    Args:\n        talks: An iterable of Talk objects, typically from pretalx_client.talks()\n        file_path: Path where the JSON file should be saved\n        pretalx_client: Optional PretalxClient instance to fetch speaker data\n        event_slug: Optional event slug needed if pretalx_client is provided\n    \"\"\"\n    json_data = talks_to_json([talk for talk in talks if talk.state.value == 'confirmed'], pretalx_client, event_slug)\n\n    with open(file_path, 'w', encoding='utf-8') as f:\n        f.write(json_data)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.save_talks_to_json","title":"<code>save_talks_to_json(pretalx_client: PretalxClient, event_slug: str, file_path: str, state_value: str = 'confirmed', params: dict[str, Any] | None = None) -&gt; None</code>","text":"<p>Fetch talks from pretalx and save them to a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>pretalx_client</code> <code>PretalxClient</code> <p>PretalxClient instance to fetch talk and speaker data</p> required <code>event_slug</code> <code>str</code> <p>Event slug for the pretalx event</p> required <code>file_path</code> <code>str</code> <p>Path where the JSON file should be saved</p> required <code>state_value</code> <code>str</code> <p>State of talks to include (default: \"confirmed\")</p> <code>'confirmed'</code> <code>params</code> <code>dict[str, Any] | None</code> <p>Additional parameters to pass to the pretalx API</p> <code>None</code> Source code in <code>src/pytanis/pretalx/utils.py</code> <pre><code>def save_talks_to_json(\n    pretalx_client: PretalxClient,\n    event_slug: str,\n    file_path: str,\n    state_value: str = 'confirmed',\n    params: dict[str, Any] | None = None,\n) -&gt; None:\n    \"\"\"\n    Fetch talks from pretalx and save them to a JSON file.\n\n    Args:\n        pretalx_client: PretalxClient instance to fetch talk and speaker data\n        event_slug: Event slug for the pretalx event\n        file_path: Path where the JSON file should be saved\n        state_value: State of talks to include (default: \"confirmed\")\n        params: Additional parameters to pass to the pretalx API\n    \"\"\"\n    json_data = get_talks_as_json(pretalx_client, event_slug, state_value, params)\n\n    with open(file_path, 'w', encoding='utf-8') as f:\n        f.write(json_data)\n</code></pre>"},{"location":"reference/pytanis/#pytanis.talks_to_json","title":"<code>talks_to_json(talks: Iterable[Talk], pretalx_client: PretalxClient | None = None, event_slug: str | None = None) -&gt; str</code>","text":"<p>Convert Talk objects to a JSON list of SimpleTalk objects.</p> <p>This function extracts the essential information from pretalx Talk objects and returns a JSON string containing a list of simplified talk objects.</p> <p>Parameters:</p> Name Type Description Default <code>talks</code> <code>Iterable[Talk]</code> <p>An iterable of Talk objects</p> required <code>pretalx_client</code> <code>PretalxClient | None</code> <p>Optional PretalxClient instance to fetch speaker data</p> <code>None</code> <code>event_slug</code> <code>str | None</code> <p>Optional event slug needed if pretalx_client is provided</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>A JSON string containing a list of SimpleTalk objects</p> Source code in <code>src/pytanis/pretalx/utils.py</code> <pre><code>def talks_to_json(\n    talks: Iterable[Talk], pretalx_client: PretalxClient | None = None, event_slug: str | None = None\n) -&gt; str:\n    \"\"\"\n    Convert Talk objects to a JSON list of SimpleTalk objects.\n\n    This function extracts the essential information from pretalx Talk objects\n    and returns a JSON string containing a list of simplified talk objects.\n\n    Args:\n        talks: An iterable of Talk objects\n        pretalx_client: Optional PretalxClient instance to fetch speaker data\n        event_slug: Optional event slug needed if pretalx_client is provided\n\n    Returns:\n        A JSON string containing a list of SimpleTalk objects\n    \"\"\"\n    simple_talks = []\n\n    # Store speaker data to avoid fetching the same speaker multiple times\n    speaker_data: dict[str, Speaker] = {}\n\n    for talk in talks:\n        # Create a SimpleTalk object with basic information\n        simple_talk = create_simple_talk_from_talk(talk)\n\n        # Extract expertise levels and prerequisites\n        extract_expertise_and_prerequisites(talk, simple_talk)\n\n        # Extract organisation information\n        if event_slug and pretalx_client:\n            extract_organisation(talk, simple_talk, pretalx_client, event_slug, speaker_data)\n\n        simple_talks.append(simple_talk)\n\n    # Convert to JSON\n    return json.dumps([talk.model_dump() for talk in simple_talks], indent=2)\n</code></pre>"},{"location":"reference/pytanis/config/","title":"Config","text":""},{"location":"reference/pytanis/config/#pytanis.config","title":"<code>config</code>","text":"<p>Handling the configuration</p>"},{"location":"reference/pytanis/config/#pytanis.config.PYTANIS_CFG_PATH","title":"<code>PYTANIS_CFG_PATH: str = '.pytanis/config.toml'</code>  <code>module-attribute</code>","text":"<p>Path within $HOME to the configuration file of Pytanis</p>"},{"location":"reference/pytanis/config/#pytanis.config.PYTANIS_ENV","title":"<code>PYTANIS_ENV: str = 'PYTANIS_CONFIG'</code>  <code>module-attribute</code>","text":"<p>Name of the environment variable to look up the path for the config</p>"},{"location":"reference/pytanis/config/#pytanis.config.__all__","title":"<code>__all__ = ['CommunicationCfg', 'Config', 'GoogleCfg', 'HelpDeskCfg', 'MailgunCfg', 'PretalxCfg', 'get_cfg', 'get_cfg_file']</code>  <code>module-attribute</code>","text":""},{"location":"reference/pytanis/config/#pytanis.config.CommunicationCfg","title":"<code>CommunicationCfg</code>","text":"<p>Configuration for communication providers</p>"},{"location":"reference/pytanis/config/#pytanis.config.CommunicationCfg.email_provider","title":"<code>email_provider: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/config/#pytanis.config.CommunicationCfg.ticket_provider","title":"<code>ticket_provider: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/config/#pytanis.config.Config","title":"<code>Config</code>","text":"<p>Main configuration object</p>"},{"location":"reference/pytanis/config/#pytanis.config.Config.Communication","title":"<code>Communication: CommunicationCfg | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/config/#pytanis.config.Config.Google","title":"<code>Google: GoogleCfg | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/config/#pytanis.config.Config.HelpDesk","title":"<code>HelpDesk: HelpDeskCfg | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/config/#pytanis.config.Config.Mailgun","title":"<code>Mailgun: MailgunCfg | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/config/#pytanis.config.Config.Pretalx","title":"<code>Pretalx: PretalxCfg</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/config/#pytanis.config.Config.cfg_path","title":"<code>cfg_path: FilePath</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/config/#pytanis.config.Config.convert_json_path","title":"<code>convert_json_path(v: GoogleCfg | None, info: ValidationInfo) -&gt; GoogleCfg | None</code>  <code>classmethod</code>","text":"Source code in <code>src/pytanis/config.py</code> <pre><code>@field_validator('Google')\n@classmethod\ndef convert_json_path(cls, v: GoogleCfg | None, info: ValidationInfo) -&gt; GoogleCfg | None:\n    if v is None:\n        return v\n\n    def make_rel_path_abs(entry):\n        if entry is not None and not entry.is_absolute():\n            entry = info.data['cfg_path'].parent / entry\n        return entry\n\n    v.client_secret_json = make_rel_path_abs(v.client_secret_json)\n    v.token_json = make_rel_path_abs(v.token_json)\n\n    return v\n</code></pre>"},{"location":"reference/pytanis/config/#pytanis.config.GoogleCfg","title":"<code>GoogleCfg</code>","text":"<p>Configuration related to the Google API</p>"},{"location":"reference/pytanis/config/#pytanis.config.GoogleCfg.client_secret_json","title":"<code>client_secret_json: Path | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/config/#pytanis.config.GoogleCfg.service_user_authentication","title":"<code>service_user_authentication: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/config/#pytanis.config.GoogleCfg.token_json","title":"<code>token_json: Path | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/config/#pytanis.config.HelpDeskCfg","title":"<code>HelpDeskCfg</code>","text":"<p>Configuration related to the HelpDesk API</p>"},{"location":"reference/pytanis/config/#pytanis.config.HelpDeskCfg.account","title":"<code>account: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/config/#pytanis.config.HelpDeskCfg.entity_id","title":"<code>entity_id: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/config/#pytanis.config.HelpDeskCfg.token","title":"<code>token: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/config/#pytanis.config.MailgunCfg","title":"<code>MailgunCfg</code>","text":"<p>Configuration related to the Mailgun API</p>"},{"location":"reference/pytanis/config/#pytanis.config.MailgunCfg.from_address","title":"<code>from_address: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/config/#pytanis.config.MailgunCfg.reply_to","title":"<code>reply_to: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/config/#pytanis.config.MailgunCfg.token","title":"<code>token: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/config/#pytanis.config.PretalxCfg","title":"<code>PretalxCfg</code>","text":"<p>Pydantic model for the Pretalx configuration</p>"},{"location":"reference/pytanis/config/#pytanis.config.PretalxCfg.api_token","title":"<code>api_token: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/config/#pytanis.config.PretalxCfg.api_version","title":"<code>api_version: str = 'v1'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/config/#pytanis.config.PretalxCfg.timeout","title":"<code>timeout: int | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/config/#pytanis.config.get_cfg","title":"<code>get_cfg() -&gt; Config</code>","text":"<p>Returns the configuration as an object</p> Source code in <code>src/pytanis/config.py</code> <pre><code>def get_cfg() -&gt; Config:\n    \"\"\"Returns the configuration as an object\"\"\"\n    cfg_path = get_cfg_file()\n    with open(cfg_path, 'rb') as fh:\n        cfg_dict = tomli.load(fh)\n\n    # add config path to later resolve relative paths of config values\n    cfg_dict['cfg_path'] = cfg_path\n\n    # Ensure Pretalx section exists (it's required)\n    if 'Pretalx' not in cfg_dict:\n        cfg_dict['Pretalx'] = {}\n\n    # Optional sections will default to None if not present\n    return Config.model_validate(cfg_dict)\n</code></pre>"},{"location":"reference/pytanis/config/#pytanis.config.get_cfg_file","title":"<code>get_cfg_file() -&gt; Path</code>","text":"<p>Determines the path of the config file</p> Source code in <code>src/pytanis/config.py</code> <pre><code>def get_cfg_file() -&gt; Path:\n    \"\"\"Determines the path of the config file\"\"\"\n    path_str = os.environ.get(PYTANIS_ENV, None)\n    path = Path.home() / Path(PYTANIS_CFG_PATH) if path_str is None else Path(path_str)\n    return path\n</code></pre>"},{"location":"reference/pytanis/factory/","title":"Factory","text":""},{"location":"reference/pytanis/factory/#pytanis.factory","title":"<code>factory</code>","text":"<p>Factory functions for creating storage and communication clients</p>"},{"location":"reference/pytanis/factory/#pytanis.factory.get_mail_client","title":"<code>get_mail_client(config: Config | None = None) -&gt; BaseMailClient</code>","text":"<p>Get a mail client based on configuration</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config | None</code> <p>Configuration object (if None, will use get_cfg())</p> <code>None</code> <p>Returns:</p> Type Description <code>BaseMailClient</code> <p>A mail client instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no email provider is configured or if it's not supported</p> <code>ImportError</code> <p>If the provider's dependencies are not installed</p> Source code in <code>src/pytanis/factory.py</code> <pre><code>def get_mail_client(config: Config | None = None) -&gt; BaseMailClient:\n    \"\"\"Get a mail client based on configuration\n\n    Args:\n        config: Configuration object (if None, will use get_cfg())\n\n    Returns:\n        A mail client instance\n\n    Raises:\n        ValueError: If no email provider is configured or if it's not supported\n        ImportError: If the provider's dependencies are not installed\n    \"\"\"\n    if config is None:\n        config = get_cfg()\n\n    # Get communication configuration\n    comm_cfg = config.Communication\n    if comm_cfg is None or comm_cfg.email_provider is None:\n        # Check legacy configuration\n        if config.Mailgun is not None and config.Mailgun.token is not None:\n            _logger.info('Using Mailgun from legacy configuration')\n            provider = 'mailgun'\n        elif config.HelpDesk is not None and config.HelpDesk.token is not None:\n            _logger.info('Using HelpDesk from legacy configuration')\n            provider = 'helpdesk'\n        else:\n            msg = 'No email provider configured'\n            raise ValueError(msg)\n    else:\n        provider = comm_cfg.email_provider.lower()\n\n    if provider == 'mailgun':\n        return MailgunAdapter(config=config)\n\n    elif provider == 'helpdesk':\n        return HelpDeskMailAdapter(config=config)\n    else:\n        msg = f'Unknown email provider: {provider}'\n        raise ValueError(msg)\n</code></pre>"},{"location":"reference/pytanis/factory/#pytanis.factory.get_ticket_client","title":"<code>get_ticket_client(config: Config | None = None) -&gt; BaseTicketClient</code>","text":"<p>Get a ticket client based on configuration</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config | None</code> <p>Configuration object (if None, will use get_cfg())</p> <code>None</code> <p>Returns:</p> Type Description <code>BaseTicketClient</code> <p>A ticket client instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no ticket provider is configured or if it's not supported</p> <code>ImportError</code> <p>If the provider's dependencies are not installed</p> Source code in <code>src/pytanis/factory.py</code> <pre><code>def get_ticket_client(config: Config | None = None) -&gt; BaseTicketClient:\n    \"\"\"Get a ticket client based on configuration\n\n    Args:\n        config: Configuration object (if None, will use get_cfg())\n\n    Returns:\n        A ticket client instance\n\n    Raises:\n        ValueError: If no ticket provider is configured or if it's not supported\n        ImportError: If the provider's dependencies are not installed\n    \"\"\"\n    if config is None:\n        config = get_cfg()\n\n    # Get communication configuration\n    comm_cfg = config.Communication\n    if comm_cfg is None or comm_cfg.ticket_provider is None:\n        # Check legacy configuration\n        if config.HelpDesk is not None and config.HelpDesk.token is not None:\n            _logger.info('Using HelpDesk from legacy configuration')\n            provider = 'helpdesk'\n        else:\n            msg = 'No ticket provider configured'\n            raise ValueError(msg)\n    else:\n        provider = comm_cfg.ticket_provider.lower()\n\n    if provider != 'helpdesk':\n        msg = f'Unknown ticket provider: {provider}'\n        raise ValueError(msg)\n\n    else:\n        return HelpDeskTicketAdapter(config=config)\n</code></pre>"},{"location":"reference/pytanis/google/","title":"Google","text":""},{"location":"reference/pytanis/google/#pytanis.google","title":"<code>google</code>","text":"<p>Functionality around the Google's Spreadsheet API</p> <p>Additional Documentation</p> <ul> <li>Google GSheet API</li> <li>GSpread</li> <li>GSpread-Dataframe</li> <li>GSpread-Formatting</li> </ul>"},{"location":"reference/pytanis/google/#pytanis.google.ColorType","title":"<code>ColorType = str | tuple[float, float, float] | tuple[float, float, float, float]</code>  <code>module-attribute</code>","text":""},{"location":"reference/pytanis/google/#pytanis.google.__all__","title":"<code>__all__ = ['GSheetsClient', 'PermissionDeniedError', 'gsheet_rows_for_fmt']</code>  <code>module-attribute</code>","text":""},{"location":"reference/pytanis/google/#pytanis.google.GSheetsClient","title":"<code>GSheetsClient(config: Config | None = None, *, read_only: bool = True)</code>","text":"<p>Google API to easily handle GSheets and other files on GDrive</p> <p>By default, only the least permissive scope <code>GSHEET_RO</code> in case of <code>read_only = True</code> is used.</p> Source code in <code>src/pytanis/google.py</code> <pre><code>def __init__(self, config: Config | None = None, *, read_only: bool = True):\n    self._read_only = read_only\n    if read_only:\n        self._scopes = [Scope.GSHEET_RO]\n    else:\n        self._scopes = [Scope.GSHEET_RW]\n    if config is None:\n        config = get_cfg()\n    self._config = config\n    self.gc = gspread_client(self._scopes, config)  # gspread client for more functionality\n</code></pre>"},{"location":"reference/pytanis/google/#pytanis.google.GSheetsClient.gc","title":"<code>gc = gspread_client(self._scopes, config)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/google/#pytanis.google.GSheetsClient.clear_gsheet","title":"<code>clear_gsheet(spreadsheet_id: str, worksheet_name: str)</code>","text":"<p>Clear the worksheet including values, formatting, filtering, etc.</p> Source code in <code>src/pytanis/google.py</code> <pre><code>def clear_gsheet(self, spreadsheet_id: str, worksheet_name: str):\n    \"\"\"Clear the worksheet including values, formatting, filtering, etc.\"\"\"\n    worksheet = self.gsheet(spreadsheet_id, worksheet_name, create_ws=False)\n    default_fmt = get_default_format(worksheet.spreadsheet)\n    wrange = worksheet_range(worksheet)\n    try:\n        worksheet.clear()\n        worksheet.clear_basic_filter()\n        format_cell_range(worksheet, wrange, default_fmt)\n        rules = get_conditional_format_rules(worksheet)\n        rules.clear()\n        rules.save()\n        set_data_validation_for_cell_range(worksheet, wrange, None)\n    except APIError as error:\n        self._exception_feedback(error)\n</code></pre>"},{"location":"reference/pytanis/google/#pytanis.google.GSheetsClient.gsheet","title":"<code>gsheet(spreadsheet_id: str, worksheet_name: str | None = None, *, create_ws: bool = False) -&gt; Worksheet | Spreadsheet</code>","text":"<p>Retrieve a Google sheet by its id and the name</p> <p>Open a Google sheet in your browser and check the URL to retrieve the id, e.g.: https://docs.google.com/spreadsheets/d/SPREEDSHEET_ID/edit...</p> <p>If the spreadsheet as several worksheets (check the lower bar) then <code>worksheet_name</code> can be used to specify a specific one.</p> Source code in <code>src/pytanis/google.py</code> <pre><code>def gsheet(\n    self, spreadsheet_id: str, worksheet_name: str | None = None, *, create_ws: bool = False\n) -&gt; Worksheet | Spreadsheet:\n    \"\"\"Retrieve a Google sheet by its id and the name\n\n    Open a Google sheet in your browser and check the URL to retrieve the id, e.g.:\n    https://docs.google.com/spreadsheets/d/SPREEDSHEET_ID/edit...\n\n    If the spreadsheet as several worksheets (check the lower bar) then `worksheet_name` can be used to\n    specify a specific one.\n    \"\"\"\n    spreadsheet = self.gc.open_by_key(spreadsheet_id)\n    if worksheet_name is None:\n        return spreadsheet\n    elif worksheet_name in [ws.title for ws in spreadsheet.worksheets()]:\n        return spreadsheet.worksheet(worksheet_name)\n    elif create_ws:\n        worksheet = spreadsheet.add_worksheet(title=worksheet_name, rows=100, cols=20)\n        self._wait_for_worksheet(spreadsheet_id, worksheet_name)\n        return worksheet\n    else:\n        return spreadsheet.worksheet(worksheet_name)  # raises exception\n</code></pre>"},{"location":"reference/pytanis/google/#pytanis.google.GSheetsClient.gsheet_as_df","title":"<code>gsheet_as_df(spreadsheet_id: str, worksheet_name: str, **kwargs: str | bool | int) -&gt; pd.DataFrame</code>","text":"<p>Returns a worksheet as dataframe</p> Source code in <code>src/pytanis/google.py</code> <pre><code>def gsheet_as_df(self, spreadsheet_id: str, worksheet_name: str, **kwargs: str | bool | int) -&gt; pd.DataFrame:\n    \"\"\"Returns a worksheet as dataframe\"\"\"\n    worksheet = self.gsheet(spreadsheet_id, worksheet_name)\n    df = get_as_dataframe(worksheet, **kwargs)\n    # remove Nan rows &amp; columns as they are exported by default\n    df.dropna(how='all', inplace=True, axis=0)\n    df.dropna(how='all', inplace=True, axis=1)\n    return df\n</code></pre>"},{"location":"reference/pytanis/google/#pytanis.google.GSheetsClient.recreate_token","title":"<code>recreate_token()</code>","text":"<p>Recreate the current token using the scopes given at initialization</p> Source code in <code>src/pytanis/google.py</code> <pre><code>def recreate_token(self):\n    \"\"\"Recreate the current token using the scopes given at initialization\"\"\"\n    self._config.Google.token_json.unlink(missing_ok=True)\n    self.gc = gspread_client(self._scopes, self._config)\n</code></pre>"},{"location":"reference/pytanis/google/#pytanis.google.GSheetsClient.save_df_as_gsheet","title":"<code>save_df_as_gsheet(df: pd.DataFrame, spreadsheet_id: str, worksheet_name: str, *, create_ws: bool = False, default_fmt: bool = True, **kwargs: str | (bool | int))</code>","text":"<p>Save the given dataframe as worksheet in a spreadsheet</p> <p>Make sure that the scope passed gives you write permissions</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>dataframe to save</p> required <code>spreadsheet_id</code> <code>str</code> <p>id of the Google spreadsheet</p> required <code>worksheet_name</code> <code>str</code> <p>name of the worksheet within the spreadsheet</p> required <code>create_ws</code> <code>bool</code> <p>create the worksheet if non-existent</p> <code>False</code> <code>default_fmt</code> <code>bool</code> <p>apply default formatter <code>BasicFormatter</code></p> <code>True</code> <code>**kwargs</code> <code>str | (bool | int)</code> <p>extra keyword arguments passed to <code>set_with_dataframe</code></p> <code>{}</code> Source code in <code>src/pytanis/google.py</code> <pre><code>def save_df_as_gsheet(\n    self,\n    df: pd.DataFrame,\n    spreadsheet_id: str,\n    worksheet_name: str,\n    *,\n    create_ws: bool = False,\n    default_fmt: bool = True,\n    **kwargs: str | (bool | int),\n):\n    \"\"\"Save the given dataframe as worksheet in a spreadsheet\n\n    Make sure that the scope passed gives you write permissions\n\n    Args:\n        df: dataframe to save\n        spreadsheet_id: id of the Google spreadsheet\n        worksheet_name: name of the worksheet within the spreadsheet\n        create_ws: create the worksheet if non-existent\n        default_fmt: apply default formatter `BasicFormatter`\n        **kwargs: extra keyword arguments passed to `set_with_dataframe`\n    \"\"\"\n    worksheet = self.gsheet(spreadsheet_id, worksheet_name, create_ws=create_ws)\n    # make sure it's really only the dataframe, not some residue\n    self.clear_gsheet(spreadsheet_id, worksheet_name)\n    params = {'resize': True} | dict(**kwargs)  # set sane defaults\n    try:\n        set_with_dataframe(worksheet, df, **params)\n        if default_fmt:\n            format_with_dataframe(worksheet, df)\n    except APIError as error:\n        self._exception_feedback(error)\n</code></pre>"},{"location":"reference/pytanis/google/#pytanis.google.PermissionDeniedError","title":"<code>PermissionDeniedError</code>","text":"<p>Error for APIError with status PERMISSION_DENIED</p> <p>Most likely thrown in cases when the scope is not <code>GSHEET_RW</code> or the token needs to be updated accordingly.</p>"},{"location":"reference/pytanis/google/#pytanis.google.Scope","title":"<code>Scope</code>","text":""},{"location":"reference/pytanis/google/#pytanis.google.Scope.GDRIVE_FILE","title":"<code>GDRIVE_FILE = 'https://www.googleapis.com/auth/drive.file'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/google/#pytanis.google.Scope.GDRIVE_RO","title":"<code>GDRIVE_RO = 'https://www.googleapis.com/auth/drive.readonly'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/google/#pytanis.google.Scope.GDRIVE_RW","title":"<code>GDRIVE_RW = 'https://www.googleapis.com/auth/drive'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/google/#pytanis.google.Scope.GSHEET_RO","title":"<code>GSHEET_RO = 'https://www.googleapis.com/auth/spreadsheets.readonly'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/google/#pytanis.google.Scope.GSHEET_RW","title":"<code>GSHEET_RW = 'https://www.googleapis.com/auth/spreadsheets'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/google/#pytanis.google.gsheet_col","title":"<code>gsheet_col(idx: int) -&gt; str</code>","text":"<p>Convert a column index to Google Sheet range notation, e.g. A, BE, etc.</p> Source code in <code>src/pytanis/google.py</code> <pre><code>def gsheet_col(idx: int) -&gt; str:\n    \"\"\"Convert a column index to Google Sheet range notation, e.g. A, BE, etc.\"\"\"\n    idx += 1\n    chars = []\n    while idx:\n        chars.append(string.ascii_uppercase[(idx % 26) - 1])\n        idx //= 27\n    return ''.join(chars[::-1])\n</code></pre>"},{"location":"reference/pytanis/google/#pytanis.google.gsheet_rows_for_fmt","title":"<code>gsheet_rows_for_fmt(mask: pd.Series, n_cols: int) -&gt; list[str]</code>","text":"<p>Get the Google Sheet row range specifications for formatting</p> Source code in <code>src/pytanis/google.py</code> <pre><code>def gsheet_rows_for_fmt(mask: pd.Series, n_cols: int) -&gt; list[str]:\n    \"\"\"Get the Google Sheet row range specifications for formatting\"\"\"\n    rows: pd.Series = pd.Series(np.argwhere(mask.to_numpy()).reshape(-1) + 2)  # +2 since 1-index and header\n    last_col = gsheet_col(n_cols - 1)  # last index\n    rows = rows.map(lambda x: f'A{x}:{last_col}{x}')\n    return rows.to_list()\n</code></pre>"},{"location":"reference/pytanis/google/#pytanis.google.gspread_client","title":"<code>gspread_client(scopes: list[Scope], config: Config) -&gt; gspread.client.Client</code>","text":"<p>Creates the GSheet client using our configuration</p> <p>Read GSpread for usage details</p> Source code in <code>src/pytanis/google.py</code> <pre><code>def gspread_client(scopes: list[Scope], config: Config) -&gt; gspread.client.Client:\n    \"\"\"Creates the GSheet client using our configuration\n\n    Read [GSpread](https://docs.gspread.org/) for usage details\n    \"\"\"\n    if config.Google is None:\n        msg = 'Google configuration is missing in config.toml!'\n        raise RuntimeError(msg)\n    if (secret_path := config.Google.client_secret_json) is None:\n        msg = 'You have to set Google.client_secret_json in your config.toml!'\n        raise RuntimeError(msg)\n\n    if (service_user_authentication := config.Google.service_user_authentication) is None:\n        service_user_authentication = False\n\n    if service_user_authentication:\n        gc = gspread.service_account(scopes=[scope.value for scope in scopes], filename=str(secret_path))\n    else:\n        if (token_path := config.Google.token_json) is None:\n            msg = 'You have to set Google.token_json in your config.toml!'\n            raise RuntimeError(msg)\n\n        gc = gspread.oauth(\n            scopes=[scope.value for scope in scopes],\n            credentials_filename=str(secret_path),\n            authorized_user_filename=str(token_path),\n        )\n\n    return gc\n</code></pre>"},{"location":"reference/pytanis/google/#pytanis.google.mark_rows","title":"<code>mark_rows(worksheet, mask: pd.Series, color: ColorType)</code>","text":"<p>Mark rows specified by a mask (condition) with a given color</p> <p>Color can be a tuple of RGB values or a Matplotlib string specification: https://matplotlib.org/stable/gallery/color/named_colors.html#css-colors</p> Source code in <code>src/pytanis/google.py</code> <pre><code>def mark_rows(worksheet, mask: pd.Series, color: ColorType):\n    \"\"\"Mark rows specified by a mask (condition) with a given color\n\n    Color can be a tuple of RGB values or a Matplotlib string specification:\n    https://matplotlib.org/stable/gallery/color/named_colors.html#css-colors\n    \"\"\"\n    rows = gsheet_rows_for_fmt(mask, worksheet.col_count)\n    color_rgb = name_to_rgb(color) if isinstance(color, str) else color[:3]\n    color_rgb = [x / 255 for x in color_rgb]  # convert RGB to 0-1 range\n    fmt = CellFormat(backgroundColor=Color(*color_rgb))\n    if rows:\n        format_cell_ranges(worksheet, [(rng, fmt) for rng in rows])\n</code></pre>"},{"location":"reference/pytanis/google/#pytanis.google.worksheet_range","title":"<code>worksheet_range(worksheet: Worksheet) -&gt; str</code>","text":"<p>Returns a range encompassing the whole worksheet</p> Source code in <code>src/pytanis/google.py</code> <pre><code>def worksheet_range(worksheet: Worksheet) -&gt; str:\n    \"\"\"Returns a range encompassing the whole worksheet\"\"\"\n    last_row = worksheet.row_count\n    last_col = gsheet_col(worksheet.col_count)\n    return f'A1:{last_col}{last_row}'\n</code></pre>"},{"location":"reference/pytanis/highs/","title":"Highs","text":""},{"location":"reference/pytanis/highs/#pytanis.highs","title":"<code>highs</code>","text":"<p>Some helper functions for HiGHS (https://highs.dev/)</p> <p><code>pyomo</code> and <code>highspy</code> need to be installed, consider <code>pip install 'pytanis[all]'</code>.</p> <p>ToDo</p> <ul> <li>Introduce a function <code>check_model_vars</code> that checks the names of variables and sets to be alphanumeric   before reading in a solution in <code>set_solution_from_file</code>.</li> </ul>"},{"location":"reference/pytanis/highs/#pytanis.highs.read_sol_file","title":"<code>read_sol_file(file_name: str) -&gt; Iterator[tuple[str, float]]</code>","text":"<p>Read a solution file from HiGHS solver with default output style</p> <p>We assume here that your variable names are alphanumeric!</p> <p>No underscores, no dashes, etc.!</p> Source code in <code>src/pytanis/highs.py</code> <pre><code>def read_sol_file(file_name: str) -&gt; Iterator[tuple[str, float]]:\n    \"\"\"Read a solution file from HiGHS solver with default output style\n\n    Attention: We assume here that your variable names are alphanumeric!\n               No underscores, no dashes, etc.!\n    \"\"\"\n    line_re = re.compile(r'(\\w+)(?:\\((\\w+)\\))?(_binary_indicator_var)? ([.\\w-]+)')\n\n    with open(file_name, encoding='utf8') as fh:\n        while True:\n            line = fh.readline()\n            if line.startswith('# Columns'):\n                break\n        for line in fh.readlines():\n            if line.startswith('#'):\n                break\n            if (match_obj := line_re.match(line.strip())) is None:\n                msg = f'Could not interpret line: {line}'\n                raise RuntimeError(msg)\n            else:\n                var_name, idx, binary, val = match_obj.groups()\n            val = float(val)\n            binary = binary.replace('_', '.', 1) if binary else ''\n\n            if idx is None:\n                yield f'{var_name}{binary}', val\n            else:\n                idx = idx.replace('_', ',')\n                yield f'{var_name}[{idx}]{binary}', val\n</code></pre>"},{"location":"reference/pytanis/highs/#pytanis.highs.set_solution_from_file","title":"<code>set_solution_from_file(model: ConcreteModel, file_name: str)</code>","text":"<p>Given a HiGHS solution file set the variables of a Pyomo model accordingly.</p> <p>This is a workaround to set a Pyomo model's variables to the solution from a HiGHS solution file.</p> Source code in <code>src/pytanis/highs.py</code> <pre><code>def set_solution_from_file(model: ConcreteModel, file_name: str):\n    \"\"\"Given a HiGHS solution file set the variables of a Pyomo model accordingly.\n\n    This is a workaround to set a Pyomo model's variables to the solution\n    from a HiGHS solution file.\n    \"\"\"\n    # just to initialize we read it in using HiGHS. The result is incorrect though,\n    # as the order of variables is mixed up quite often. We fix this below!\n    opt = Highs()\n    opt.set_instance(model)\n    opt._solver_model.readSolution(file_name, 0)\n    opt._sol = opt._solver_model.getSolution()\n    opt.load_vars()\n\n    # read the actual mapping of the variable names to the values\n    file_sol = dict(read_sol_file(file_name))\n\n    # overwrite the values of the variables again using the symbolic names from the file\n    for v, ref_info in opt._referenced_variables.items():\n        using_cons, using_sos, using_obj = ref_info\n        if using_cons or using_sos or (using_obj is not None):\n            var = opt._vars[v][0]\n            var.set_value(file_sol[var.name], skip_validation=True)\n</code></pre>"},{"location":"reference/pytanis/review/","title":"Review","text":""},{"location":"reference/pytanis/review/#pytanis.review","title":"<code>review</code>","text":"<p>Tools related to assigning proposals to reviewers</p> <p>In Pretalx assignments can be done in two directions:</p> <ol> <li>Assign proposals to reviewers</li> <li>Assign reviewers to proposals</li> </ol> <p>We will always assume direction 1. in this file when we talk about an assignment. So in Operation Research-speak, resources get assigned tasks, not the other way around. The time needed for the task of reviewing a proposal is quite homogeneous while the number of reviews a single reviewer may highly vary. Also, we will rather use the name submission instead of proposal as this also reflects the naming of the Pretalx API.</p> <p>We follow the convention over configuration principle here and thus check out the <code>Col</code> class for the naming of columns.</p>"},{"location":"reference/pytanis/review/#pytanis.review.Col","title":"<code>Col</code>","text":"<p>Additional conventions used for reviews</p>"},{"location":"reference/pytanis/review/#pytanis.review.Col.address_as","title":"<code>address_as = 'Address as'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/review/#pytanis.review.Col.all_proposals","title":"<code>all_proposals = 'All Proposals'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/review/#pytanis.review.Col.committee_contact","title":"<code>committee_contact = 'Committee Contact'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/review/#pytanis.review.Col.committee_member","title":"<code>committee_member = 'Committee Member'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/review/#pytanis.review.Col.curr_assignments","title":"<code>curr_assignments = 'Current Assignments'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/review/#pytanis.review.Col.done_nreviews","title":"<code>done_nreviews = 'Done #Reviews'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/review/#pytanis.review.Col.nassignments","title":"<code>nassignments = '#Assignments'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/review/#pytanis.review.Col.nvotes","title":"<code>nvotes = '#Votes'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/review/#pytanis.review.Col.pretalx_activated","title":"<code>pretalx_activated = 'Pretalx activated'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/review/#pytanis.review.Col.rem_nreviews","title":"<code>rem_nreviews = 'Remaining #Reviews'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/review/#pytanis.review.Col.target_nreviews","title":"<code>target_nreviews = 'Target #Reviews'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/review/#pytanis.review.Col.track_prefs","title":"<code>track_prefs = 'Track Preferences'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/review/#pytanis.review.Col.vote_score","title":"<code>vote_score = 'Vote Score'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/review/#pytanis.review.read_assignment_as_df","title":"<code>read_assignment_as_df(file_path: Path) -&gt; pd.DataFrame</code>","text":"<p>Reads an assignment and returns a dataframe.</p> Source code in <code>src/pytanis/review.py</code> <pre><code>def read_assignment_as_df(file_path: Path) -&gt; pd.DataFrame:\n    \"\"\"Reads an assignment and returns a dataframe.\"\"\"\n    with open(file_path, encoding='utf8') as fh:\n        curr_assign = json.load(fh)\n    df = pd.DataFrame({k: [v] for k, v in curr_assign.items()})\n    df = df.T.rename_axis(index=Col.email).rename(columns={0: Col.curr_assignments}).reset_index()\n    return df\n</code></pre>"},{"location":"reference/pytanis/review/#pytanis.review.save_assignments_as_json","title":"<code>save_assignments_as_json(df: pd.DataFrame, file_path: Path | str) -&gt; None</code>","text":"<p>Save the dataframe as proposal assignment JSON file.</p> <p>We expect <code>df</code> to have the columns <code>Col.email</code> and <code>Col.curr_assignments</code>.</p> Source code in <code>src/pytanis/review.py</code> <pre><code>def save_assignments_as_json(df: pd.DataFrame, file_path: Path | str) -&gt; None:\n    \"\"\"Save the dataframe as proposal assignment JSON file.\n\n    We expect `df` to have the columns `Col.email` and `Col.curr_assignments`.\n    \"\"\"\n    if df[Col.email].duplicated().any():\n        non_unique_mails = df[Col.email][df[Col.email].duplicated(keep=False)].unique().tolist()\n        msg = f'Non-unique emails found in the dataframe: {\", \".join(non_unique_mails)}'\n        raise ValueError(msg)\n    file_path = Path(file_path)\n    df = df.loc[:, [Col.email, Col.curr_assignments]]\n    json_dct = json.loads(df.set_index(Col.email).to_json())[Col.curr_assignments]\n    # prettify the json string for human-edit-ability if reviewers need to be dropped later\n    json_str = json.dumps(json_dct).replace('{', '{\\n').replace('], ', '],\\n').replace(']}', ']\\n}')\n    with open(file_path, 'w', encoding='utf8') as fh:\n        fh.write(json_str)\n</code></pre>"},{"location":"reference/pytanis/utils/","title":"Utils","text":""},{"location":"reference/pytanis/utils/#pytanis.utils","title":"<code>utils</code>","text":"<p>Additional utilities</p>"},{"location":"reference/pytanis/utils/#pytanis.utils.RT","title":"<code>RT = TypeVar('RT')</code>  <code>module-attribute</code>","text":""},{"location":"reference/pytanis/utils/#pytanis.utils.implode","title":"<code>implode(df: pd.DataFrame, cols: str | list[str]) -&gt; pd.DataFrame</code>","text":"<p>The inverse of Pandas' explode</p> Source code in <code>src/pytanis/utils.py</code> <pre><code>def implode(df: pd.DataFrame, cols: str | list[str]) -&gt; pd.DataFrame:\n    \"\"\"The inverse of Pandas' explode\"\"\"\n    if not isinstance(cols, list):\n        cols = [cols]\n    orig_cols = df.columns\n    grp_cols = [col for col in df.columns if col not in cols]\n    df = df.groupby(grp_cols, group_keys=True, dropna=False).aggregate({col: lambda x: x.tolist() for col in cols})\n    df.reset_index(inplace=True)\n    df = df.loc[:, list(orig_cols)]\n    return df\n</code></pre>"},{"location":"reference/pytanis/utils/#pytanis.utils.pretty_timedelta","title":"<code>pretty_timedelta(seconds: int) -&gt; str</code>","text":"<p>Converts timedelta in seconds to human-readable string</p> <p>Parameters:</p> Name Type Description Default <code>seconds</code> <code>int</code> <p>time delta in seconds</p> required <p>Returns:</p> Type Description <code>str</code> <p>timedelta as pretty string</p> Source code in <code>src/pytanis/utils.py</code> <pre><code>def pretty_timedelta(seconds: int) -&gt; str:\n    \"\"\"Converts timedelta in seconds to human-readable string\n\n    Args:\n        seconds: time delta in seconds\n\n    Returns:\n        timedelta as pretty string\n    \"\"\"\n    sign = '-' if seconds &lt; 0 else ''\n    seconds = abs(int(seconds))\n    days, seconds = divmod(seconds, 86400)\n    hours, seconds = divmod(seconds, 3600)\n    minutes, seconds = divmod(seconds, 60)\n    if days &gt; 0:\n        return f'{sign}{days}d{hours}h{minutes}m{seconds}s'\n    elif hours &gt; 0:\n        return f'{sign}{hours}h{minutes}m{seconds}s'\n    elif minutes &gt; 0:\n        return f'{sign}{minutes}m{seconds}s'\n    else:\n        return f'{sign}{seconds}s'\n</code></pre>"},{"location":"reference/pytanis/utils/#pytanis.utils.rm_keys","title":"<code>rm_keys(keys: Any | list[Any], dct: dict[Any, Any]) -&gt; dict[Any, Any]</code>","text":"<p>Return a copy with keys removed from dictionary</p> Source code in <code>src/pytanis/utils.py</code> <pre><code>def rm_keys(\n    keys: Any | list[Any],\n    dct: dict[Any, Any],\n) -&gt; dict[Any, Any]:\n    \"\"\"Return a copy with keys removed from dictionary\"\"\"\n    if not isinstance(keys, list):\n        keys = [keys]\n    return {k: v for k, v in dct.items() if k not in keys}\n</code></pre>"},{"location":"reference/pytanis/utils/#pytanis.utils.throttle","title":"<code>throttle(calls: int, seconds: int = 1) -&gt; Callable[[Callable[..., RT]], Callable[..., RT]]</code>","text":"<p>Decorator for throttling a function to number of calls per seconds</p> <p>Parameters:</p> Name Type Description Default <code>calls</code> <code>int</code> <p>number of calls per interval</p> required <code>seconds</code> <code>int</code> <p>number of seconds in interval</p> <code>1</code> <p>Returns:</p> Type Description <code>Callable[[Callable[..., RT]], Callable[..., RT]]</code> <p>wrapped function</p> Source code in <code>src/pytanis/utils.py</code> <pre><code>def throttle(calls: int, seconds: int = 1) -&gt; Callable[[Callable[..., RT]], Callable[..., RT]]:\n    \"\"\"Decorator for throttling a function to number of calls per seconds\n\n    Args:\n        calls: number of calls per interval\n        seconds: number of seconds in interval\n\n    Returns:\n        wrapped function\n    \"\"\"\n    if not isinstance(calls, int):\n        msg = 'number of calls must be integer'\n        raise ValueError(msg)\n    if not isinstance(seconds, int):\n        msg = 'number of seconds must be integer'\n        raise ValueError(msg)\n\n    def decorator(func: Callable[..., RT]) -&gt; Callable[..., RT]:\n        # keeps track of the last calls\n        last_calls: list[float] = []\n        lock = threading.Lock()\n\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs) -&gt; RT:\n            nonlocal last_calls\n            with lock:\n                curr_time = time.time()\n                # Remove old calls\n                last_calls = [call for call in last_calls if call &gt; curr_time - seconds]\n\n                if len(last_calls) &gt;= calls:\n                    sleep_time = last_calls[0] + seconds - curr_time\n                    logger = get_logger()\n                    logger.debug('stalling call', func=func.__name__, secs=sleep_time)\n                    time.sleep(sleep_time)\n\n                resp = func(*args, **kwargs)\n                last_calls.append(time.time())\n                return resp\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"reference/pytanis/communication/","title":"Communication","text":""},{"location":"reference/pytanis/communication/#pytanis.communication","title":"<code>communication</code>","text":"<p>Communication abstraction layer for Pytanis</p> <p>This module provides abstract base classes and implementations for sending emails and managing support tickets through various providers.</p>"},{"location":"reference/pytanis/communication/#pytanis.communication.__all__","title":"<code>__all__ = ['BaseMailClient', 'BaseTicketClient', 'EmailMessage', 'Ticket', 'TicketComment']</code>  <code>module-attribute</code>","text":""},{"location":"reference/pytanis/communication/#pytanis.communication.BaseMailClient","title":"<code>BaseMailClient</code>","text":"<p>Abstract base class for email clients</p> <p>This class defines the interface for sending emails through various providers (e.g., SMTP, Mailgun, SendGrid, etc.).</p>"},{"location":"reference/pytanis/communication/#pytanis.communication.BaseMailClient.send_bulk_emails","title":"<code>send_bulk_emails(messages: list[EmailMessage], rate_limit: int | None = None) -&gt; list[str | None]</code>  <code>abstractmethod</code>","text":"<p>Send multiple email messages</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>list[EmailMessage]</code> <p>List of email messages to send</p> required <code>rate_limit</code> <code>int | None</code> <p>Maximum emails per second (None for no limit)</p> <code>None</code> <p>Returns:</p> Type Description <code>list[str | None]</code> <p>List of message IDs (None for failures)</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If there's an error sending emails</p> Source code in <code>src/pytanis/communication/base.py</code> <pre><code>@abstractmethod\ndef send_bulk_emails(self, messages: list[EmailMessage], rate_limit: int | None = None) -&gt; list[str | None]:\n    \"\"\"Send multiple email messages\n\n    Args:\n        messages: List of email messages to send\n        rate_limit: Maximum emails per second (None for no limit)\n\n    Returns:\n        List of message IDs (None for failures)\n\n    Raises:\n        IOError: If there's an error sending emails\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/pytanis/communication/#pytanis.communication.BaseMailClient.send_email","title":"<code>send_email(message: EmailMessage) -&gt; str | None</code>  <code>abstractmethod</code>","text":"<p>Send an email message</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>EmailMessage</code> <p>The email message to send</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>Message ID if available, None otherwise</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If there's an error sending the email</p> Source code in <code>src/pytanis/communication/base.py</code> <pre><code>@abstractmethod\ndef send_email(self, message: EmailMessage) -&gt; str | None:\n    \"\"\"Send an email message\n\n    Args:\n        message: The email message to send\n\n    Returns:\n        Message ID if available, None otherwise\n\n    Raises:\n        IOError: If there's an error sending the email\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/pytanis/communication/#pytanis.communication.BaseMailClient.validate_email","title":"<code>validate_email(email: str) -&gt; bool</code>  <code>staticmethod</code>","text":"<p>Validate an email address format</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Email address to validate</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>src/pytanis/communication/base.py</code> <pre><code>@staticmethod\ndef validate_email(email: str) -&gt; bool:\n    \"\"\"Validate an email address format\n\n    Args:\n        email: Email address to validate\n\n    Returns:\n        True if valid, False otherwise\n    \"\"\"\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    return bool(re.match(pattern, email))\n</code></pre>"},{"location":"reference/pytanis/communication/#pytanis.communication.BaseTicketClient","title":"<code>BaseTicketClient</code>","text":"<p>Abstract base class for support ticket clients</p> <p>This class defines the interface for managing support tickets through various providers (e.g., HelpDesk, Zendesk, Freshdesk, etc.).</p>"},{"location":"reference/pytanis/communication/#pytanis.communication.BaseTicketClient.add_comment","title":"<code>add_comment(comment: TicketComment) -&gt; str</code>  <code>abstractmethod</code>","text":"<p>Add a comment to a ticket</p> <p>Parameters:</p> Name Type Description Default <code>comment</code> <code>TicketComment</code> <p>The comment to add</p> required <p>Returns:</p> Type Description <code>str</code> <p>The comment ID</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the ticket does not exist</p> <code>IOError</code> <p>If there's an error adding the comment</p> Source code in <code>src/pytanis/communication/base.py</code> <pre><code>@abstractmethod\ndef add_comment(self, comment: TicketComment) -&gt; str:\n    \"\"\"Add a comment to a ticket\n\n    Args:\n        comment: The comment to add\n\n    Returns:\n        The comment ID\n\n    Raises:\n        KeyError: If the ticket does not exist\n        IOError: If there's an error adding the comment\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/pytanis/communication/#pytanis.communication.BaseTicketClient.close_ticket","title":"<code>close_ticket(ticket_id: str) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Close a ticket</p> <p>Parameters:</p> Name Type Description Default <code>ticket_id</code> <code>str</code> <p>The ticket ID</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the ticket does not exist</p> <code>IOError</code> <p>If there's an error closing the ticket</p> Source code in <code>src/pytanis/communication/base.py</code> <pre><code>@abstractmethod\ndef close_ticket(self, ticket_id: str) -&gt; None:\n    \"\"\"Close a ticket\n\n    Args:\n        ticket_id: The ticket ID\n\n    Raises:\n        KeyError: If the ticket does not exist\n        IOError: If there's an error closing the ticket\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/pytanis/communication/#pytanis.communication.BaseTicketClient.create_ticket","title":"<code>create_ticket(ticket: Ticket) -&gt; str</code>  <code>abstractmethod</code>","text":"<p>Create a new support ticket</p> <p>Parameters:</p> Name Type Description Default <code>ticket</code> <code>Ticket</code> <p>The ticket to create</p> required <p>Returns:</p> Type Description <code>str</code> <p>The created ticket ID</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If there's an error creating the ticket</p> Source code in <code>src/pytanis/communication/base.py</code> <pre><code>@abstractmethod\ndef create_ticket(self, ticket: Ticket) -&gt; str:\n    \"\"\"Create a new support ticket\n\n    Args:\n        ticket: The ticket to create\n\n    Returns:\n        The created ticket ID\n\n    Raises:\n        IOError: If there's an error creating the ticket\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/pytanis/communication/#pytanis.communication.BaseTicketClient.get_ticket","title":"<code>get_ticket(ticket_id: str) -&gt; Ticket</code>  <code>abstractmethod</code>","text":"<p>Get a ticket by ID</p> <p>Parameters:</p> Name Type Description Default <code>ticket_id</code> <code>str</code> <p>The ticket ID</p> required <p>Returns:</p> Type Description <code>Ticket</code> <p>The ticket details</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the ticket does not exist</p> <code>IOError</code> <p>If there's an error retrieving the ticket</p> Source code in <code>src/pytanis/communication/base.py</code> <pre><code>@abstractmethod\ndef get_ticket(self, ticket_id: str) -&gt; Ticket:\n    \"\"\"Get a ticket by ID\n\n    Args:\n        ticket_id: The ticket ID\n\n    Returns:\n        The ticket details\n\n    Raises:\n        KeyError: If the ticket does not exist\n        IOError: If there's an error retrieving the ticket\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/pytanis/communication/#pytanis.communication.BaseTicketClient.list_tickets","title":"<code>list_tickets(status: str | None = None, requester_email: str | None = None, limit: int = 100) -&gt; list[Ticket]</code>  <code>abstractmethod</code>","text":"<p>List tickets with optional filtering</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>str | None</code> <p>Filter by status (e.g., 'open', 'closed')</p> <code>None</code> <code>requester_email</code> <code>str | None</code> <p>Filter by requester email</p> <code>None</code> <code>limit</code> <code>int</code> <p>Maximum number of tickets to return</p> <code>100</code> <p>Returns:</p> Type Description <code>list[Ticket]</code> <p>List of tickets matching the criteria</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If there's an error listing tickets</p> Source code in <code>src/pytanis/communication/base.py</code> <pre><code>@abstractmethod\ndef list_tickets(\n    self, status: str | None = None, requester_email: str | None = None, limit: int = 100\n) -&gt; list[Ticket]:\n    \"\"\"List tickets with optional filtering\n\n    Args:\n        status: Filter by status (e.g., 'open', 'closed')\n        requester_email: Filter by requester email\n        limit: Maximum number of tickets to return\n\n    Returns:\n        List of tickets matching the criteria\n\n    Raises:\n        IOError: If there's an error listing tickets\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/pytanis/communication/#pytanis.communication.BaseTicketClient.update_ticket","title":"<code>update_ticket(ticket_id: str, updates: dict[str, Any]) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Update a ticket</p> <p>Parameters:</p> Name Type Description Default <code>ticket_id</code> <code>str</code> <p>The ticket ID</p> required <code>updates</code> <code>dict[str, Any]</code> <p>Dictionary of fields to update</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the ticket does not exist</p> <code>IOError</code> <p>If there's an error updating the ticket</p> Source code in <code>src/pytanis/communication/base.py</code> <pre><code>@abstractmethod\ndef update_ticket(self, ticket_id: str, updates: dict[str, Any]) -&gt; None:\n    \"\"\"Update a ticket\n\n    Args:\n        ticket_id: The ticket ID\n        updates: Dictionary of fields to update\n\n    Raises:\n        KeyError: If the ticket does not exist\n        IOError: If there's an error updating the ticket\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/pytanis/communication/#pytanis.communication.EmailMessage","title":"<code>EmailMessage(to: list[str], subject: str, body: str, html_body: str | None = None, cc: list[str] | None = None, bcc: list[str] | None = None, reply_to: str | None = None, attachments: list[tuple[str, bytes]] | None = None, headers: dict[str, str] | None = None, metadata: dict[str, Any] | None = None)</code>  <code>dataclass</code>","text":"<p>Standard email message representation</p>"},{"location":"reference/pytanis/communication/#pytanis.communication.EmailMessage.attachments","title":"<code>attachments: list[tuple[str, bytes]] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/#pytanis.communication.EmailMessage.bcc","title":"<code>bcc: list[str] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/#pytanis.communication.EmailMessage.body","title":"<code>body: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/#pytanis.communication.EmailMessage.cc","title":"<code>cc: list[str] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/#pytanis.communication.EmailMessage.headers","title":"<code>headers: dict[str, str] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/#pytanis.communication.EmailMessage.html_body","title":"<code>html_body: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/#pytanis.communication.EmailMessage.metadata","title":"<code>metadata: dict[str, Any] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/#pytanis.communication.EmailMessage.reply_to","title":"<code>reply_to: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/#pytanis.communication.EmailMessage.subject","title":"<code>subject: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/#pytanis.communication.EmailMessage.to","title":"<code>to: list[str]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/#pytanis.communication.Ticket","title":"<code>Ticket(id: str | None, subject: str, description: str, requester_email: str, requester_name: str | None = None, status: str = 'open', priority: str = 'normal', tags: list[str] | None = None, custom_fields: dict[str, Any] | None = None)</code>  <code>dataclass</code>","text":"<p>Support ticket representation</p>"},{"location":"reference/pytanis/communication/#pytanis.communication.Ticket.custom_fields","title":"<code>custom_fields: dict[str, Any] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/#pytanis.communication.Ticket.description","title":"<code>description: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/#pytanis.communication.Ticket.id","title":"<code>id: str | None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/#pytanis.communication.Ticket.priority","title":"<code>priority: str = 'normal'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/#pytanis.communication.Ticket.requester_email","title":"<code>requester_email: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/#pytanis.communication.Ticket.requester_name","title":"<code>requester_name: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/#pytanis.communication.Ticket.status","title":"<code>status: str = 'open'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/#pytanis.communication.Ticket.subject","title":"<code>subject: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/#pytanis.communication.Ticket.tags","title":"<code>tags: list[str] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/#pytanis.communication.TicketComment","title":"<code>TicketComment(ticket_id: str, body: str, author_email: str, author_name: str | None = None, public: bool = True, attachments: list[tuple[str, bytes]] | None = None)</code>  <code>dataclass</code>","text":"<p>Comment on a support ticket</p>"},{"location":"reference/pytanis/communication/#pytanis.communication.TicketComment.attachments","title":"<code>attachments: list[tuple[str, bytes]] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/#pytanis.communication.TicketComment.author_email","title":"<code>author_email: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/#pytanis.communication.TicketComment.author_name","title":"<code>author_name: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/#pytanis.communication.TicketComment.body","title":"<code>body: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/#pytanis.communication.TicketComment.public","title":"<code>public: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/#pytanis.communication.TicketComment.ticket_id","title":"<code>ticket_id: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/base/","title":"Base","text":""},{"location":"reference/pytanis/communication/base/#pytanis.communication.base","title":"<code>base</code>","text":"<p>Base classes for communication abstraction</p>"},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.BaseMailClient","title":"<code>BaseMailClient</code>","text":"<p>Abstract base class for email clients</p> <p>This class defines the interface for sending emails through various providers (e.g., SMTP, Mailgun, SendGrid, etc.).</p>"},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.BaseMailClient.send_bulk_emails","title":"<code>send_bulk_emails(messages: list[EmailMessage], rate_limit: int | None = None) -&gt; list[str | None]</code>  <code>abstractmethod</code>","text":"<p>Send multiple email messages</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>list[EmailMessage]</code> <p>List of email messages to send</p> required <code>rate_limit</code> <code>int | None</code> <p>Maximum emails per second (None for no limit)</p> <code>None</code> <p>Returns:</p> Type Description <code>list[str | None]</code> <p>List of message IDs (None for failures)</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If there's an error sending emails</p> Source code in <code>src/pytanis/communication/base.py</code> <pre><code>@abstractmethod\ndef send_bulk_emails(self, messages: list[EmailMessage], rate_limit: int | None = None) -&gt; list[str | None]:\n    \"\"\"Send multiple email messages\n\n    Args:\n        messages: List of email messages to send\n        rate_limit: Maximum emails per second (None for no limit)\n\n    Returns:\n        List of message IDs (None for failures)\n\n    Raises:\n        IOError: If there's an error sending emails\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.BaseMailClient.send_email","title":"<code>send_email(message: EmailMessage) -&gt; str | None</code>  <code>abstractmethod</code>","text":"<p>Send an email message</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>EmailMessage</code> <p>The email message to send</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>Message ID if available, None otherwise</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If there's an error sending the email</p> Source code in <code>src/pytanis/communication/base.py</code> <pre><code>@abstractmethod\ndef send_email(self, message: EmailMessage) -&gt; str | None:\n    \"\"\"Send an email message\n\n    Args:\n        message: The email message to send\n\n    Returns:\n        Message ID if available, None otherwise\n\n    Raises:\n        IOError: If there's an error sending the email\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.BaseMailClient.validate_email","title":"<code>validate_email(email: str) -&gt; bool</code>  <code>staticmethod</code>","text":"<p>Validate an email address format</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Email address to validate</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>src/pytanis/communication/base.py</code> <pre><code>@staticmethod\ndef validate_email(email: str) -&gt; bool:\n    \"\"\"Validate an email address format\n\n    Args:\n        email: Email address to validate\n\n    Returns:\n        True if valid, False otherwise\n    \"\"\"\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    return bool(re.match(pattern, email))\n</code></pre>"},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.BaseTicketClient","title":"<code>BaseTicketClient</code>","text":"<p>Abstract base class for support ticket clients</p> <p>This class defines the interface for managing support tickets through various providers (e.g., HelpDesk, Zendesk, Freshdesk, etc.).</p>"},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.BaseTicketClient.add_comment","title":"<code>add_comment(comment: TicketComment) -&gt; str</code>  <code>abstractmethod</code>","text":"<p>Add a comment to a ticket</p> <p>Parameters:</p> Name Type Description Default <code>comment</code> <code>TicketComment</code> <p>The comment to add</p> required <p>Returns:</p> Type Description <code>str</code> <p>The comment ID</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the ticket does not exist</p> <code>IOError</code> <p>If there's an error adding the comment</p> Source code in <code>src/pytanis/communication/base.py</code> <pre><code>@abstractmethod\ndef add_comment(self, comment: TicketComment) -&gt; str:\n    \"\"\"Add a comment to a ticket\n\n    Args:\n        comment: The comment to add\n\n    Returns:\n        The comment ID\n\n    Raises:\n        KeyError: If the ticket does not exist\n        IOError: If there's an error adding the comment\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.BaseTicketClient.close_ticket","title":"<code>close_ticket(ticket_id: str) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Close a ticket</p> <p>Parameters:</p> Name Type Description Default <code>ticket_id</code> <code>str</code> <p>The ticket ID</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the ticket does not exist</p> <code>IOError</code> <p>If there's an error closing the ticket</p> Source code in <code>src/pytanis/communication/base.py</code> <pre><code>@abstractmethod\ndef close_ticket(self, ticket_id: str) -&gt; None:\n    \"\"\"Close a ticket\n\n    Args:\n        ticket_id: The ticket ID\n\n    Raises:\n        KeyError: If the ticket does not exist\n        IOError: If there's an error closing the ticket\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.BaseTicketClient.create_ticket","title":"<code>create_ticket(ticket: Ticket) -&gt; str</code>  <code>abstractmethod</code>","text":"<p>Create a new support ticket</p> <p>Parameters:</p> Name Type Description Default <code>ticket</code> <code>Ticket</code> <p>The ticket to create</p> required <p>Returns:</p> Type Description <code>str</code> <p>The created ticket ID</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If there's an error creating the ticket</p> Source code in <code>src/pytanis/communication/base.py</code> <pre><code>@abstractmethod\ndef create_ticket(self, ticket: Ticket) -&gt; str:\n    \"\"\"Create a new support ticket\n\n    Args:\n        ticket: The ticket to create\n\n    Returns:\n        The created ticket ID\n\n    Raises:\n        IOError: If there's an error creating the ticket\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.BaseTicketClient.get_ticket","title":"<code>get_ticket(ticket_id: str) -&gt; Ticket</code>  <code>abstractmethod</code>","text":"<p>Get a ticket by ID</p> <p>Parameters:</p> Name Type Description Default <code>ticket_id</code> <code>str</code> <p>The ticket ID</p> required <p>Returns:</p> Type Description <code>Ticket</code> <p>The ticket details</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the ticket does not exist</p> <code>IOError</code> <p>If there's an error retrieving the ticket</p> Source code in <code>src/pytanis/communication/base.py</code> <pre><code>@abstractmethod\ndef get_ticket(self, ticket_id: str) -&gt; Ticket:\n    \"\"\"Get a ticket by ID\n\n    Args:\n        ticket_id: The ticket ID\n\n    Returns:\n        The ticket details\n\n    Raises:\n        KeyError: If the ticket does not exist\n        IOError: If there's an error retrieving the ticket\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.BaseTicketClient.list_tickets","title":"<code>list_tickets(status: str | None = None, requester_email: str | None = None, limit: int = 100) -&gt; list[Ticket]</code>  <code>abstractmethod</code>","text":"<p>List tickets with optional filtering</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>str | None</code> <p>Filter by status (e.g., 'open', 'closed')</p> <code>None</code> <code>requester_email</code> <code>str | None</code> <p>Filter by requester email</p> <code>None</code> <code>limit</code> <code>int</code> <p>Maximum number of tickets to return</p> <code>100</code> <p>Returns:</p> Type Description <code>list[Ticket]</code> <p>List of tickets matching the criteria</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If there's an error listing tickets</p> Source code in <code>src/pytanis/communication/base.py</code> <pre><code>@abstractmethod\ndef list_tickets(\n    self, status: str | None = None, requester_email: str | None = None, limit: int = 100\n) -&gt; list[Ticket]:\n    \"\"\"List tickets with optional filtering\n\n    Args:\n        status: Filter by status (e.g., 'open', 'closed')\n        requester_email: Filter by requester email\n        limit: Maximum number of tickets to return\n\n    Returns:\n        List of tickets matching the criteria\n\n    Raises:\n        IOError: If there's an error listing tickets\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.BaseTicketClient.update_ticket","title":"<code>update_ticket(ticket_id: str, updates: dict[str, Any]) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Update a ticket</p> <p>Parameters:</p> Name Type Description Default <code>ticket_id</code> <code>str</code> <p>The ticket ID</p> required <code>updates</code> <code>dict[str, Any]</code> <p>Dictionary of fields to update</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the ticket does not exist</p> <code>IOError</code> <p>If there's an error updating the ticket</p> Source code in <code>src/pytanis/communication/base.py</code> <pre><code>@abstractmethod\ndef update_ticket(self, ticket_id: str, updates: dict[str, Any]) -&gt; None:\n    \"\"\"Update a ticket\n\n    Args:\n        ticket_id: The ticket ID\n        updates: Dictionary of fields to update\n\n    Raises:\n        KeyError: If the ticket does not exist\n        IOError: If there's an error updating the ticket\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.EmailMessage","title":"<code>EmailMessage(to: list[str], subject: str, body: str, html_body: str | None = None, cc: list[str] | None = None, bcc: list[str] | None = None, reply_to: str | None = None, attachments: list[tuple[str, bytes]] | None = None, headers: dict[str, str] | None = None, metadata: dict[str, Any] | None = None)</code>  <code>dataclass</code>","text":"<p>Standard email message representation</p>"},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.EmailMessage.attachments","title":"<code>attachments: list[tuple[str, bytes]] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.EmailMessage.bcc","title":"<code>bcc: list[str] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.EmailMessage.body","title":"<code>body: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.EmailMessage.cc","title":"<code>cc: list[str] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.EmailMessage.headers","title":"<code>headers: dict[str, str] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.EmailMessage.html_body","title":"<code>html_body: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.EmailMessage.metadata","title":"<code>metadata: dict[str, Any] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.EmailMessage.reply_to","title":"<code>reply_to: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.EmailMessage.subject","title":"<code>subject: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.EmailMessage.to","title":"<code>to: list[str]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.Ticket","title":"<code>Ticket(id: str | None, subject: str, description: str, requester_email: str, requester_name: str | None = None, status: str = 'open', priority: str = 'normal', tags: list[str] | None = None, custom_fields: dict[str, Any] | None = None)</code>  <code>dataclass</code>","text":"<p>Support ticket representation</p>"},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.Ticket.custom_fields","title":"<code>custom_fields: dict[str, Any] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.Ticket.description","title":"<code>description: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.Ticket.id","title":"<code>id: str | None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.Ticket.priority","title":"<code>priority: str = 'normal'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.Ticket.requester_email","title":"<code>requester_email: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.Ticket.requester_name","title":"<code>requester_name: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.Ticket.status","title":"<code>status: str = 'open'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.Ticket.subject","title":"<code>subject: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.Ticket.tags","title":"<code>tags: list[str] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.TicketComment","title":"<code>TicketComment(ticket_id: str, body: str, author_email: str, author_name: str | None = None, public: bool = True, attachments: list[tuple[str, bytes]] | None = None)</code>  <code>dataclass</code>","text":"<p>Comment on a support ticket</p>"},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.TicketComment.attachments","title":"<code>attachments: list[tuple[str, bytes]] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.TicketComment.author_email","title":"<code>author_email: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.TicketComment.author_name","title":"<code>author_name: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.TicketComment.body","title":"<code>body: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.TicketComment.public","title":"<code>public: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/base/#pytanis.communication.base.TicketComment.ticket_id","title":"<code>ticket_id: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/communication/helpdesk_adapter/","title":"Helpdesk adapter","text":""},{"location":"reference/pytanis/communication/helpdesk_adapter/#pytanis.communication.helpdesk_adapter","title":"<code>helpdesk_adapter</code>","text":"<p>HelpDesk adapter for the communication abstraction</p>"},{"location":"reference/pytanis/communication/helpdesk_adapter/#pytanis.communication.helpdesk_adapter.HelpDeskMailAdapter","title":"<code>HelpDeskMailAdapter(config: Any = None)</code>","text":"<p>HelpDesk email client adapter</p> <p>This class wraps the existing HelpDesk mail functionality to provide a consistent interface with other email providers.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Any</code> <p>Configuration object (if None, will use get_cfg())</p> <code>None</code> Source code in <code>src/pytanis/communication/helpdesk_adapter.py</code> <pre><code>def __init__(self, config: Any = None):\n    \"\"\"Initialize the HelpDesk mail adapter\n\n    Args:\n        config: Configuration object (if None, will use get_cfg())\n    \"\"\"\n    if config is None:\n        config = get_cfg()\n\n    # Create HelpDeskClient first, then pass it to MailClient\n    helpdesk_client = HelpDeskClient()\n    self._client = MailClient(helpdesk_client=helpdesk_client)\n    self._config = config\n</code></pre>"},{"location":"reference/pytanis/communication/helpdesk_adapter/#pytanis.communication.helpdesk_adapter.HelpDeskMailAdapter.send_bulk_emails","title":"<code>send_bulk_emails(messages: list[EmailMessage], rate_limit: int | None = None) -&gt; list[str | None]</code>","text":"<p>Send multiple email messages</p> Source code in <code>src/pytanis/communication/helpdesk_adapter.py</code> <pre><code>def send_bulk_emails(self, messages: list[EmailMessage], rate_limit: int | None = None) -&gt; list[str | None]:\n    \"\"\"Send multiple email messages\"\"\"\n    # The HelpDesk MailClient handles batching internally\n    # We'll create a single Mail object with all recipients for efficiency\n    try:\n        if not messages:\n            return []\n\n        all_recipients = []\n        # Use the first message as template, assuming all have same content\n        template_message = messages[0]\n\n        for message in messages:\n            if not message.to:\n                continue\n\n            for email in message.to:\n                recipient = Recipient(\n                    name=email.split('@')[0],  # Use email prefix as name\n                    email=email,\n                )\n                all_recipients.append(recipient)\n\n        if not all_recipients:\n            return []\n\n        # Get team_id and agent_id from config (with defaults)\n        team_id = getattr(self._config, 'helpdesk_team_id', 'default_team')\n        agent_id = getattr(self._config, 'helpdesk_agent_id', 'default_agent')\n\n        # Create a single mail object with all recipients\n        mail = Mail(\n            subject=template_message.subject,\n            text=template_message.body or template_message.html_body or '',\n            team_id=team_id,\n            agent_id=agent_id,\n            recipients=all_recipients,\n            status='solved',  # Default status\n        )\n\n        # Configure rate limiting if specified\n        if rate_limit:\n            self._client.batch_size = rate_limit\n\n        # Send emails (dry_run=False to actually send)\n        tickets, errors = self._client.send(mail, dry_run=False)\n\n        # Log any errors\n        if errors:\n            for recipient, error in errors:\n                _logger.error('Failed to send to recipient', recipient=recipient.email, error=str(error))\n\n        # Create result list matching input messages\n        results: list[str | None] = []\n        ticket_map = {ticket[0].email: ticket[1] for ticket in tickets if ticket[1]}\n\n        for message in messages:\n            if message.to and message.to[0] in ticket_map:\n                # Access ID via dict since Ticket model uses extra='allow'\n                ticket = ticket_map[message.to[0]]\n                ticket_dict = ticket.model_dump()\n                results.append(str(ticket_dict.get('ID', '')))\n            else:\n                results.append(None)\n\n        return results\n\n    except Exception as e:\n        msg = f'Error sending bulk emails via HelpDesk: {e}'\n        raise OSError(msg) from e\n</code></pre>"},{"location":"reference/pytanis/communication/helpdesk_adapter/#pytanis.communication.helpdesk_adapter.HelpDeskMailAdapter.send_email","title":"<code>send_email(message: EmailMessage) -&gt; str | None</code>","text":"<p>Send an email message using HelpDesk</p> Source code in <code>src/pytanis/communication/helpdesk_adapter.py</code> <pre><code>def send_email(self, message: EmailMessage) -&gt; str | None:\n    \"\"\"Send an email message using HelpDesk\"\"\"\n    try:\n        # Convert to HelpDesk format\n\n        if not message.to:\n            msg = 'No recipients specified'\n            raise ValueError(msg)\n\n        # Create recipient objects for all recipients\n        recipients = []\n        for email in message.to:\n            recipient = Recipient(\n                name=email.split('@')[0],  # Use email prefix as name\n                email=email,\n            )\n            recipients.append(recipient)\n\n        # Get team_id and agent_id from config (with defaults)\n        team_id = getattr(self._config, 'helpdesk_team_id', 'default_team')\n        agent_id = getattr(self._config, 'helpdesk_agent_id', 'default_agent')\n\n        # Create mail object with required fields\n        mail = Mail(\n            subject=message.subject,\n            text=message.body or message.html_body or '',\n            team_id=team_id,\n            agent_id=agent_id,\n            recipients=recipients,\n            status='solved',  # Default status\n        )\n\n        # Send email (dry_run=False to actually send)\n        tickets, errors = self._client.send(mail, dry_run=False)\n\n        # Log any errors\n        if errors:\n            for recipient, error in errors:\n                _logger.error('Failed to send to recipient', recipient=recipient.email, error=str(error))\n\n        # Handle CC recipients warning\n        if message.cc:\n            _logger.warning(\n                'HelpDesk adapter does not support CC recipients. CC recipients ignored.',\n                cc=message.cc,\n            )\n\n        # Return the first ticket ID if successful\n        if tickets and tickets[0][1]:\n            # Access ID via dict since Ticket model uses extra='allow'\n            ticket_dict = tickets[0][1].model_dump()\n            return str(ticket_dict.get('ID', ''))\n        return None\n\n    except Exception as e:\n        msg = f'Error sending email via HelpDesk: {e}'\n        raise OSError(msg) from e\n</code></pre>"},{"location":"reference/pytanis/communication/helpdesk_adapter/#pytanis.communication.helpdesk_adapter.HelpDeskTicketAdapter","title":"<code>HelpDeskTicketAdapter(config: Any = None)</code>","text":"<p>HelpDesk ticket client adapter</p> <p>This class wraps the existing HelpDesk client to provide a consistent interface with other ticket providers.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Any</code> <p>Configuration object (if None, will use get_cfg())</p> <code>None</code> Source code in <code>src/pytanis/communication/helpdesk_adapter.py</code> <pre><code>def __init__(self, config: Any = None):\n    \"\"\"Initialize the HelpDesk ticket adapter\n\n    Args:\n        config: Configuration object (if None, will use get_cfg())\n    \"\"\"\n\n    if config is None:\n        config = get_cfg()\n    self._client = HelpDeskClient()\n    self._config = config\n</code></pre>"},{"location":"reference/pytanis/communication/helpdesk_adapter/#pytanis.communication.helpdesk_adapter.HelpDeskTicketAdapter.add_comment","title":"<code>add_comment(comment: TicketComment) -&gt; str</code>","text":"<p>Add a comment to a ticket</p> Source code in <code>src/pytanis/communication/helpdesk_adapter.py</code> <pre><code>def add_comment(self, comment: TicketComment) -&gt; str:\n    \"\"\"Add a comment to a ticket\"\"\"\n    # HelpDesk client doesn't have an add_comment method in the current implementation\n    msg = 'HelpDesk adapter does not support adding comments yet'\n    raise NotImplementedError(msg)\n</code></pre>"},{"location":"reference/pytanis/communication/helpdesk_adapter/#pytanis.communication.helpdesk_adapter.HelpDeskTicketAdapter.close_ticket","title":"<code>close_ticket(ticket_id: str) -&gt; None</code>","text":"<p>Close a ticket</p> Source code in <code>src/pytanis/communication/helpdesk_adapter.py</code> <pre><code>def close_ticket(self, ticket_id: str) -&gt; None:\n    \"\"\"Close a ticket\"\"\"\n    # HelpDesk client doesn't have a close_ticket method in the current implementation\n    msg = 'HelpDesk adapter does not support closing tickets yet'\n    raise NotImplementedError(msg)\n</code></pre>"},{"location":"reference/pytanis/communication/helpdesk_adapter/#pytanis.communication.helpdesk_adapter.HelpDeskTicketAdapter.create_ticket","title":"<code>create_ticket(ticket: Ticket) -&gt; str</code>","text":"<p>Create a new support ticket</p> Source code in <code>src/pytanis/communication/helpdesk_adapter.py</code> <pre><code>def create_ticket(self, ticket: Ticket) -&gt; str:\n    \"\"\"Create a new support ticket\"\"\"\n    try:\n        # Create requester object\n        requester = Requester(\n            email=ticket.requester_email,\n            name=ticket.requester_name or ticket.requester_email.split('@')[0],\n        )\n\n        # Create message object\n        message = Message(text=ticket.description)\n\n        # Get team_id and agent_id from config (with defaults)\n        team_id = getattr(self._config, 'helpdesk_team_id', 'default_team')\n        agent_id = getattr(self._config, 'helpdesk_agent_id', 'default_agent')\n\n        # Create assignment if we have team and agent IDs\n        assignment = None\n        team_ids = None\n        if team_id and agent_id:\n            assignment = Assignment(\n                team=Id(ID=team_id),\n                agent=Id(ID=agent_id),\n            )\n            team_ids = [team_id]\n\n        # Convert to HelpDesk format\n        new_ticket = NewTicket(\n            subject=ticket.subject,\n            message=message,\n            requester=requester,\n            status=ticket.status or 'open',\n            assignment=assignment,\n            teamIDs=team_ids,\n        )\n\n        # Create ticket\n        result = self._client.create_ticket(new_ticket)\n\n        # Extract ticket ID from result\n        if isinstance(result, dict) and 'ID' in result:\n            return str(result['ID'])\n        return str(result)\n\n    except Exception as e:\n        msg = f'Error creating ticket: {e}'\n        raise OSError(msg) from e\n</code></pre>"},{"location":"reference/pytanis/communication/helpdesk_adapter/#pytanis.communication.helpdesk_adapter.HelpDeskTicketAdapter.get_ticket","title":"<code>get_ticket(ticket_id: str) -&gt; Ticket</code>","text":"<p>Get a ticket by ID</p> Source code in <code>src/pytanis/communication/helpdesk_adapter.py</code> <pre><code>def get_ticket(self, ticket_id: str) -&gt; Ticket:\n    \"\"\"Get a ticket by ID\"\"\"\n    # HelpDesk client doesn't have a get_ticket method in the current implementation\n    msg = 'HelpDesk adapter does not support getting tickets yet'\n    raise NotImplementedError(msg)\n</code></pre>"},{"location":"reference/pytanis/communication/helpdesk_adapter/#pytanis.communication.helpdesk_adapter.HelpDeskTicketAdapter.list_tickets","title":"<code>list_tickets(status: str | None = None, requester_email: str | None = None, limit: int = 100) -&gt; list[Ticket]</code>","text":"<p>List tickets with optional filtering</p> Source code in <code>src/pytanis/communication/helpdesk_adapter.py</code> <pre><code>def list_tickets(\n    self, status: str | None = None, requester_email: str | None = None, limit: int = 100\n) -&gt; list[Ticket]:\n    \"\"\"List tickets with optional filtering\"\"\"\n    # HelpDesk client doesn't have a list_tickets method in the current implementation\n    msg = 'HelpDesk adapter does not support listing tickets yet'\n    raise NotImplementedError(msg)\n</code></pre>"},{"location":"reference/pytanis/communication/helpdesk_adapter/#pytanis.communication.helpdesk_adapter.HelpDeskTicketAdapter.update_ticket","title":"<code>update_ticket(ticket_id: str, updates: dict[str, Any]) -&gt; None</code>","text":"<p>Update a ticket</p> Source code in <code>src/pytanis/communication/helpdesk_adapter.py</code> <pre><code>def update_ticket(self, ticket_id: str, updates: dict[str, Any]) -&gt; None:\n    \"\"\"Update a ticket\"\"\"\n    # HelpDesk client doesn't have an update_ticket method in the current implementation\n    msg = 'HelpDesk adapter does not support updating tickets yet'\n    raise NotImplementedError(msg)\n</code></pre>"},{"location":"reference/pytanis/communication/mailgun_adapter/","title":"Mailgun adapter","text":""},{"location":"reference/pytanis/communication/mailgun_adapter/#pytanis.communication.mailgun_adapter","title":"<code>mailgun_adapter</code>","text":"<p>Mailgun adapter for the communication abstraction</p>"},{"location":"reference/pytanis/communication/mailgun_adapter/#pytanis.communication.mailgun_adapter.MailgunAdapter","title":"<code>MailgunAdapter(config: Any = None)</code>","text":"<p>Mailgun email client adapter</p> <p>This class wraps the existing Mailgun functionality to provide a consistent interface with other email providers.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Any</code> <p>Configuration object (if None, will use get_cfg())</p> <code>None</code> Source code in <code>src/pytanis/communication/mailgun_adapter.py</code> <pre><code>def __init__(self, config: Any = None):\n    \"\"\"Initialize the Mailgun adapter\n\n    Args:\n        config: Configuration object (if None, will use get_cfg())\n    \"\"\"\n\n    if config is None:\n        config = get_cfg()\n    self._client = MailClient(config=config)\n    self._config = config\n</code></pre>"},{"location":"reference/pytanis/communication/mailgun_adapter/#pytanis.communication.mailgun_adapter.MailgunAdapter.send_bulk_emails","title":"<code>send_bulk_emails(messages: list[EmailMessage], rate_limit: int | None = None) -&gt; list[str | None]</code>","text":"<p>Send multiple email messages</p> <p>Note: This implementation sends emails individually as the Mailgun client handles batching internally based on its batch_size configuration.</p> Source code in <code>src/pytanis/communication/mailgun_adapter.py</code> <pre><code>def send_bulk_emails(self, messages: list[EmailMessage], rate_limit: int | None = None) -&gt; list[str | None]:\n    \"\"\"Send multiple email messages\n\n    Note: This implementation sends emails individually as the Mailgun client\n    handles batching internally based on its batch_size configuration.\n    \"\"\"\n    results = []\n\n    # If rate limit is specified, override the client's wait time\n    if rate_limit:\n        original_batch_size = self._client.batch_size\n        original_wait_time = self._client.wait_time\n        self._client.batch_size = 1  # Send one at a time\n        self._client.wait_time = int(1.0 / rate_limit)\n\n    try:\n        for i, message in enumerate(messages):\n            try:\n                # For bulk sends, we could optimize by creating a single Mail object\n                # with all recipients if all messages have the same subject/body\n                msg_id = self.send_email(message)\n                results.append(msg_id)\n\n            except Exception as e:\n                _logger.error('Failed to send email', error=str(e), index=i, to=message.to)\n                results.append(None)\n\n    finally:\n        # Restore original settings if we modified them\n        if rate_limit:\n            self._client.batch_size = original_batch_size\n            self._client.wait_time = original_wait_time\n\n    return results\n</code></pre>"},{"location":"reference/pytanis/communication/mailgun_adapter/#pytanis.communication.mailgun_adapter.MailgunAdapter.send_email","title":"<code>send_email(message: EmailMessage) -&gt; str | None</code>","text":"<p>Send an email message using Mailgun</p> Source code in <code>src/pytanis/communication/mailgun_adapter.py</code> <pre><code>def send_email(self, message: EmailMessage) -&gt; str | None:\n    \"\"\"Send an email message using Mailgun\"\"\"\n    try:\n        # Convert to Mailgun format\n\n        # Extract recipients\n        if not message.to:\n            msg = 'No recipients specified'\n            raise ValueError(msg)\n\n        # Create recipient objects for all recipients\n        recipients = []\n        for email in message.to:\n            # Extract name from email if no metadata is provided\n            name = email.split('@')[0]\n            recipients.append(\n                Recipient(\n                    name=name,\n                    email=email,\n                )\n            )\n\n        # Create mail object with correct parameters\n        mail = Mail(\n            subject=message.subject,\n            body=message.body,\n            recipients=recipients,\n        )\n\n        # Send email using the correct method name\n        responses, errors = self._client.send(mail)\n\n        # Check for errors\n        if errors:\n            error_msgs = [f'{recipient.email}: {error!s}' for recipient, error in errors]\n            _logger.error('Errors sending emails', errors=error_msgs)\n            if not responses:\n                msg = f'All emails failed: {\"; \".join(error_msgs)}'\n                raise OSError(msg)\n\n        # Handle additional recipients as CC/BCC (not supported by current Mailgun implementation)\n        if message.cc or message.bcc:\n            _logger.warning(\n                'Mailgun adapter currently does not support CC/BCC recipients.',\n                cc=message.cc,\n                bcc=message.bcc,\n            )\n\n        # Return the first response ID if available\n        if responses and hasattr(responses[0], 'json'):\n            return responses[0].json().get('id')\n\n        return None\n\n    except Exception as e:\n        msg = f'Error sending email via Mailgun: {e}'\n        raise OSError(msg) from e\n</code></pre>"},{"location":"reference/pytanis/helpdesk/","title":"Helpdesk","text":""},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk","title":"<code>helpdesk</code>","text":"<p>Functionality around the HelpDesk / LiveChat API</p>"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.__all__","title":"<code>__all__ = ['HelpDeskClient', 'Mail', 'MailClient', 'Recipient']</code>  <code>module-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.HelpDeskClient","title":"<code>HelpDeskClient(config: Config | None = None)</code>","text":"Source code in <code>src/pytanis/helpdesk/client.py</code> <pre><code>def __init__(self, config: Config | None = None):\n    if config is None:\n        config = get_cfg()\n    self._config = config\n    # Important: Always use a custom User-Agent, never a generic one.\n    # Generic User-Agents are filtered by helpdesk to reduce spam.\n    self._headers = {'User-Agent': 'Pytanis'}\n\n    self._get_throttled = self._get\n    self._post_throttled = self._post\n    self.set_throttling(calls=1, seconds=10)  # Helpdesk is really strange when it comes to this\n</code></pre>"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.HelpDeskClient.create_ticket","title":"<code>create_ticket(ticket: NewTicket)</code>","text":"Source code in <code>src/pytanis/helpdesk/client.py</code> <pre><code>def create_ticket(self, ticket: NewTicket):\n    return self.post('tickets', data=ticket.model_dump())\n</code></pre>"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.HelpDeskClient.get","title":"<code>get(endpoint: str, params: QueryParams | None = None) -&gt; JSON</code>","text":"<p>Retrieve data via throttled GET request and return the JSON</p> Source code in <code>src/pytanis/helpdesk/client.py</code> <pre><code>def get(self, endpoint: str, params: QueryParams | None = None) -&gt; JSON:\n    \"\"\"Retrieve data via throttled GET request and return the JSON\"\"\"\n    resp = self._get_throttled(endpoint, params)\n    resp.raise_for_status()\n    return resp.json()\n</code></pre>"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.HelpDeskClient.list_agents","title":"<code>list_agents() -&gt; list[Agent]</code>","text":"Source code in <code>src/pytanis/helpdesk/client.py</code> <pre><code>def list_agents(self) -&gt; list[Agent]:\n    agents = self.get('agents')\n    if not isinstance(agents, list):\n        msg = 'Received JSON is not a list object'\n        raise ValueError(msg)\n    return [Agent.model_validate(dct) for dct in agents]\n</code></pre>"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.HelpDeskClient.list_teams","title":"<code>list_teams() -&gt; list[Team]</code>","text":"Source code in <code>src/pytanis/helpdesk/client.py</code> <pre><code>def list_teams(self) -&gt; list[Team]:\n    teams = self.get('teams')\n    if not isinstance(teams, list):\n        msg = 'Received JSON is not a list object'\n        raise ValueError(msg)\n    return [Team.model_validate(dct) for dct in teams]\n</code></pre>"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.HelpDeskClient.post","title":"<code>post(endpoint: str, data: dict[str, Any], params: QueryParams | None = None) -&gt; JSON</code>","text":"Source code in <code>src/pytanis/helpdesk/client.py</code> <pre><code>def post(self, endpoint: str, data: dict[str, Any], params: QueryParams | None = None) -&gt; JSON:\n    resp = self._post_throttled(endpoint, data, params)\n    resp.raise_for_status()\n    return resp.json()\n</code></pre>"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.HelpDeskClient.set_throttling","title":"<code>set_throttling(calls: int, seconds: int)</code>","text":"<p>Throttle the number of calls per seconds to the Pretalx API</p> Source code in <code>src/pytanis/helpdesk/client.py</code> <pre><code>def set_throttling(self, calls: int, seconds: int):\n    \"\"\"Throttle the number of calls per seconds to the Pretalx API\"\"\"\n    _logger.debug('throttling', calls=calls, seconds=seconds)\n    self._get_throttled = throttle(calls, seconds)(self._get)\n    self._post_throttled = throttle(calls, seconds)(self._post)\n</code></pre>"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.Mail","title":"<code>Mail</code>","text":"<p>Mail template</p> <p>Use the <code>data</code> field to store additional information</p> <p>You can use the typical Format String Syntax and the objects <code>recipient</code> and <code>mail</code> to access metadata to complement the template, e.g.:</p> <pre><code>Hello {recipient.address_as},\n\nWe hope it's ok to address you your first name rather than using your full name being {recipient.name}.\nHave you read the email's subject '{mail.subject}'? How is your work right now at {recipient.data.company}?\n\nCheers!\n</code></pre>"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.Mail.agent_id","title":"<code>agent_id: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.Mail.data","title":"<code>data: MetaData | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.Mail.recipients","title":"<code>recipients: list[Recipient]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.Mail.status","title":"<code>status: str = 'solved'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.Mail.subject","title":"<code>subject: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.Mail.team_id","title":"<code>team_id: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.Mail.text","title":"<code>text: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.MailClient","title":"<code>MailClient(helpdesk_client: HelpDeskClient | None = None)</code>","text":"<p>Mail client for mass mails over HelpDesk</p> Source code in <code>src/pytanis/helpdesk/mail.py</code> <pre><code>def __init__(self, helpdesk_client: HelpDeskClient | None = None):\n    if helpdesk_client is None:\n        helpdesk_client = HelpDeskClient()\n    self._helpdesk_client = helpdesk_client\n    self.dry_run: Callable[[NewTicket], None] = self.print_new_ticket\n</code></pre>"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.MailClient.batch_size","title":"<code>batch_size: int = 10</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.MailClient.dry_run","title":"<code>dry_run: Callable[[NewTicket], None] = self.print_new_ticket</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.MailClient.wait_time","title":"<code>wait_time: int = 20</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.MailClient.print_new_ticket","title":"<code>print_new_ticket(ticket: NewTicket)</code>  <code>staticmethod</code>","text":"<p>Default action in a dry-run. Mainly for making sure you sent what you mean!</p> <p>Overwrite it by assigning to self.dry_run another function</p> <p>ToDo: Make this function nice, maybe use the <code>rich</code> library even</p> Source code in <code>src/pytanis/helpdesk/mail.py</code> <pre><code>@staticmethod\ndef print_new_ticket(ticket: NewTicket):\n    \"\"\"Default action in a dry-run. Mainly for making sure you sent what you mean!\n\n    Overwrite it by assigning to self.dry_run another function\n\n    ToDo: Make this function nice, maybe use the `rich` library even\n    \"\"\"\n    print('#' * 40)  # noqa: T201\n    print(f'Recipient: {ticket.requester.name} &lt;{ticket.requester.email}&gt;')  # noqa: T201\n    print(f'Subject: {ticket.subject}')  # noqa: T201\n    print(f'{ticket.message.text}')  # noqa: T201\n</code></pre>"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.MailClient.send","title":"<code>send(mail: Mail, *, dry_run: bool = True) -&gt; tuple[list[tuple[Recipient, Ticket | None]], list[tuple[Recipient, Exception]]]</code>","text":"<p>Send a mail to all recipients using HelpDesk</p> Source code in <code>src/pytanis/helpdesk/mail.py</code> <pre><code>def send(\n    self, mail: Mail, *, dry_run: bool = True\n) -&gt; tuple[list[tuple[Recipient, Ticket | None]], list[tuple[Recipient, Exception]]]:\n    \"\"\"Send a mail to all recipients using HelpDesk\"\"\"\n    errors = []\n    tickets = []\n    for idx, recipient in enumerate(tqdm(mail.recipients), start=1):\n        recip_mail = mail.model_copy()\n        try:\n            recip_mail.subject = mail.subject.format(recipient=recipient, mail=mail)\n            # be aware here that the body might reference to subject line, so it must be filled already\n            recip_mail.text = recip_mail.text.format(recipient=recipient, mail=recip_mail)\n            ticket = self._create_ticket(recip_mail, recipient)\n            if dry_run:\n                self.print_new_ticket(ticket)\n                resp_ticket = None\n            else:\n                resp = self._helpdesk_client.create_ticket(ticket)\n                resp_ticket = Ticket.model_validate(resp)\n        except Exception as e:\n            errors.append((recipient, e))\n        else:\n            tickets.append((recipient, resp_ticket))\n        if (idx % self.batch_size == 0) and not dry_run:\n            time.sleep(self.wait_time)\n\n    return tickets, errors\n</code></pre>"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.Recipient","title":"<code>Recipient</code>","text":"<p>Details about the recipient</p> <p>Use the <code>data</code> field to store additional information</p>"},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.Recipient.address_as","title":"<code>address_as: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.Recipient.data","title":"<code>data: MetaData | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.Recipient.email","title":"<code>email: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.Recipient.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/#pytanis.helpdesk.Recipient.fill_address_as","title":"<code>fill_address_as()</code>","text":"Source code in <code>src/pytanis/helpdesk/mail.py</code> <pre><code>@model_validator(mode='after')\ndef fill_address_as(self):\n    if self.address_as is None:\n        self.address_as = self.name\n    return self\n</code></pre>"},{"location":"reference/pytanis/helpdesk/client/","title":"Client","text":""},{"location":"reference/pytanis/helpdesk/client/#pytanis.helpdesk.client","title":"<code>client</code>","text":"<p>Client for the HelpDesk / LiveChat API</p> <p>Documentation: https://api.helpdesk.com/docs</p> <p>ToDo</p> <ul> <li>Transfer more functionality from PYCONDE/py_helpdesk_com</li> </ul>"},{"location":"reference/pytanis/helpdesk/client/#pytanis.helpdesk.client.JSON","title":"<code>JSON: TypeAlias = JSONObj | JSONLst</code>  <code>module-attribute</code>","text":"<p>Type of the JSON response as returned by the HelpDesk / LiveChat API</p>"},{"location":"reference/pytanis/helpdesk/client/#pytanis.helpdesk.client.JSONLst","title":"<code>JSONLst: TypeAlias = list[JSONObj]</code>  <code>module-attribute</code>","text":"<p>Type of a JSON list of JSON objects</p>"},{"location":"reference/pytanis/helpdesk/client/#pytanis.helpdesk.client.JSONObj","title":"<code>JSONObj: TypeAlias = dict[str, Any]</code>  <code>module-attribute</code>","text":"<p>Type of a JSON object (without recursion)</p>"},{"location":"reference/pytanis/helpdesk/client/#pytanis.helpdesk.client.HelpDeskClient","title":"<code>HelpDeskClient(config: Config | None = None)</code>","text":"Source code in <code>src/pytanis/helpdesk/client.py</code> <pre><code>def __init__(self, config: Config | None = None):\n    if config is None:\n        config = get_cfg()\n    self._config = config\n    # Important: Always use a custom User-Agent, never a generic one.\n    # Generic User-Agents are filtered by helpdesk to reduce spam.\n    self._headers = {'User-Agent': 'Pytanis'}\n\n    self._get_throttled = self._get\n    self._post_throttled = self._post\n    self.set_throttling(calls=1, seconds=10)  # Helpdesk is really strange when it comes to this\n</code></pre>"},{"location":"reference/pytanis/helpdesk/client/#pytanis.helpdesk.client.HelpDeskClient.create_ticket","title":"<code>create_ticket(ticket: NewTicket)</code>","text":"Source code in <code>src/pytanis/helpdesk/client.py</code> <pre><code>def create_ticket(self, ticket: NewTicket):\n    return self.post('tickets', data=ticket.model_dump())\n</code></pre>"},{"location":"reference/pytanis/helpdesk/client/#pytanis.helpdesk.client.HelpDeskClient.get","title":"<code>get(endpoint: str, params: QueryParams | None = None) -&gt; JSON</code>","text":"<p>Retrieve data via throttled GET request and return the JSON</p> Source code in <code>src/pytanis/helpdesk/client.py</code> <pre><code>def get(self, endpoint: str, params: QueryParams | None = None) -&gt; JSON:\n    \"\"\"Retrieve data via throttled GET request and return the JSON\"\"\"\n    resp = self._get_throttled(endpoint, params)\n    resp.raise_for_status()\n    return resp.json()\n</code></pre>"},{"location":"reference/pytanis/helpdesk/client/#pytanis.helpdesk.client.HelpDeskClient.list_agents","title":"<code>list_agents() -&gt; list[Agent]</code>","text":"Source code in <code>src/pytanis/helpdesk/client.py</code> <pre><code>def list_agents(self) -&gt; list[Agent]:\n    agents = self.get('agents')\n    if not isinstance(agents, list):\n        msg = 'Received JSON is not a list object'\n        raise ValueError(msg)\n    return [Agent.model_validate(dct) for dct in agents]\n</code></pre>"},{"location":"reference/pytanis/helpdesk/client/#pytanis.helpdesk.client.HelpDeskClient.list_teams","title":"<code>list_teams() -&gt; list[Team]</code>","text":"Source code in <code>src/pytanis/helpdesk/client.py</code> <pre><code>def list_teams(self) -&gt; list[Team]:\n    teams = self.get('teams')\n    if not isinstance(teams, list):\n        msg = 'Received JSON is not a list object'\n        raise ValueError(msg)\n    return [Team.model_validate(dct) for dct in teams]\n</code></pre>"},{"location":"reference/pytanis/helpdesk/client/#pytanis.helpdesk.client.HelpDeskClient.post","title":"<code>post(endpoint: str, data: dict[str, Any], params: QueryParams | None = None) -&gt; JSON</code>","text":"Source code in <code>src/pytanis/helpdesk/client.py</code> <pre><code>def post(self, endpoint: str, data: dict[str, Any], params: QueryParams | None = None) -&gt; JSON:\n    resp = self._post_throttled(endpoint, data, params)\n    resp.raise_for_status()\n    return resp.json()\n</code></pre>"},{"location":"reference/pytanis/helpdesk/client/#pytanis.helpdesk.client.HelpDeskClient.set_throttling","title":"<code>set_throttling(calls: int, seconds: int)</code>","text":"<p>Throttle the number of calls per seconds to the Pretalx API</p> Source code in <code>src/pytanis/helpdesk/client.py</code> <pre><code>def set_throttling(self, calls: int, seconds: int):\n    \"\"\"Throttle the number of calls per seconds to the Pretalx API\"\"\"\n    _logger.debug('throttling', calls=calls, seconds=seconds)\n    self._get_throttled = throttle(calls, seconds)(self._get)\n    self._post_throttled = throttle(calls, seconds)(self._post)\n</code></pre>"},{"location":"reference/pytanis/helpdesk/mail/","title":"Mail","text":""},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail","title":"<code>mail</code>","text":"<p>Functionality around mailing</p> <p>ToDo</p> <ul> <li>add logging where appropriate</li> <li>Find out why <code>extra=Extra.allow</code> causes mypy to fail. Seems like a bug in pydantic.</li> <li>Sending mails is quite slow, so using <code>tqdm</code> to show feedback to the current progress would be nice</li> </ul>"},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Mail","title":"<code>Mail</code>","text":"<p>Mail template</p> <p>Use the <code>data</code> field to store additional information</p> <p>You can use the typical Format String Syntax and the objects <code>recipient</code> and <code>mail</code> to access metadata to complement the template, e.g.:</p> <pre><code>Hello {recipient.address_as},\n\nWe hope it's ok to address you your first name rather than using your full name being {recipient.name}.\nHave you read the email's subject '{mail.subject}'? How is your work right now at {recipient.data.company}?\n\nCheers!\n</code></pre>"},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Mail.agent_id","title":"<code>agent_id: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Mail.data","title":"<code>data: MetaData | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Mail.recipients","title":"<code>recipients: list[Recipient]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Mail.status","title":"<code>status: str = 'solved'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Mail.subject","title":"<code>subject: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Mail.team_id","title":"<code>team_id: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Mail.text","title":"<code>text: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.MailClient","title":"<code>MailClient(helpdesk_client: HelpDeskClient | None = None)</code>","text":"<p>Mail client for mass mails over HelpDesk</p> Source code in <code>src/pytanis/helpdesk/mail.py</code> <pre><code>def __init__(self, helpdesk_client: HelpDeskClient | None = None):\n    if helpdesk_client is None:\n        helpdesk_client = HelpDeskClient()\n    self._helpdesk_client = helpdesk_client\n    self.dry_run: Callable[[NewTicket], None] = self.print_new_ticket\n</code></pre>"},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.MailClient.batch_size","title":"<code>batch_size: int = 10</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.MailClient.dry_run","title":"<code>dry_run: Callable[[NewTicket], None] = self.print_new_ticket</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.MailClient.wait_time","title":"<code>wait_time: int = 20</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.MailClient.print_new_ticket","title":"<code>print_new_ticket(ticket: NewTicket)</code>  <code>staticmethod</code>","text":"<p>Default action in a dry-run. Mainly for making sure you sent what you mean!</p> <p>Overwrite it by assigning to self.dry_run another function</p> <p>ToDo: Make this function nice, maybe use the <code>rich</code> library even</p> Source code in <code>src/pytanis/helpdesk/mail.py</code> <pre><code>@staticmethod\ndef print_new_ticket(ticket: NewTicket):\n    \"\"\"Default action in a dry-run. Mainly for making sure you sent what you mean!\n\n    Overwrite it by assigning to self.dry_run another function\n\n    ToDo: Make this function nice, maybe use the `rich` library even\n    \"\"\"\n    print('#' * 40)  # noqa: T201\n    print(f'Recipient: {ticket.requester.name} &lt;{ticket.requester.email}&gt;')  # noqa: T201\n    print(f'Subject: {ticket.subject}')  # noqa: T201\n    print(f'{ticket.message.text}')  # noqa: T201\n</code></pre>"},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.MailClient.send","title":"<code>send(mail: Mail, *, dry_run: bool = True) -&gt; tuple[list[tuple[Recipient, Ticket | None]], list[tuple[Recipient, Exception]]]</code>","text":"<p>Send a mail to all recipients using HelpDesk</p> Source code in <code>src/pytanis/helpdesk/mail.py</code> <pre><code>def send(\n    self, mail: Mail, *, dry_run: bool = True\n) -&gt; tuple[list[tuple[Recipient, Ticket | None]], list[tuple[Recipient, Exception]]]:\n    \"\"\"Send a mail to all recipients using HelpDesk\"\"\"\n    errors = []\n    tickets = []\n    for idx, recipient in enumerate(tqdm(mail.recipients), start=1):\n        recip_mail = mail.model_copy()\n        try:\n            recip_mail.subject = mail.subject.format(recipient=recipient, mail=mail)\n            # be aware here that the body might reference to subject line, so it must be filled already\n            recip_mail.text = recip_mail.text.format(recipient=recipient, mail=recip_mail)\n            ticket = self._create_ticket(recip_mail, recipient)\n            if dry_run:\n                self.print_new_ticket(ticket)\n                resp_ticket = None\n            else:\n                resp = self._helpdesk_client.create_ticket(ticket)\n                resp_ticket = Ticket.model_validate(resp)\n        except Exception as e:\n            errors.append((recipient, e))\n        else:\n            tickets.append((recipient, resp_ticket))\n        if (idx % self.batch_size == 0) and not dry_run:\n            time.sleep(self.wait_time)\n\n    return tickets, errors\n</code></pre>"},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.MetaData","title":"<code>MetaData</code>","text":"<p>Additional, arbitrary metadata provided by the user like for template filling</p>"},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.MetaData.model_config","title":"<code>model_config = ConfigDict(extra='allow')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Recipient","title":"<code>Recipient</code>","text":"<p>Details about the recipient</p> <p>Use the <code>data</code> field to store additional information</p>"},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Recipient.address_as","title":"<code>address_as: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Recipient.data","title":"<code>data: MetaData | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Recipient.email","title":"<code>email: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Recipient.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/mail/#pytanis.helpdesk.mail.Recipient.fill_address_as","title":"<code>fill_address_as()</code>","text":"Source code in <code>src/pytanis/helpdesk/mail.py</code> <pre><code>@model_validator(mode='after')\ndef fill_address_as(self):\n    if self.address_as is None:\n        self.address_as = self.name\n    return self\n</code></pre>"},{"location":"reference/pytanis/helpdesk/models/","title":"Models","text":""},{"location":"reference/pytanis/helpdesk/models/#pytanis.helpdesk.models","title":"<code>models</code>","text":"<p>Return types of the HelpDesk / LiveChat API</p> <p>Documentation: https://api.helpdesk.com/docs</p> <p>ToDo</p> <ul> <li>Implement the types below correctly instead of using <code>Extra.Allow</code></li> <li>Find out why <code>extra=Extra.allow</code> causes mypy to fail. Seems like a bug in pydantic.</li> </ul>"},{"location":"reference/pytanis/helpdesk/models/#pytanis.helpdesk.models.Agent","title":"<code>Agent</code>","text":""},{"location":"reference/pytanis/helpdesk/models/#pytanis.helpdesk.models.Agent.model_config","title":"<code>model_config = ConfigDict(extra='allow')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/models/#pytanis.helpdesk.models.Assignment","title":"<code>Assignment</code>","text":""},{"location":"reference/pytanis/helpdesk/models/#pytanis.helpdesk.models.Assignment.agent","title":"<code>agent: Id</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/models/#pytanis.helpdesk.models.Assignment.model_config","title":"<code>model_config = ConfigDict(extra='allow')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/models/#pytanis.helpdesk.models.Assignment.team","title":"<code>team: Id</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/models/#pytanis.helpdesk.models.Id","title":"<code>Id</code>","text":""},{"location":"reference/pytanis/helpdesk/models/#pytanis.helpdesk.models.Id.ID","title":"<code>ID: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/models/#pytanis.helpdesk.models.Message","title":"<code>Message</code>","text":""},{"location":"reference/pytanis/helpdesk/models/#pytanis.helpdesk.models.Message.model_config","title":"<code>model_config = ConfigDict(extra='allow')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/models/#pytanis.helpdesk.models.Message.text","title":"<code>text: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/models/#pytanis.helpdesk.models.NewTicket","title":"<code>NewTicket</code>","text":"<p>Object that needs to be sent when creating a NEW ticket</p>"},{"location":"reference/pytanis/helpdesk/models/#pytanis.helpdesk.models.NewTicket.assignment","title":"<code>assignment: Assignment | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/models/#pytanis.helpdesk.models.NewTicket.message","title":"<code>message: Message</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/models/#pytanis.helpdesk.models.NewTicket.model_config","title":"<code>model_config = ConfigDict(extra='allow')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/models/#pytanis.helpdesk.models.NewTicket.requester","title":"<code>requester: Requester</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/models/#pytanis.helpdesk.models.NewTicket.status","title":"<code>status: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/models/#pytanis.helpdesk.models.NewTicket.subject","title":"<code>subject: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/models/#pytanis.helpdesk.models.NewTicket.teamIDs","title":"<code>teamIDs: list[str] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/models/#pytanis.helpdesk.models.Requester","title":"<code>Requester</code>","text":""},{"location":"reference/pytanis/helpdesk/models/#pytanis.helpdesk.models.Requester.email","title":"<code>email: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/models/#pytanis.helpdesk.models.Requester.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/models/#pytanis.helpdesk.models.Team","title":"<code>Team</code>","text":""},{"location":"reference/pytanis/helpdesk/models/#pytanis.helpdesk.models.Team.model_config","title":"<code>model_config = ConfigDict(extra='allow')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/helpdesk/models/#pytanis.helpdesk.models.Ticket","title":"<code>Ticket</code>","text":"<p>Actual ticket as returned by the API</p>"},{"location":"reference/pytanis/helpdesk/models/#pytanis.helpdesk.models.Ticket.model_config","title":"<code>model_config = ConfigDict(extra='allow')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/mailgun/","title":"Mailgun","text":""},{"location":"reference/pytanis/mailgun/#pytanis.mailgun","title":"<code>mailgun</code>","text":"<p>Functionality around the Mailgun API</p>"},{"location":"reference/pytanis/mailgun/#pytanis.mailgun.__all__","title":"<code>__all__ = ['Mail', 'MailClient', 'Recipient']</code>  <code>module-attribute</code>","text":""},{"location":"reference/pytanis/mailgun/#pytanis.mailgun.Mail","title":"<code>Mail</code>","text":"<p>Mail template</p> <p>Use the <code>data</code> field to store additional information</p> <p>You can use the typical Format String Syntax and the objects <code>recipient</code> and <code>mail</code> to access metadata to complement the template, e.g.:</p> <pre><code>Hello {recipient.address_as},\n\nWe hope it's ok to address you your first name rather than using your full name being {recipient.name}.\nHave you read the email's subject '{mail.subject}'? How is your work right now at {recipient.data.company}?\n\nCheers!\n</code></pre>"},{"location":"reference/pytanis/mailgun/#pytanis.mailgun.Mail.body","title":"<code>body: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/mailgun/#pytanis.mailgun.Mail.data","title":"<code>data: MetaData | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/mailgun/#pytanis.mailgun.Mail.recipients","title":"<code>recipients: list[Recipient]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/mailgun/#pytanis.mailgun.Mail.subject","title":"<code>subject: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/mailgun/#pytanis.mailgun.MailClient","title":"<code>MailClient(config: Config | None = None)</code>","text":"<p>Mail client for mass mails via Mailgun</p> Source code in <code>src/pytanis/mailgun/mail.py</code> <pre><code>def __init__(self, config: Config | None = None):\n    if config is None:\n        config = get_cfg()\n    self._config = config\n</code></pre>"},{"location":"reference/pytanis/mailgun/#pytanis.mailgun.MailClient.batch_size","title":"<code>batch_size: int = 10</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/mailgun/#pytanis.mailgun.MailClient.timeout","title":"<code>timeout: int = 10</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/mailgun/#pytanis.mailgun.MailClient.wait_time","title":"<code>wait_time: int = 20</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/mailgun/#pytanis.mailgun.MailClient.send","title":"<code>send(mail: Mail)</code>","text":"<p>Send a mail to all recipients using Mailgun</p> Source code in <code>src/pytanis/mailgun/mail.py</code> <pre><code>def send(self, mail: Mail):\n    \"\"\"Send a mail to all recipients using Mailgun\"\"\"\n    errors = []\n    responses = []\n\n    # TODO: improve Mailgun batch mailing by setting custom transactional variables\n    if self._config.Mailgun is None:\n        msg = 'Mailgun configuration is missing'\n        raise RuntimeError(msg)\n    for idx, recipient in enumerate(tqdm(mail.recipients), start=1):\n        try:\n            recipient_mail = mail.model_copy()\n            if self._config.Mailgun.token is None:\n                msg = 'API token for Mailgun is empty'\n                raise RuntimeError(msg)\n            if self._config.Mailgun.from_address is None:\n                msg = 'From Email for Mailgun is empty'\n                raise RuntimeError(msg)\n            if self._config.Mailgun.reply_to is None:\n                msg = 'Reply To Email for Mailgun is empty'\n                raise RuntimeError(msg)\n\n            response = requests.post(\n                'https://api.eu.mailgun.net/v3/mg.pycon.de/messages',\n                auth=('api', self._config.Mailgun.token),\n                data={\n                    'to': [recipient.email],\n                    'from': self._config.Mailgun.from_address,\n                    'subject': recipient_mail.subject.format(recipient=recipient, mail=mail),\n                    'text': recipient_mail.body.format(recipient=recipient, mail=mail),\n                    'h:Reply-To': self._config.Mailgun.reply_to,\n                },\n                timeout=self.timeout,\n            )\n            # check response status message and throw exception if not 200\n            response.raise_for_status()\n        except Exception as e:\n            errors.append((recipient, e))\n        else:\n            responses.append(response)\n\n        if idx % self.batch_size == 0:\n            time.sleep(self.wait_time)\n\n    return responses, errors\n</code></pre>"},{"location":"reference/pytanis/mailgun/#pytanis.mailgun.Recipient","title":"<code>Recipient</code>","text":"<p>Details about the recipient</p> <p>Use the <code>data</code> field to store additional information</p>"},{"location":"reference/pytanis/mailgun/#pytanis.mailgun.Recipient.address_as","title":"<code>address_as: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/mailgun/#pytanis.mailgun.Recipient.data","title":"<code>data: MetaData | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/mailgun/#pytanis.mailgun.Recipient.email","title":"<code>email: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/mailgun/#pytanis.mailgun.Recipient.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/mailgun/#pytanis.mailgun.Recipient.fill_address_as","title":"<code>fill_address_as()</code>","text":"Source code in <code>src/pytanis/mailgun/mail.py</code> <pre><code>@model_validator(mode='after')\ndef fill_address_as(self):\n    if self.address_as is None:\n        self.address_as = self.name\n    return self\n</code></pre>"},{"location":"reference/pytanis/mailgun/mail/","title":"Mail","text":""},{"location":"reference/pytanis/mailgun/mail/#pytanis.mailgun.mail","title":"<code>mail</code>","text":""},{"location":"reference/pytanis/mailgun/mail/#pytanis.mailgun.mail.Mail","title":"<code>Mail</code>","text":"<p>Mail template</p> <p>Use the <code>data</code> field to store additional information</p> <p>You can use the typical Format String Syntax and the objects <code>recipient</code> and <code>mail</code> to access metadata to complement the template, e.g.:</p> <pre><code>Hello {recipient.address_as},\n\nWe hope it's ok to address you your first name rather than using your full name being {recipient.name}.\nHave you read the email's subject '{mail.subject}'? How is your work right now at {recipient.data.company}?\n\nCheers!\n</code></pre>"},{"location":"reference/pytanis/mailgun/mail/#pytanis.mailgun.mail.Mail.body","title":"<code>body: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/mailgun/mail/#pytanis.mailgun.mail.Mail.data","title":"<code>data: MetaData | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/mailgun/mail/#pytanis.mailgun.mail.Mail.recipients","title":"<code>recipients: list[Recipient]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/mailgun/mail/#pytanis.mailgun.mail.Mail.subject","title":"<code>subject: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/mailgun/mail/#pytanis.mailgun.mail.MailClient","title":"<code>MailClient(config: Config | None = None)</code>","text":"<p>Mail client for mass mails via Mailgun</p> Source code in <code>src/pytanis/mailgun/mail.py</code> <pre><code>def __init__(self, config: Config | None = None):\n    if config is None:\n        config = get_cfg()\n    self._config = config\n</code></pre>"},{"location":"reference/pytanis/mailgun/mail/#pytanis.mailgun.mail.MailClient.batch_size","title":"<code>batch_size: int = 10</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/mailgun/mail/#pytanis.mailgun.mail.MailClient.timeout","title":"<code>timeout: int = 10</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/mailgun/mail/#pytanis.mailgun.mail.MailClient.wait_time","title":"<code>wait_time: int = 20</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/mailgun/mail/#pytanis.mailgun.mail.MailClient.send","title":"<code>send(mail: Mail)</code>","text":"<p>Send a mail to all recipients using Mailgun</p> Source code in <code>src/pytanis/mailgun/mail.py</code> <pre><code>def send(self, mail: Mail):\n    \"\"\"Send a mail to all recipients using Mailgun\"\"\"\n    errors = []\n    responses = []\n\n    # TODO: improve Mailgun batch mailing by setting custom transactional variables\n    if self._config.Mailgun is None:\n        msg = 'Mailgun configuration is missing'\n        raise RuntimeError(msg)\n    for idx, recipient in enumerate(tqdm(mail.recipients), start=1):\n        try:\n            recipient_mail = mail.model_copy()\n            if self._config.Mailgun.token is None:\n                msg = 'API token for Mailgun is empty'\n                raise RuntimeError(msg)\n            if self._config.Mailgun.from_address is None:\n                msg = 'From Email for Mailgun is empty'\n                raise RuntimeError(msg)\n            if self._config.Mailgun.reply_to is None:\n                msg = 'Reply To Email for Mailgun is empty'\n                raise RuntimeError(msg)\n\n            response = requests.post(\n                'https://api.eu.mailgun.net/v3/mg.pycon.de/messages',\n                auth=('api', self._config.Mailgun.token),\n                data={\n                    'to': [recipient.email],\n                    'from': self._config.Mailgun.from_address,\n                    'subject': recipient_mail.subject.format(recipient=recipient, mail=mail),\n                    'text': recipient_mail.body.format(recipient=recipient, mail=mail),\n                    'h:Reply-To': self._config.Mailgun.reply_to,\n                },\n                timeout=self.timeout,\n            )\n            # check response status message and throw exception if not 200\n            response.raise_for_status()\n        except Exception as e:\n            errors.append((recipient, e))\n        else:\n            responses.append(response)\n\n        if idx % self.batch_size == 0:\n            time.sleep(self.wait_time)\n\n    return responses, errors\n</code></pre>"},{"location":"reference/pytanis/mailgun/mail/#pytanis.mailgun.mail.MetaData","title":"<code>MetaData</code>","text":"<p>Additional, arbitrary metadata provided by the user like for template filling</p>"},{"location":"reference/pytanis/mailgun/mail/#pytanis.mailgun.mail.MetaData.model_config","title":"<code>model_config = ConfigDict(extra='allow')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/mailgun/mail/#pytanis.mailgun.mail.Recipient","title":"<code>Recipient</code>","text":"<p>Details about the recipient</p> <p>Use the <code>data</code> field to store additional information</p>"},{"location":"reference/pytanis/mailgun/mail/#pytanis.mailgun.mail.Recipient.address_as","title":"<code>address_as: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/mailgun/mail/#pytanis.mailgun.mail.Recipient.data","title":"<code>data: MetaData | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/mailgun/mail/#pytanis.mailgun.mail.Recipient.email","title":"<code>email: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/mailgun/mail/#pytanis.mailgun.mail.Recipient.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/mailgun/mail/#pytanis.mailgun.mail.Recipient.fill_address_as","title":"<code>fill_address_as()</code>","text":"Source code in <code>src/pytanis/mailgun/mail.py</code> <pre><code>@model_validator(mode='after')\ndef fill_address_as(self):\n    if self.address_as is None:\n        self.address_as = self.name\n    return self\n</code></pre>"},{"location":"reference/pytanis/pretalx/","title":"Pretalx","text":""},{"location":"reference/pytanis/pretalx/#pytanis.pretalx","title":"<code>pretalx</code>","text":"<p>Functionality around the Pretalx API</p>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.__all__","title":"<code>__all__ = ['PretalxClient', 'SimpleTalk', 'get_confirmed_talks_as_json', 'get_talks_as_json', 'reviews_as_df', 'save_confirmed_talks_to_json', 'save_talks_to_json', 'speakers_as_df', 'subs_as_df', 'talks_to_json']</code>  <code>module-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient","title":"<code>PretalxClient(config: Config | None = None, *, blocking: bool = False)</code>","text":"<p>Client for the Pretalx API</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def __init__(self, config: Config | None = None, *, blocking: bool = False):\n    if config is None:\n        config = get_cfg()\n    self._config = config\n    self._get_throttled = self._get\n    self.blocking = blocking\n    self.set_throttling(calls=2, seconds=1)  # we are nice by default and Pretalx doesn't allow many calls at once.\n\n    # Caches for expanded objects (session-only, not persisted)\n    self._speaker_cache: dict[str, dict] = {}\n    self._submission_type_cache: dict[int, dict] = {}\n    self._track_cache: dict[int, dict] = {}\n    self._answer_cache: dict[int, dict | None] = {}\n    self._question_cache: dict[int, dict] = {}\n    self._caches_populated: dict[str, bool] = {}  # Track which event caches are populated\n    self._use_cache_prepopulation: bool = True  # Enable cache pre-population by default\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.blocking","title":"<code>blocking = blocking</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.__validate","title":"<code>__validate(model_type, result)</code>  <code>classmethod</code>","text":"Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>@classmethod\ndef __validate(cls, model_type, result):\n    try:\n        validated = model_type.model_validate(result)\n        return validated\n    except Exception as e:\n        # introduced to deal with API changes\n        _logger.error('result', resp=e)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.answer","title":"<code>answer(event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Answer</code>","text":"<p>Returns a specific answer</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def answer(self, event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Answer:  # noqa: A002\n    \"\"\"Returns a specific answer\"\"\"\n    return self._endpoint_id(Answer, event_slug, 'answers', id, params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.answers","title":"<code>answers(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Answer]]</code>","text":"<p>Lists all answers and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def answers(self, event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Answer]]:\n    \"\"\"Lists all answers and their details\"\"\"\n    return self._endpoint_lst(Answer, event_slug, 'answers', params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.clear_caches","title":"<code>clear_caches() -&gt; None</code>","text":"<p>Clear all session caches.</p> <p>This is useful if you want to force fresh data to be fetched from the API. Note that caches are session-only and are not persisted between client instances.</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def clear_caches(self) -&gt; None:\n    \"\"\"Clear all session caches.\n\n    This is useful if you want to force fresh data to be fetched from the API.\n    Note that caches are session-only and are not persisted between client instances.\n    \"\"\"\n    self._speaker_cache.clear()\n    self._submission_type_cache.clear()\n    self._track_cache.clear()\n    self._answer_cache.clear()\n    self._question_cache.clear()\n    self._caches_populated.clear()\n    _logger.info('All caches cleared')\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.event","title":"<code>event(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; Event</code>","text":"<p>Returns detailed information about a specific event</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def event(self, event_slug: str, *, params: QueryParams | dict | None = None) -&gt; Event:\n    \"\"\"Returns detailed information about a specific event\"\"\"\n    endpoint = f'/api/events/{event_slug}/'\n    result = self._get_one(endpoint, params)\n    _logger.debug('result', resp=result)\n    return self.__validate(Event, result)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.events","title":"<code>events(*, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Event]]</code>","text":"<p>Lists all events and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def events(self, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Event]]:\n    \"\"\"Lists all events and their details\"\"\"\n    count, results = self._get_many('/api/events/', params)\n    events = iter(_logger.debug('result', resp=r) or Event.model_validate(r) for r in results)\n    return count, events\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.me","title":"<code>me() -&gt; Me</code>  <code>classmethod</code>","text":"<p>Returns what Pretalx knows about myself</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>@classmethod\ndef me(cls) -&gt; Me:\n    \"\"\"Returns what Pretalx knows about myself\"\"\"\n    # removed in API update v1\n    msg = 'This endpoint is no longer provided since API v1.'\n    raise RuntimeError(msg)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.question","title":"<code>question(event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Question</code>","text":"<p>Returns a specific question</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def question(self, event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Question:  # noqa: A002\n    \"\"\"Returns a specific question\"\"\"\n    return self._endpoint_id(Question, event_slug, 'questions', id, params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.questions","title":"<code>questions(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Question]]</code>","text":"<p>Lists all questions and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def questions(self, event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Question]]:\n    \"\"\"Lists all questions and their details\"\"\"\n    return self._endpoint_lst(Question, event_slug, 'questions', params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.review","title":"<code>review(event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Review</code>","text":"<p>Returns a specific review</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def review(self, event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Review:  # noqa: A002\n    \"\"\"Returns a specific review\"\"\"\n    return self._endpoint_id(Review, event_slug, 'reviews', id, params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.reviews","title":"<code>reviews(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Review]]</code>","text":"<p>Lists all reviews and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def reviews(self, event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Review]]:\n    \"\"\"Lists all reviews and their details\"\"\"\n    return self._endpoint_lst(Review, event_slug, 'reviews', params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.room","title":"<code>room(event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Room</code>","text":"<p>Returns a specific room</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def room(self, event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Room:  # noqa: A002\n    \"\"\"Returns a specific room\"\"\"\n    return self._endpoint_id(Room, event_slug, 'rooms', id, params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.rooms","title":"<code>rooms(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Room]]</code>","text":"<p>Lists all rooms and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def rooms(self, event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Room]]:\n    \"\"\"Lists all rooms and their details\"\"\"\n    return self._endpoint_lst(Room, event_slug, 'rooms', params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.set_cache_prepopulation","title":"<code>set_cache_prepopulation(enabled: bool) -&gt; None</code>","text":"<p>Enable or disable automatic cache pre-population for submissions.</p> <p>When enabled (default), the client will fetch all speakers, submission types, and tracks in bulk on the first submission to minimize API calls. Disable this if you're only fetching a few submissions.</p> <p>Parameters:</p> Name Type Description Default <code>enabled</code> <code>bool</code> <p>Whether to enable cache pre-population</p> required Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def set_cache_prepopulation(self, enabled: bool) -&gt; None:  # noqa: FBT001\n    \"\"\"Enable or disable automatic cache pre-population for submissions.\n\n    When enabled (default), the client will fetch all speakers, submission types,\n    and tracks in bulk on the first submission to minimize API calls.\n    Disable this if you're only fetching a few submissions.\n\n    Args:\n        enabled: Whether to enable cache pre-population\n    \"\"\"\n    self._use_cache_prepopulation = enabled\n    _logger.info(f'Cache pre-population {\"enabled\" if enabled else \"disabled\"}')\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.set_throttling","title":"<code>set_throttling(calls: int, seconds: int)</code>","text":"<p>Throttle the number of calls per seconds to the Pretalx API</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def set_throttling(self, calls: int, seconds: int):\n    \"\"\"Throttle the number of calls per seconds to the Pretalx API\"\"\"\n    _logger.info('throttling', calls=calls, seconds=seconds)\n    self._get_throttled = throttle(calls, seconds)(self._get)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.speaker","title":"<code>speaker(event_slug: str, code: str, *, params: QueryParams | dict | None = None) -&gt; Speaker</code>","text":"<p>Returns a specific speaker</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def speaker(self, event_slug: str, code: str, *, params: QueryParams | dict | None = None) -&gt; Speaker:\n    \"\"\"Returns a specific speaker\"\"\"\n    return self._endpoint_id(Speaker, event_slug, 'speakers', code, params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.speakers","title":"<code>speakers(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Speaker]]</code>","text":"<p>Lists all speakers and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def speakers(self, event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Speaker]]:\n    \"\"\"Lists all speakers and their details\"\"\"\n    return self._endpoint_lst(Speaker, event_slug, 'speakers', params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.submission","title":"<code>submission(event_slug: str, code: str, *, params: QueryParams | dict | None = None) -&gt; Submission</code>","text":"<p>Returns a specific submission</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def submission(self, event_slug: str, code: str, *, params: QueryParams | dict | None = None) -&gt; Submission:\n    \"\"\"Returns a specific submission\"\"\"\n    return self._endpoint_id(Submission, event_slug, 'submissions', code, params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.submission_type","title":"<code>submission_type(event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; SubmissionType</code>","text":"<p>Returns a specific submission type</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def submission_type(self, event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; SubmissionType:  # noqa: A002\n    \"\"\"Returns a specific submission type\"\"\"\n    return self._endpoint_id(SubmissionType, event_slug, 'submission-types', id, params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.submission_types","title":"<code>submission_types(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[SubmissionType]]</code>","text":"<p>Lists all submission types and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def submission_types(\n    self, event_slug: str, *, params: QueryParams | dict | None = None\n) -&gt; tuple[int, Iterator[SubmissionType]]:\n    \"\"\"Lists all submission types and their details\"\"\"\n    return self._endpoint_lst(SubmissionType, event_slug, 'submission-types', params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.submissions","title":"<code>submissions(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Submission]]</code>","text":"<p>Lists all submissions and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def submissions(\n    self, event_slug: str, *, params: QueryParams | dict | None = None\n) -&gt; tuple[int, Iterator[Submission]]:\n    \"\"\"Lists all submissions and their details\"\"\"\n    return self._endpoint_lst(Submission, event_slug, 'submissions', params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.tag","title":"<code>tag(event_slug: str, tag: str, *, params: QueryParams | dict | None = None) -&gt; Tag</code>","text":"<p>Returns a specific tag</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def tag(self, event_slug: str, tag: str, *, params: QueryParams | dict | None = None) -&gt; Tag:\n    \"\"\"Returns a specific tag\"\"\"\n    return self._endpoint_id(Tag, event_slug, 'tags', tag, params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.tags","title":"<code>tags(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Tag]]</code>","text":"<p>Lists all tags and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def tags(self, event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Tag]]:\n    \"\"\"Lists all tags and their details\"\"\"\n    return self._endpoint_lst(Tag, event_slug, 'tags', params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.talk","title":"<code>talk(event_slug: str, code: str, *, params: QueryParams | dict | None = None) -&gt; Talk</code>","text":"<p>Returns a specific talk</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def talk(self, event_slug: str, code: str, *, params: QueryParams | dict | None = None) -&gt; Talk:\n    \"\"\"Returns a specific talk\"\"\"\n    try:\n        return self._endpoint_id(Talk, event_slug, 'talks', code, params=params)\n    except httpx.HTTPStatusError as e:\n        if e.response.status_code == HTTPStatus.NOT_FOUND:\n            _logger.info('talk endpoint not available, using submission endpoint')\n            # Use submission endpoint but validate as Talk object\n            return self._endpoint_id(Talk, event_slug, 'submissions', code, params=params)\n        raise\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.talks","title":"<code>talks(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Talk]]</code>","text":"<p>Lists all talks and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def talks(self, event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Talk]]:\n    \"\"\"Lists all talks and their details\"\"\"\n    try:\n        return self._endpoint_lst(Talk, event_slug, 'talks', params=params)\n    except httpx.HTTPStatusError as e:\n        if e.response.status_code == HTTPStatus.NOT_FOUND:\n            _logger.info('talks endpoint not available, using submissions endpoint')\n            # Use submissions endpoint but validate as Talk objects\n            return self._endpoint_lst(Talk, event_slug, 'submissions', params=params)\n        raise\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.track","title":"<code>track(event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Track</code>","text":"<p>Returns a specific track</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def track(self, event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Track:  # noqa: A002\n    \"\"\"Returns a specific track\"\"\"\n    return self._endpoint_id(Track, event_slug, 'tracks', id, params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.PretalxClient.tracks","title":"<code>tracks(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Track]]</code>","text":"<p>Lists all tracks and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def tracks(self, event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Track]]:\n    \"\"\"Lists all tracks and their details\"\"\"\n    return self._endpoint_lst(Track, event_slug, 'tracks', params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.SimpleTalk","title":"<code>SimpleTalk</code>","text":"<p>Simplified Talk model for generating JSON output</p> <p>This model contains only the essential information needed for display purposes.</p>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.SimpleTalk.abstract","title":"<code>abstract: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.SimpleTalk.code","title":"<code>code: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.SimpleTalk.description","title":"<code>description: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.SimpleTalk.domain_level","title":"<code>domain_level: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.SimpleTalk.duration","title":"<code>duration: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.SimpleTalk.organisation","title":"<code>organisation: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.SimpleTalk.prerequisites","title":"<code>prerequisites: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.SimpleTalk.python_level","title":"<code>python_level: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.SimpleTalk.speaker","title":"<code>speaker: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.SimpleTalk.title","title":"<code>title: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.SimpleTalk.track","title":"<code>track: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.get_confirmed_talks_as_json","title":"<code>get_confirmed_talks_as_json(pretalx_client: PretalxClient, event_slug: str, params: dict[str, Any] | None = None) -&gt; str</code>","text":"<p>Get confirmed talks from pretalx and convert them to JSON (legacy function for backward compatibility).</p> <p>Parameters:</p> Name Type Description Default <code>pretalx_client</code> <code>PretalxClient</code> <p>PretalxClient instance to fetch talk and speaker data</p> required <code>event_slug</code> <code>str</code> <p>Event slug for the pretalx event</p> required <code>params</code> <code>dict[str, Any] | None</code> <p>Additional parameters to pass to the pretalx API</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>A JSON string containing a list of SimpleTalk objects</p> Source code in <code>src/pytanis/pretalx/utils.py</code> <pre><code>def get_confirmed_talks_as_json(\n    pretalx_client: PretalxClient, event_slug: str, params: dict[str, Any] | None = None\n) -&gt; str:\n    \"\"\"\n    Get confirmed talks from pretalx and convert them to JSON (legacy function for backward compatibility).\n\n    Args:\n        pretalx_client: PretalxClient instance to fetch talk and speaker data\n        event_slug: Event slug for the pretalx event\n        params: Additional parameters to pass to the pretalx API\n\n    Returns:\n        A JSON string containing a list of SimpleTalk objects\n    \"\"\"\n    return get_talks_as_json(pretalx_client, event_slug, 'confirmed', params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.get_talks_as_json","title":"<code>get_talks_as_json(pretalx_client: PretalxClient, event_slug: str, state_value: str = 'confirmed', params: dict[str, Any] | None = None) -&gt; str</code>","text":"<p>Get talks from pretalx and convert them to a JSON list of SimpleTalk objects.</p> <p>This function fetches talks from pretalx based on the specified state, extracts the essential information, and returns a JSON string containing a list of simplified talk objects.</p> <p>Parameters:</p> Name Type Description Default <code>pretalx_client</code> <code>PretalxClient</code> <p>PretalxClient instance to fetch talk and speaker data</p> required <code>event_slug</code> <code>str</code> <p>Event slug for the pretalx event</p> required <code>state_value</code> <code>str</code> <p>State of talks to include (default: \"confirmed\")</p> <code>'confirmed'</code> <code>params</code> <code>dict[str, Any] | None</code> <p>Additional parameters to pass to the pretalx API</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>A JSON string containing a list of SimpleTalk objects</p> Source code in <code>src/pytanis/pretalx/utils.py</code> <pre><code>def get_talks_as_json(\n    pretalx_client: PretalxClient, event_slug: str, state_value: str = 'confirmed', params: dict[str, Any] | None = None\n) -&gt; str:\n    \"\"\"\n    Get talks from pretalx and convert them to a JSON list of SimpleTalk objects.\n\n    This function fetches talks from pretalx based on the specified state,\n    extracts the essential information, and returns a JSON string containing\n    a list of simplified talk objects.\n\n    Args:\n        pretalx_client: PretalxClient instance to fetch talk and speaker data\n        event_slug: Event slug for the pretalx event\n        state_value: State of talks to include (default: \"confirmed\")\n        params: Additional parameters to pass to the pretalx API\n\n    Returns:\n        A JSON string containing a list of SimpleTalk objects\n    \"\"\"\n    # Prepare parameters for the API call\n    if params is None:\n        params = {}\n\n    # Ensure we get all questions and filter by state\n    params['questions'] = 'all'\n    params['state'] = state_value\n\n    # Fetch talks from pretalx\n    _, talks_iter = pretalx_client.talks(event_slug, params=params)\n    talks = list(talks_iter)  # Materialize the iterator\n\n    return talks_to_json(talks, pretalx_client, event_slug)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.reviews_as_df","title":"<code>reviews_as_df(reviews: Iterable[Review]) -&gt; pd.DataFrame</code>","text":"<p>Convert the reviews to a dataframe</p> Source code in <code>src/pytanis/pretalx/utils.py</code> <pre><code>def reviews_as_df(reviews: Iterable[Review]) -&gt; pd.DataFrame:\n    \"\"\"Convert the reviews to a dataframe\"\"\"\n    df = pd.DataFrame([review.model_dump() for review in reviews])\n    # make first letter of column upper-case in accordance with our convention\n    df.rename(columns={col: col.title() for col in df.columns}, inplace=True)\n    # user is the speaker name to use for joining\n    df.rename(columns={'User': Col.pretalx_user, 'Score': Col.review_score}, inplace=True)\n\n    return df\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.save_confirmed_talks_to_json","title":"<code>save_confirmed_talks_to_json(talks: Iterable[Talk], file_path: str, pretalx_client: PretalxClient | None = None, event_slug: str | None = None) -&gt; None</code>","text":"<p>Save confirmed talks to a JSON file (legacy function for backward compatibility).</p> <p>Parameters:</p> Name Type Description Default <code>talks</code> <code>Iterable[Talk]</code> <p>An iterable of Talk objects, typically from pretalx_client.talks()</p> required <code>file_path</code> <code>str</code> <p>Path where the JSON file should be saved</p> required <code>pretalx_client</code> <code>PretalxClient | None</code> <p>Optional PretalxClient instance to fetch speaker data</p> <code>None</code> <code>event_slug</code> <code>str | None</code> <p>Optional event slug needed if pretalx_client is provided</p> <code>None</code> Source code in <code>src/pytanis/pretalx/utils.py</code> <pre><code>def save_confirmed_talks_to_json(\n    talks: Iterable[Talk], file_path: str, pretalx_client: PretalxClient | None = None, event_slug: str | None = None\n) -&gt; None:\n    \"\"\"\n    Save confirmed talks to a JSON file (legacy function for backward compatibility).\n\n    Args:\n        talks: An iterable of Talk objects, typically from pretalx_client.talks()\n        file_path: Path where the JSON file should be saved\n        pretalx_client: Optional PretalxClient instance to fetch speaker data\n        event_slug: Optional event slug needed if pretalx_client is provided\n    \"\"\"\n    json_data = talks_to_json([talk for talk in talks if talk.state.value == 'confirmed'], pretalx_client, event_slug)\n\n    with open(file_path, 'w', encoding='utf-8') as f:\n        f.write(json_data)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.save_talks_to_json","title":"<code>save_talks_to_json(pretalx_client: PretalxClient, event_slug: str, file_path: str, state_value: str = 'confirmed', params: dict[str, Any] | None = None) -&gt; None</code>","text":"<p>Fetch talks from pretalx and save them to a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>pretalx_client</code> <code>PretalxClient</code> <p>PretalxClient instance to fetch talk and speaker data</p> required <code>event_slug</code> <code>str</code> <p>Event slug for the pretalx event</p> required <code>file_path</code> <code>str</code> <p>Path where the JSON file should be saved</p> required <code>state_value</code> <code>str</code> <p>State of talks to include (default: \"confirmed\")</p> <code>'confirmed'</code> <code>params</code> <code>dict[str, Any] | None</code> <p>Additional parameters to pass to the pretalx API</p> <code>None</code> Source code in <code>src/pytanis/pretalx/utils.py</code> <pre><code>def save_talks_to_json(\n    pretalx_client: PretalxClient,\n    event_slug: str,\n    file_path: str,\n    state_value: str = 'confirmed',\n    params: dict[str, Any] | None = None,\n) -&gt; None:\n    \"\"\"\n    Fetch talks from pretalx and save them to a JSON file.\n\n    Args:\n        pretalx_client: PretalxClient instance to fetch talk and speaker data\n        event_slug: Event slug for the pretalx event\n        file_path: Path where the JSON file should be saved\n        state_value: State of talks to include (default: \"confirmed\")\n        params: Additional parameters to pass to the pretalx API\n    \"\"\"\n    json_data = get_talks_as_json(pretalx_client, event_slug, state_value, params)\n\n    with open(file_path, 'w', encoding='utf-8') as f:\n        f.write(json_data)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.speakers_as_df","title":"<code>speakers_as_df(speakers: Iterable[Speaker], *, with_questions: bool = False, question_prefix: str = 'Q: ') -&gt; pd.DataFrame</code>","text":"<p>Convert speakers into a dataframe</p> <p>Make sure to have <code>params={\"questions\": \"all\"}</code> for the PretalxAPI if <code>with_questions</code> is True.</p> Source code in <code>src/pytanis/pretalx/utils.py</code> <pre><code>def speakers_as_df(\n    speakers: Iterable[Speaker], *, with_questions: bool = False, question_prefix: str = 'Q: '\n) -&gt; pd.DataFrame:\n    \"\"\"Convert speakers into a dataframe\n\n    Make sure to have `params={\"questions\": \"all\"}` for the PretalxAPI if `with_questions` is True.\n    \"\"\"\n    rows = []\n    for speaker in speakers:\n        row = {\n            Col.speaker_code: speaker.code,\n            Col.speaker_name: speaker.name,\n            Col.email: speaker.email,\n            Col.biography: speaker.biography,\n            Col.submission: speaker.submissions,\n        }\n        if with_questions and speaker.answers is not None:\n            for answer in speaker.answers:\n                # The API returns also questions that are 'per proposal/submission', we get these using the\n                # submission endpoint and don't want them here due to ambiguity if several submission were made.\n                if isinstance(answer, int):\n                    # answers can be a list of ints now / API v1\n                    continue\n                if answer.person is not None:\n                    row[f'{question_prefix}{answer.question.question.en}'] = answer.answer\n        rows.append(row)\n    return pd.DataFrame(rows)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.subs_as_df","title":"<code>subs_as_df(subs: Iterable[Submission], *, with_questions: bool = False, question_prefix: str = 'Q: ') -&gt; pd.DataFrame</code>","text":"<p>Convert submissions into a dataframe</p> <p>Make sure to have <code>params={\"questions\": \"all\"}</code> for the PretalxAPI if <code>with_questions</code> is True.</p> Source code in <code>src/pytanis/pretalx/utils.py</code> <pre><code>def subs_as_df(\n    subs: Iterable[Submission], *, with_questions: bool = False, question_prefix: str = 'Q: '\n) -&gt; pd.DataFrame:\n    \"\"\"Convert submissions into a dataframe\n\n    Make sure to have `params={\"questions\": \"all\"}` for the PretalxAPI if `with_questions` is True.\n    \"\"\"\n    rows = []\n    for sub in subs:\n        row = {\n            Col.submission: sub.code,\n            Col.title: sub.title,\n            Col.track: sub.track.en if sub.track else None,\n            Col.speaker_code: [speaker.code for speaker in sub.speakers],\n            Col.speaker_name: [speaker.name for speaker in sub.speakers],\n            Col.duration: sub.duration,\n            Col.submission_type: (\n                sub.submission_type.en if hasattr(sub.submission_type, 'en') else str(sub.submission_type)\n            ),\n            Col.submission_type_id: sub.submission_type_id,\n            Col.state: sub.state.value,\n            Col.pending_state: None if sub.pending_state is None else sub.pending_state.value,\n            Col.created: sub.created,\n        }\n        if with_questions and sub.answers is not None:\n            for answer in sub.answers:\n                row[f'{question_prefix}{answer.question.question.en}'] = answer.answer\n        rows.append(row)\n    return pd.DataFrame(rows)\n</code></pre>"},{"location":"reference/pytanis/pretalx/#pytanis.pretalx.talks_to_json","title":"<code>talks_to_json(talks: Iterable[Talk], pretalx_client: PretalxClient | None = None, event_slug: str | None = None) -&gt; str</code>","text":"<p>Convert Talk objects to a JSON list of SimpleTalk objects.</p> <p>This function extracts the essential information from pretalx Talk objects and returns a JSON string containing a list of simplified talk objects.</p> <p>Parameters:</p> Name Type Description Default <code>talks</code> <code>Iterable[Talk]</code> <p>An iterable of Talk objects</p> required <code>pretalx_client</code> <code>PretalxClient | None</code> <p>Optional PretalxClient instance to fetch speaker data</p> <code>None</code> <code>event_slug</code> <code>str | None</code> <p>Optional event slug needed if pretalx_client is provided</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>A JSON string containing a list of SimpleTalk objects</p> Source code in <code>src/pytanis/pretalx/utils.py</code> <pre><code>def talks_to_json(\n    talks: Iterable[Talk], pretalx_client: PretalxClient | None = None, event_slug: str | None = None\n) -&gt; str:\n    \"\"\"\n    Convert Talk objects to a JSON list of SimpleTalk objects.\n\n    This function extracts the essential information from pretalx Talk objects\n    and returns a JSON string containing a list of simplified talk objects.\n\n    Args:\n        talks: An iterable of Talk objects\n        pretalx_client: Optional PretalxClient instance to fetch speaker data\n        event_slug: Optional event slug needed if pretalx_client is provided\n\n    Returns:\n        A JSON string containing a list of SimpleTalk objects\n    \"\"\"\n    simple_talks = []\n\n    # Store speaker data to avoid fetching the same speaker multiple times\n    speaker_data: dict[str, Speaker] = {}\n\n    for talk in talks:\n        # Create a SimpleTalk object with basic information\n        simple_talk = create_simple_talk_from_talk(talk)\n\n        # Extract expertise levels and prerequisites\n        extract_expertise_and_prerequisites(talk, simple_talk)\n\n        # Extract organisation information\n        if event_slug and pretalx_client:\n            extract_organisation(talk, simple_talk, pretalx_client, event_slug, speaker_data)\n\n        simple_talks.append(simple_talk)\n\n    # Convert to JSON\n    return json.dumps([talk.model_dump() for talk in simple_talks], indent=2)\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/","title":"Client","text":""},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client","title":"<code>client</code>","text":"<p>Client for the Pretalx API</p> <p>Documentation: https://docs.pretalx.org/api/resources/index.html</p> <p>ToDo</p> <ul> <li>add additional parameters explicitly like querying according to the API</li> </ul>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.JSON","title":"<code>JSON: TypeAlias = JSONObj | JSONLst</code>  <code>module-attribute</code>","text":"<p>Type of the JSON response as returned by the Pretalx API</p>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.JSONLst","title":"<code>JSONLst: TypeAlias = list[JSONObj]</code>  <code>module-attribute</code>","text":"<p>Type of a JSON list of JSON objects</p>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.JSONObj","title":"<code>JSONObj: TypeAlias = dict[str, Any]</code>  <code>module-attribute</code>","text":"<p>Type of a JSON object (without recursion)</p>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.T","title":"<code>T = TypeVar('T', bound=BaseModel)</code>  <code>module-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient","title":"<code>PretalxClient(config: Config | None = None, *, blocking: bool = False)</code>","text":"<p>Client for the Pretalx API</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def __init__(self, config: Config | None = None, *, blocking: bool = False):\n    if config is None:\n        config = get_cfg()\n    self._config = config\n    self._get_throttled = self._get\n    self.blocking = blocking\n    self.set_throttling(calls=2, seconds=1)  # we are nice by default and Pretalx doesn't allow many calls at once.\n\n    # Caches for expanded objects (session-only, not persisted)\n    self._speaker_cache: dict[str, dict] = {}\n    self._submission_type_cache: dict[int, dict] = {}\n    self._track_cache: dict[int, dict] = {}\n    self._answer_cache: dict[int, dict | None] = {}\n    self._question_cache: dict[int, dict] = {}\n    self._caches_populated: dict[str, bool] = {}  # Track which event caches are populated\n    self._use_cache_prepopulation: bool = True  # Enable cache pre-population by default\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.blocking","title":"<code>blocking = blocking</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.__validate","title":"<code>__validate(model_type, result)</code>  <code>classmethod</code>","text":"Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>@classmethod\ndef __validate(cls, model_type, result):\n    try:\n        validated = model_type.model_validate(result)\n        return validated\n    except Exception as e:\n        # introduced to deal with API changes\n        _logger.error('result', resp=e)\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.answer","title":"<code>answer(event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Answer</code>","text":"<p>Returns a specific answer</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def answer(self, event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Answer:  # noqa: A002\n    \"\"\"Returns a specific answer\"\"\"\n    return self._endpoint_id(Answer, event_slug, 'answers', id, params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.answers","title":"<code>answers(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Answer]]</code>","text":"<p>Lists all answers and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def answers(self, event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Answer]]:\n    \"\"\"Lists all answers and their details\"\"\"\n    return self._endpoint_lst(Answer, event_slug, 'answers', params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.clear_caches","title":"<code>clear_caches() -&gt; None</code>","text":"<p>Clear all session caches.</p> <p>This is useful if you want to force fresh data to be fetched from the API. Note that caches are session-only and are not persisted between client instances.</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def clear_caches(self) -&gt; None:\n    \"\"\"Clear all session caches.\n\n    This is useful if you want to force fresh data to be fetched from the API.\n    Note that caches are session-only and are not persisted between client instances.\n    \"\"\"\n    self._speaker_cache.clear()\n    self._submission_type_cache.clear()\n    self._track_cache.clear()\n    self._answer_cache.clear()\n    self._question_cache.clear()\n    self._caches_populated.clear()\n    _logger.info('All caches cleared')\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.event","title":"<code>event(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; Event</code>","text":"<p>Returns detailed information about a specific event</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def event(self, event_slug: str, *, params: QueryParams | dict | None = None) -&gt; Event:\n    \"\"\"Returns detailed information about a specific event\"\"\"\n    endpoint = f'/api/events/{event_slug}/'\n    result = self._get_one(endpoint, params)\n    _logger.debug('result', resp=result)\n    return self.__validate(Event, result)\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.events","title":"<code>events(*, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Event]]</code>","text":"<p>Lists all events and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def events(self, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Event]]:\n    \"\"\"Lists all events and their details\"\"\"\n    count, results = self._get_many('/api/events/', params)\n    events = iter(_logger.debug('result', resp=r) or Event.model_validate(r) for r in results)\n    return count, events\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.me","title":"<code>me() -&gt; Me</code>  <code>classmethod</code>","text":"<p>Returns what Pretalx knows about myself</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>@classmethod\ndef me(cls) -&gt; Me:\n    \"\"\"Returns what Pretalx knows about myself\"\"\"\n    # removed in API update v1\n    msg = 'This endpoint is no longer provided since API v1.'\n    raise RuntimeError(msg)\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.question","title":"<code>question(event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Question</code>","text":"<p>Returns a specific question</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def question(self, event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Question:  # noqa: A002\n    \"\"\"Returns a specific question\"\"\"\n    return self._endpoint_id(Question, event_slug, 'questions', id, params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.questions","title":"<code>questions(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Question]]</code>","text":"<p>Lists all questions and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def questions(self, event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Question]]:\n    \"\"\"Lists all questions and their details\"\"\"\n    return self._endpoint_lst(Question, event_slug, 'questions', params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.review","title":"<code>review(event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Review</code>","text":"<p>Returns a specific review</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def review(self, event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Review:  # noqa: A002\n    \"\"\"Returns a specific review\"\"\"\n    return self._endpoint_id(Review, event_slug, 'reviews', id, params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.reviews","title":"<code>reviews(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Review]]</code>","text":"<p>Lists all reviews and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def reviews(self, event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Review]]:\n    \"\"\"Lists all reviews and their details\"\"\"\n    return self._endpoint_lst(Review, event_slug, 'reviews', params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.room","title":"<code>room(event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Room</code>","text":"<p>Returns a specific room</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def room(self, event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Room:  # noqa: A002\n    \"\"\"Returns a specific room\"\"\"\n    return self._endpoint_id(Room, event_slug, 'rooms', id, params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.rooms","title":"<code>rooms(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Room]]</code>","text":"<p>Lists all rooms and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def rooms(self, event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Room]]:\n    \"\"\"Lists all rooms and their details\"\"\"\n    return self._endpoint_lst(Room, event_slug, 'rooms', params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.set_cache_prepopulation","title":"<code>set_cache_prepopulation(enabled: bool) -&gt; None</code>","text":"<p>Enable or disable automatic cache pre-population for submissions.</p> <p>When enabled (default), the client will fetch all speakers, submission types, and tracks in bulk on the first submission to minimize API calls. Disable this if you're only fetching a few submissions.</p> <p>Parameters:</p> Name Type Description Default <code>enabled</code> <code>bool</code> <p>Whether to enable cache pre-population</p> required Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def set_cache_prepopulation(self, enabled: bool) -&gt; None:  # noqa: FBT001\n    \"\"\"Enable or disable automatic cache pre-population for submissions.\n\n    When enabled (default), the client will fetch all speakers, submission types,\n    and tracks in bulk on the first submission to minimize API calls.\n    Disable this if you're only fetching a few submissions.\n\n    Args:\n        enabled: Whether to enable cache pre-population\n    \"\"\"\n    self._use_cache_prepopulation = enabled\n    _logger.info(f'Cache pre-population {\"enabled\" if enabled else \"disabled\"}')\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.set_throttling","title":"<code>set_throttling(calls: int, seconds: int)</code>","text":"<p>Throttle the number of calls per seconds to the Pretalx API</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def set_throttling(self, calls: int, seconds: int):\n    \"\"\"Throttle the number of calls per seconds to the Pretalx API\"\"\"\n    _logger.info('throttling', calls=calls, seconds=seconds)\n    self._get_throttled = throttle(calls, seconds)(self._get)\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.speaker","title":"<code>speaker(event_slug: str, code: str, *, params: QueryParams | dict | None = None) -&gt; Speaker</code>","text":"<p>Returns a specific speaker</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def speaker(self, event_slug: str, code: str, *, params: QueryParams | dict | None = None) -&gt; Speaker:\n    \"\"\"Returns a specific speaker\"\"\"\n    return self._endpoint_id(Speaker, event_slug, 'speakers', code, params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.speakers","title":"<code>speakers(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Speaker]]</code>","text":"<p>Lists all speakers and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def speakers(self, event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Speaker]]:\n    \"\"\"Lists all speakers and their details\"\"\"\n    return self._endpoint_lst(Speaker, event_slug, 'speakers', params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.submission","title":"<code>submission(event_slug: str, code: str, *, params: QueryParams | dict | None = None) -&gt; Submission</code>","text":"<p>Returns a specific submission</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def submission(self, event_slug: str, code: str, *, params: QueryParams | dict | None = None) -&gt; Submission:\n    \"\"\"Returns a specific submission\"\"\"\n    return self._endpoint_id(Submission, event_slug, 'submissions', code, params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.submission_type","title":"<code>submission_type(event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; SubmissionType</code>","text":"<p>Returns a specific submission type</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def submission_type(self, event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; SubmissionType:  # noqa: A002\n    \"\"\"Returns a specific submission type\"\"\"\n    return self._endpoint_id(SubmissionType, event_slug, 'submission-types', id, params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.submission_types","title":"<code>submission_types(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[SubmissionType]]</code>","text":"<p>Lists all submission types and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def submission_types(\n    self, event_slug: str, *, params: QueryParams | dict | None = None\n) -&gt; tuple[int, Iterator[SubmissionType]]:\n    \"\"\"Lists all submission types and their details\"\"\"\n    return self._endpoint_lst(SubmissionType, event_slug, 'submission-types', params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.submissions","title":"<code>submissions(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Submission]]</code>","text":"<p>Lists all submissions and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def submissions(\n    self, event_slug: str, *, params: QueryParams | dict | None = None\n) -&gt; tuple[int, Iterator[Submission]]:\n    \"\"\"Lists all submissions and their details\"\"\"\n    return self._endpoint_lst(Submission, event_slug, 'submissions', params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.tag","title":"<code>tag(event_slug: str, tag: str, *, params: QueryParams | dict | None = None) -&gt; Tag</code>","text":"<p>Returns a specific tag</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def tag(self, event_slug: str, tag: str, *, params: QueryParams | dict | None = None) -&gt; Tag:\n    \"\"\"Returns a specific tag\"\"\"\n    return self._endpoint_id(Tag, event_slug, 'tags', tag, params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.tags","title":"<code>tags(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Tag]]</code>","text":"<p>Lists all tags and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def tags(self, event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Tag]]:\n    \"\"\"Lists all tags and their details\"\"\"\n    return self._endpoint_lst(Tag, event_slug, 'tags', params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.talk","title":"<code>talk(event_slug: str, code: str, *, params: QueryParams | dict | None = None) -&gt; Talk</code>","text":"<p>Returns a specific talk</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def talk(self, event_slug: str, code: str, *, params: QueryParams | dict | None = None) -&gt; Talk:\n    \"\"\"Returns a specific talk\"\"\"\n    try:\n        return self._endpoint_id(Talk, event_slug, 'talks', code, params=params)\n    except httpx.HTTPStatusError as e:\n        if e.response.status_code == HTTPStatus.NOT_FOUND:\n            _logger.info('talk endpoint not available, using submission endpoint')\n            # Use submission endpoint but validate as Talk object\n            return self._endpoint_id(Talk, event_slug, 'submissions', code, params=params)\n        raise\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.talks","title":"<code>talks(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Talk]]</code>","text":"<p>Lists all talks and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def talks(self, event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Talk]]:\n    \"\"\"Lists all talks and their details\"\"\"\n    try:\n        return self._endpoint_lst(Talk, event_slug, 'talks', params=params)\n    except httpx.HTTPStatusError as e:\n        if e.response.status_code == HTTPStatus.NOT_FOUND:\n            _logger.info('talks endpoint not available, using submissions endpoint')\n            # Use submissions endpoint but validate as Talk objects\n            return self._endpoint_lst(Talk, event_slug, 'submissions', params=params)\n        raise\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.track","title":"<code>track(event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Track</code>","text":"<p>Returns a specific track</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def track(self, event_slug: str, id: int, *, params: QueryParams | dict | None = None) -&gt; Track:  # noqa: A002\n    \"\"\"Returns a specific track\"\"\"\n    return self._endpoint_id(Track, event_slug, 'tracks', id, params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/client/#pytanis.pretalx.client.PretalxClient.tracks","title":"<code>tracks(event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Track]]</code>","text":"<p>Lists all tracks and their details</p> Source code in <code>src/pytanis/pretalx/client.py</code> <pre><code>def tracks(self, event_slug: str, *, params: QueryParams | dict | None = None) -&gt; tuple[int, Iterator[Track]]:\n    \"\"\"Lists all tracks and their details\"\"\"\n    return self._endpoint_lst(Track, event_slug, 'tracks', params=params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/models/","title":"Models","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models","title":"<code>models</code>","text":"<p>Return types of the Pretalx API</p> <p>Documentation: https://docs.pretalx.org/api/resources/index.html</p> <p>Attention: Quite often the API docs and the actual results of the API differ!</p> <p>ToDo</p> <ul> <li>Find out why <code>extra=Extra.allow</code> causes mypy to fail. Seems like a bug in pydantic.</li> </ul>"},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Answer","title":"<code>Answer</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Answer.answer","title":"<code>answer: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Answer.answer_file","title":"<code>answer_file: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Answer.id","title":"<code>id: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Answer.options","title":"<code>options: list[Option] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Answer.person","title":"<code>person: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Answer.question","title":"<code>question: AnswerQuestionRef | AnswerQuestion | Any</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Answer.review","title":"<code>review: int | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Answer.submission","title":"<code>submission: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.AnswerQuestion","title":"<code>AnswerQuestion</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.AnswerQuestion.id","title":"<code>id: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.AnswerQuestion.model_config","title":"<code>model_config = ConfigDict(extra='ignore')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.AnswerQuestion.question","title":"<code>question: MultiLingualStr</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.AnswerQuestionRef","title":"<code>AnswerQuestionRef</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.AnswerQuestionRef.id","title":"<code>id: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.AnswerQuestionRef.question","title":"<code>question: MultiLingualStr</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Event","title":"<code>Event</code>","text":"<p>Event model for Pretalx API.</p> <p>Note: The 'urls' field was present in older API versions but is no longer provided by the API as of v1/v2. It's kept as optional for backward compatibility.</p>"},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Event.date_from","title":"<code>date_from: date</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Event.date_to","title":"<code>date_to: date | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Event.is_public","title":"<code>is_public: bool</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Event.name","title":"<code>name: MultiLingualStr</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Event.slug","title":"<code>slug: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Event.timezone","title":"<code>timezone: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Event.urls","title":"<code>urls: URLs | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Me","title":"<code>Me</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Me.email","title":"<code>email: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Me.local","title":"<code>local: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Me.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Me.timezone","title":"<code>timezone: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.MultiLingualStr","title":"<code>MultiLingualStr</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.MultiLingualStr.de","title":"<code>de: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.MultiLingualStr.en","title":"<code>en: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.MultiLingualStr.model_config","title":"<code>model_config = ConfigDict(extra='allow')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Option","title":"<code>Option</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Option.answer","title":"<code>answer: MultiLingualStr</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Option.id","title":"<code>id: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Question","title":"<code>Question</code>","text":"<p>Pretalx introduced breaking API changes in 06/2025 with API \"v1\": These are the extra attributes that are provide via the questions endpoint but noct in the subdocuments in e.g., submissions</p>"},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Question.contains_personal_data","title":"<code>contains_personal_data: bool</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Question.is_public","title":"<code>is_public: bool</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Question.is_visible_to_reviewers","title":"<code>is_visible_to_reviewers: bool</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.QuestionRequirement","title":"<code>QuestionRequirement</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.QuestionRequirement.after_deadline","title":"<code>after_deadline = 'after deadline'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.QuestionRequirement.optional","title":"<code>optional = 'optional'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.QuestionRequirement.required","title":"<code>required = 'required'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.QuestionSimple","title":"<code>QuestionSimple</code>","text":"<p>Subset of questions that are used for nested responses, e.g., in Submission.answers Question is the full model that is used in the questions endpoint</p>"},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.QuestionSimple.contains_personal_data","title":"<code>contains_personal_data: bool</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.QuestionSimple.deadline","title":"<code>deadline: datetime | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.QuestionSimple.default_answer","title":"<code>default_answer: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.QuestionSimple.freeze_after","title":"<code>freeze_after: datetime | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.QuestionSimple.help_text","title":"<code>help_text: MultiLingualStr</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.QuestionSimple.id","title":"<code>id: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.QuestionSimple.is_public","title":"<code>is_public: bool</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.QuestionSimple.is_visible_to_reviewers","title":"<code>is_visible_to_reviewers: bool</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.QuestionSimple.max_length","title":"<code>max_length: int | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.QuestionSimple.min_length","title":"<code>min_length: int | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.QuestionSimple.options","title":"<code>options: list[Option]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.QuestionSimple.question","title":"<code>question: MultiLingualStr</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.QuestionSimple.question_required","title":"<code>question_required: QuestionRequirement</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.QuestionSimple.read_only","title":"<code>read_only: bool | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.QuestionSimple.required","title":"<code>required: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.QuestionSimple.target","title":"<code>target: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.QuestionSimple.variant","title":"<code>variant: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.QuestionSimple.is_required","title":"<code>is_required()</code>","text":"Source code in <code>src/pytanis/pretalx/models.py</code> <pre><code>@model_validator(mode='after')\ndef is_required(self):\n    if self.question_required and self.question_required != QuestionRequirement.optional:\n        self.required = True\n    else:\n        self.required = False\n    return self\n</code></pre>"},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Resource","title":"<code>Resource</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Resource.description","title":"<code>description: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Resource.resource","title":"<code>resource: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Review","title":"<code>Review</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Review.answers","title":"<code>answers: list[str]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Review.created","title":"<code>created: datetime</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Review.id","title":"<code>id: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Review.score","title":"<code>score: float | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Review.submission","title":"<code>submission: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Review.text","title":"<code>text: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Review.updated","title":"<code>updated: datetime</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Review.user","title":"<code>user: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Room","title":"<code>Room</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Room.availabilities","title":"<code>availabilities: list[RoomAvailability] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Room.capacity","title":"<code>capacity: int | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Room.description","title":"<code>description: MultiLingualStr</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Room.id","title":"<code>id: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Room.name","title":"<code>name: MultiLingualStr</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Room.position","title":"<code>position: int | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Room.speaker_info","title":"<code>speaker_info: MultiLingualStr | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.RoomAvailability","title":"<code>RoomAvailability</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.RoomAvailability.end","title":"<code>end: datetime</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.RoomAvailability.start","title":"<code>start: datetime</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.SimpleTalk","title":"<code>SimpleTalk</code>","text":"<p>Simplified Talk model for generating JSON output</p> <p>This model contains only the essential information needed for display purposes.</p>"},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.SimpleTalk.abstract","title":"<code>abstract: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.SimpleTalk.code","title":"<code>code: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.SimpleTalk.description","title":"<code>description: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.SimpleTalk.domain_level","title":"<code>domain_level: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.SimpleTalk.duration","title":"<code>duration: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.SimpleTalk.organisation","title":"<code>organisation: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.SimpleTalk.prerequisites","title":"<code>prerequisites: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.SimpleTalk.python_level","title":"<code>python_level: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.SimpleTalk.speaker","title":"<code>speaker: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.SimpleTalk.title","title":"<code>title: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.SimpleTalk.track","title":"<code>track: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Slot","title":"<code>Slot</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Slot.end","title":"<code>end: datetime | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Slot.room","title":"<code>room: MultiLingualStr | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Slot.room_id","title":"<code>room_id: int | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Slot.start","title":"<code>start: datetime | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Speaker","title":"<code>Speaker</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Speaker.answers","title":"<code>answers: list[Answer | int] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Speaker.availabilities","title":"<code>availabilities: list[SpeakerAvailability] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Speaker.submissions","title":"<code>submissions: list[str]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.SpeakerAvailability","title":"<code>SpeakerAvailability</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.SpeakerAvailability.allDay","title":"<code>allDay: str = Field(..., alias='all_day')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.SpeakerAvailability.end","title":"<code>end: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.SpeakerAvailability.id","title":"<code>id: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.SpeakerAvailability.start","title":"<code>start: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.State","title":"<code>State</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.State.accepted","title":"<code>accepted = 'accepted'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.State.canceled","title":"<code>canceled = 'canceled'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.State.confirmed","title":"<code>confirmed = 'confirmed'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.State.deleted","title":"<code>deleted = 'deleted'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.State.rejected","title":"<code>rejected = 'rejected'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.State.submitted","title":"<code>submitted = 'submitted'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.State.withdrawn","title":"<code>withdrawn = 'withdrawn'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Submission","title":"<code>Submission</code>","text":"<p>Pretalx introduced breaking API changes in 06/2025 with API \"v1\": - submission_type changed: TempSubmissionType can handle this now,   a validator will mangel the data back to the old format MultiLingualStr - submission_type_id: no longer exists, will be set via submission_type now - is_featured is documented but does not show, defaults to False now</p>"},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Submission.abstract","title":"<code>abstract: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Submission.answers","title":"<code>answers: list[Answer] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Submission.code","title":"<code>code: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Submission.created","title":"<code>created: datetime | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Submission.description","title":"<code>description: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Submission.do_not_record","title":"<code>do_not_record: bool</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Submission.duration","title":"<code>duration: int | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Submission.image","title":"<code>image: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Submission.internal_notes","title":"<code>internal_notes: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Submission.is_featured","title":"<code>is_featured: bool</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Submission.notes","title":"<code>notes: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Submission.pending_state","title":"<code>pending_state: State | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Submission.resources","title":"<code>resources: list[Resource]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Submission.slot","title":"<code>slot: Slot | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Submission.slot_count","title":"<code>slot_count: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Submission.speakers","title":"<code>speakers: list[SubmissionSpeaker]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Submission.state","title":"<code>state: State</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Submission.submission_type","title":"<code>submission_type: TransSubmissionType | MultiLingualStr</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Submission.submission_type_id","title":"<code>submission_type_id: int | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Submission.tag_ids","title":"<code>tag_ids: list[int] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Submission.tags","title":"<code>tags: list[str] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Submission.title","title":"<code>title: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Submission.track","title":"<code>track: MultiLingualStr | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Submission.track_id","title":"<code>track_id: int | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Submission.mangle_submission_type","title":"<code>mangle_submission_type()</code>","text":"<p>This is required to handle changes introduced via API v1</p> Source code in <code>src/pytanis/pretalx/models.py</code> <pre><code>@model_validator(mode='after')\ndef mangle_submission_type(self):\n    \"\"\"This is required to handle changes introduced via API v1\"\"\"\n    if self.submission_type:\n        self.submission_type_id = getattr(self.submission_type, 'id', None)\n        self.submission_type = getattr(self.submission_type, 'name', None)\n    return self\n</code></pre>"},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.SubmissionSpeaker","title":"<code>SubmissionSpeaker</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.SubmissionSpeaker.avatar","title":"<code>avatar: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.SubmissionSpeaker.biography","title":"<code>biography: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.SubmissionSpeaker.code","title":"<code>code: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.SubmissionSpeaker.email","title":"<code>email: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.SubmissionSpeaker.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.SubmissionType","title":"<code>SubmissionType</code>","text":"<p>Submission type model for internal use in caching</p>"},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.SubmissionType.default_duration","title":"<code>default_duration: int | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.SubmissionType.id","title":"<code>id: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.SubmissionType.name","title":"<code>name: MultiLingualStr</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Tag","title":"<code>Tag</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Tag.color","title":"<code>color: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Tag.description","title":"<code>description: MultiLingualStr</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Tag.tag","title":"<code>tag: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Talk","title":"<code>Talk</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Track","title":"<code>Track</code>","text":"<p>Track model for internal use in caching</p>"},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Track.color","title":"<code>color: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Track.description","title":"<code>description: MultiLingualStr | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Track.id","title":"<code>id: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.Track.name","title":"<code>name: MultiLingualStr</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.TransSubmissionType","title":"<code>TransSubmissionType</code>","text":"<p>Model to keep previous and new models aligned due to changes in API v1</p>"},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.TransSubmissionType.id","title":"<code>id: int</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.TransSubmissionType.model_config","title":"<code>model_config = ConfigDict(extra='allow')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.TransSubmissionType.name","title":"<code>name: MultiLingualStr</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.URLs","title":"<code>URLs</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.URLs.base","title":"<code>base: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.URLs.feed","title":"<code>feed: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.URLs.login","title":"<code>login: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.URLs.schedule","title":"<code>schedule: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.User","title":"<code>User</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.User.email","title":"<code>email: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/models/#pytanis.pretalx.models.User.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/utils/","title":"Utils","text":""},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils","title":"<code>utils</code>","text":"<p>Utilities related to Pretalx</p>"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col","title":"<code>Col</code>","text":"<p>Convention of Pretalx column names for the functions below.</p>"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.affiliation","title":"<code>affiliation = 'Affiliation'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.availability","title":"<code>availability = 'Availability'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.availability_comment","title":"<code>availability_comment = 'Availability Comment'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.biography","title":"<code>biography = 'Biography'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.comment","title":"<code>comment = 'Comment'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.created","title":"<code>created = 'Created'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.duration","title":"<code>duration = 'Duration'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.email","title":"<code>email = 'Email'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.nreviews","title":"<code>nreviews = '#Reviews'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.pending_state","title":"<code>pending_state = 'Pending state'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.pretalx_user","title":"<code>pretalx_user = 'Pretalx user'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.public","title":"<code>public = 'Public'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.review_score","title":"<code>review_score = 'Review Score'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.speaker_code","title":"<code>speaker_code = 'Speaker code'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.speaker_name","title":"<code>speaker_name = 'Speaker name'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.state","title":"<code>state = 'State'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.submission","title":"<code>submission = 'Submission'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.submission_type","title":"<code>submission_type = 'Submission type'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.submission_type_id","title":"<code>submission_type_id = 'Submission type id'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.title","title":"<code>title = 'Title'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.Col.track","title":"<code>track = 'Track'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.create_simple_talk_from_talk","title":"<code>create_simple_talk_from_talk(talk: Talk) -&gt; SimpleTalk</code>","text":"<p>Create a SimpleTalk object with basic information from a Talk object.</p> Source code in <code>src/pytanis/pretalx/utils.py</code> <pre><code>def create_simple_talk_from_talk(talk: Talk) -&gt; SimpleTalk:\n    \"\"\"Create a SimpleTalk object with basic information from a Talk object.\"\"\"\n    track_value = ''\n    if talk.track is not None and talk.track.en is not None:\n        track_value = talk.track.en\n\n    return SimpleTalk(\n        code=talk.code,\n        title=talk.title,\n        speaker=', '.join([speaker.name for speaker in talk.speakers]),\n        track=track_value,\n        duration=str(talk.duration) if talk.duration else '',\n        abstract=talk.abstract,\n        description=talk.description,\n    )\n</code></pre>"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.extract_expertise_and_prerequisites","title":"<code>extract_expertise_and_prerequisites(talk: Talk, simple_talk: SimpleTalk) -&gt; None</code>","text":"<p>Extract expertise levels and prerequisites from talk answers.</p> Source code in <code>src/pytanis/pretalx/utils.py</code> <pre><code>def extract_expertise_and_prerequisites(talk: Talk, simple_talk: SimpleTalk) -&gt; None:\n    \"\"\"Extract expertise levels and prerequisites from talk answers.\"\"\"\n    if not talk.answers:\n        return\n\n    # Extract domain expertise level\n    domain_expertise = find_answer_by_pattern(talk.answers, 'Expected audience expertise: Domain')\n\n    # Extract Python expertise level\n    python_expertise = find_answer_by_pattern(talk.answers, 'Expected audience expertise: Python')\n\n    # Extract prerequisites using keywords\n    prerequisites = find_answer_by_pattern(\n        talk.answers, '', case_sensitive=False, keywords=['prerequisite', 'requirement', 'needed', 'necessary']\n    )\n\n    # Set the extracted values\n    simple_talk.domain_level = domain_expertise\n    simple_talk.python_level = python_expertise\n    simple_talk.prerequisites = prerequisites\n</code></pre>"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.extract_organisation","title":"<code>extract_organisation(talk: Talk, simple_talk: SimpleTalk, pretalx_client: PretalxClient, event_slug: str, speaker_data: dict[str, Speaker]) -&gt; None</code>","text":"<p>Extract organisation information from speaker data.</p> Source code in <code>src/pytanis/pretalx/utils.py</code> <pre><code>def extract_organisation(\n    talk: Talk,\n    simple_talk: SimpleTalk,\n    pretalx_client: PretalxClient,\n    event_slug: str,\n    speaker_data: dict[str, Speaker],\n) -&gt; None:\n    \"\"\"Extract organisation information from speaker data.\"\"\"\n    if not (pretalx_client and event_slug):\n        return\n\n    organisations = []\n\n    for speaker in talk.speakers:\n        # Check if we already have this speaker's data\n        if speaker.code not in speaker_data:\n            try:\n                # Fetch speaker data with answers\n                speaker_data[speaker.code] = pretalx_client.speaker(\n                    event_slug, speaker.code, params={'questions': 'all'}\n                )\n            except Exception as e:\n                # If there's an error fetching speaker data, just continue\n                _logger.error(f'Error fetching data for speaker {speaker.code}: {e}')\n                continue\n\n        # Get the speaker with full data including answers\n        full_speaker = speaker_data[speaker.code]\n\n        # Look for \"Company / Institute\" in speaker answers\n        if full_speaker.answers:\n            # Filter to only include speaker-specific answers\n            speaker_answers = [\n                answer\n                for answer in full_speaker.answers\n                if not isinstance(answer, int) and answer.person is not None and hasattr(answer, 'person')\n            ]\n\n            # Find the organisation using our helper function\n            organisation = find_answer_by_pattern(speaker_answers, 'Company / Institute')\n            if organisation.strip():\n                organisations.append(organisation.strip())\n\n    # If we found organisations in the speaker answers, use them\n    if organisations:\n        # Remove duplicates while preserving order\n        unique_organisations = []\n        for org in organisations:\n            if org not in unique_organisations:\n                unique_organisations.append(org)\n        simple_talk.organisation = ', '.join(unique_organisations)\n</code></pre>"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.find_answer_by_pattern","title":"<code>find_answer_by_pattern(answers: list[Answer], pattern: str, *, case_sensitive: bool = True, keywords: list[str] | None = None) -&gt; str</code>","text":"<p>Find an answer by matching a pattern or keywords in the question text.</p> <p>Parameters:</p> Name Type Description Default <code>answers</code> <code>list[Answer]</code> <p>List of Answer objects to search through</p> required <code>pattern</code> <code>str</code> <p>Exact pattern to search for in question text</p> required <code>case_sensitive</code> <code>bool</code> <p>Whether the pattern matching should be case sensitive</p> <code>True</code> <code>keywords</code> <code>list[str] | None</code> <p>List of keywords to search for in question text (case insensitive)</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The answer text if found, empty string otherwise</p> Source code in <code>src/pytanis/pretalx/utils.py</code> <pre><code>def find_answer_by_pattern(\n    answers: list[Answer], pattern: str, *, case_sensitive: bool = True, keywords: list[str] | None = None\n) -&gt; str:\n    \"\"\"Find an answer by matching a pattern or keywords in the question text.\n\n    Args:\n        answers: List of Answer objects to search through\n        pattern: Exact pattern to search for in question text\n        case_sensitive: Whether the pattern matching should be case sensitive\n        keywords: List of keywords to search for in question text (case insensitive)\n\n    Returns:\n        The answer text if found, empty string otherwise\n    \"\"\"\n    if not answers:\n        return ''\n\n    for answer in answers:\n        question_text = answer.question.question.en or ''\n\n        # Check for exact pattern match\n        if pattern:\n            if case_sensitive and pattern in question_text:\n                return answer.answer\n            elif not case_sensitive and pattern.lower() in question_text.lower():\n                return answer.answer\n\n        # Check for keywords match\n        if keywords and any(keyword.lower() in question_text.lower() for keyword in keywords):\n            return answer.answer\n\n    return ''\n</code></pre>"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.get_confirmed_talks_as_json","title":"<code>get_confirmed_talks_as_json(pretalx_client: PretalxClient, event_slug: str, params: dict[str, Any] | None = None) -&gt; str</code>","text":"<p>Get confirmed talks from pretalx and convert them to JSON (legacy function for backward compatibility).</p> <p>Parameters:</p> Name Type Description Default <code>pretalx_client</code> <code>PretalxClient</code> <p>PretalxClient instance to fetch talk and speaker data</p> required <code>event_slug</code> <code>str</code> <p>Event slug for the pretalx event</p> required <code>params</code> <code>dict[str, Any] | None</code> <p>Additional parameters to pass to the pretalx API</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>A JSON string containing a list of SimpleTalk objects</p> Source code in <code>src/pytanis/pretalx/utils.py</code> <pre><code>def get_confirmed_talks_as_json(\n    pretalx_client: PretalxClient, event_slug: str, params: dict[str, Any] | None = None\n) -&gt; str:\n    \"\"\"\n    Get confirmed talks from pretalx and convert them to JSON (legacy function for backward compatibility).\n\n    Args:\n        pretalx_client: PretalxClient instance to fetch talk and speaker data\n        event_slug: Event slug for the pretalx event\n        params: Additional parameters to pass to the pretalx API\n\n    Returns:\n        A JSON string containing a list of SimpleTalk objects\n    \"\"\"\n    return get_talks_as_json(pretalx_client, event_slug, 'confirmed', params)\n</code></pre>"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.get_talks_as_json","title":"<code>get_talks_as_json(pretalx_client: PretalxClient, event_slug: str, state_value: str = 'confirmed', params: dict[str, Any] | None = None) -&gt; str</code>","text":"<p>Get talks from pretalx and convert them to a JSON list of SimpleTalk objects.</p> <p>This function fetches talks from pretalx based on the specified state, extracts the essential information, and returns a JSON string containing a list of simplified talk objects.</p> <p>Parameters:</p> Name Type Description Default <code>pretalx_client</code> <code>PretalxClient</code> <p>PretalxClient instance to fetch talk and speaker data</p> required <code>event_slug</code> <code>str</code> <p>Event slug for the pretalx event</p> required <code>state_value</code> <code>str</code> <p>State of talks to include (default: \"confirmed\")</p> <code>'confirmed'</code> <code>params</code> <code>dict[str, Any] | None</code> <p>Additional parameters to pass to the pretalx API</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>A JSON string containing a list of SimpleTalk objects</p> Source code in <code>src/pytanis/pretalx/utils.py</code> <pre><code>def get_talks_as_json(\n    pretalx_client: PretalxClient, event_slug: str, state_value: str = 'confirmed', params: dict[str, Any] | None = None\n) -&gt; str:\n    \"\"\"\n    Get talks from pretalx and convert them to a JSON list of SimpleTalk objects.\n\n    This function fetches talks from pretalx based on the specified state,\n    extracts the essential information, and returns a JSON string containing\n    a list of simplified talk objects.\n\n    Args:\n        pretalx_client: PretalxClient instance to fetch talk and speaker data\n        event_slug: Event slug for the pretalx event\n        state_value: State of talks to include (default: \"confirmed\")\n        params: Additional parameters to pass to the pretalx API\n\n    Returns:\n        A JSON string containing a list of SimpleTalk objects\n    \"\"\"\n    # Prepare parameters for the API call\n    if params is None:\n        params = {}\n\n    # Ensure we get all questions and filter by state\n    params['questions'] = 'all'\n    params['state'] = state_value\n\n    # Fetch talks from pretalx\n    _, talks_iter = pretalx_client.talks(event_slug, params=params)\n    talks = list(talks_iter)  # Materialize the iterator\n\n    return talks_to_json(talks, pretalx_client, event_slug)\n</code></pre>"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.reviews_as_df","title":"<code>reviews_as_df(reviews: Iterable[Review]) -&gt; pd.DataFrame</code>","text":"<p>Convert the reviews to a dataframe</p> Source code in <code>src/pytanis/pretalx/utils.py</code> <pre><code>def reviews_as_df(reviews: Iterable[Review]) -&gt; pd.DataFrame:\n    \"\"\"Convert the reviews to a dataframe\"\"\"\n    df = pd.DataFrame([review.model_dump() for review in reviews])\n    # make first letter of column upper-case in accordance with our convention\n    df.rename(columns={col: col.title() for col in df.columns}, inplace=True)\n    # user is the speaker name to use for joining\n    df.rename(columns={'User': Col.pretalx_user, 'Score': Col.review_score}, inplace=True)\n\n    return df\n</code></pre>"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.save_confirmed_talks_to_json","title":"<code>save_confirmed_talks_to_json(talks: Iterable[Talk], file_path: str, pretalx_client: PretalxClient | None = None, event_slug: str | None = None) -&gt; None</code>","text":"<p>Save confirmed talks to a JSON file (legacy function for backward compatibility).</p> <p>Parameters:</p> Name Type Description Default <code>talks</code> <code>Iterable[Talk]</code> <p>An iterable of Talk objects, typically from pretalx_client.talks()</p> required <code>file_path</code> <code>str</code> <p>Path where the JSON file should be saved</p> required <code>pretalx_client</code> <code>PretalxClient | None</code> <p>Optional PretalxClient instance to fetch speaker data</p> <code>None</code> <code>event_slug</code> <code>str | None</code> <p>Optional event slug needed if pretalx_client is provided</p> <code>None</code> Source code in <code>src/pytanis/pretalx/utils.py</code> <pre><code>def save_confirmed_talks_to_json(\n    talks: Iterable[Talk], file_path: str, pretalx_client: PretalxClient | None = None, event_slug: str | None = None\n) -&gt; None:\n    \"\"\"\n    Save confirmed talks to a JSON file (legacy function for backward compatibility).\n\n    Args:\n        talks: An iterable of Talk objects, typically from pretalx_client.talks()\n        file_path: Path where the JSON file should be saved\n        pretalx_client: Optional PretalxClient instance to fetch speaker data\n        event_slug: Optional event slug needed if pretalx_client is provided\n    \"\"\"\n    json_data = talks_to_json([talk for talk in talks if talk.state.value == 'confirmed'], pretalx_client, event_slug)\n\n    with open(file_path, 'w', encoding='utf-8') as f:\n        f.write(json_data)\n</code></pre>"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.save_talks_to_json","title":"<code>save_talks_to_json(pretalx_client: PretalxClient, event_slug: str, file_path: str, state_value: str = 'confirmed', params: dict[str, Any] | None = None) -&gt; None</code>","text":"<p>Fetch talks from pretalx and save them to a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>pretalx_client</code> <code>PretalxClient</code> <p>PretalxClient instance to fetch talk and speaker data</p> required <code>event_slug</code> <code>str</code> <p>Event slug for the pretalx event</p> required <code>file_path</code> <code>str</code> <p>Path where the JSON file should be saved</p> required <code>state_value</code> <code>str</code> <p>State of talks to include (default: \"confirmed\")</p> <code>'confirmed'</code> <code>params</code> <code>dict[str, Any] | None</code> <p>Additional parameters to pass to the pretalx API</p> <code>None</code> Source code in <code>src/pytanis/pretalx/utils.py</code> <pre><code>def save_talks_to_json(\n    pretalx_client: PretalxClient,\n    event_slug: str,\n    file_path: str,\n    state_value: str = 'confirmed',\n    params: dict[str, Any] | None = None,\n) -&gt; None:\n    \"\"\"\n    Fetch talks from pretalx and save them to a JSON file.\n\n    Args:\n        pretalx_client: PretalxClient instance to fetch talk and speaker data\n        event_slug: Event slug for the pretalx event\n        file_path: Path where the JSON file should be saved\n        state_value: State of talks to include (default: \"confirmed\")\n        params: Additional parameters to pass to the pretalx API\n    \"\"\"\n    json_data = get_talks_as_json(pretalx_client, event_slug, state_value, params)\n\n    with open(file_path, 'w', encoding='utf-8') as f:\n        f.write(json_data)\n</code></pre>"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.speakers_as_df","title":"<code>speakers_as_df(speakers: Iterable[Speaker], *, with_questions: bool = False, question_prefix: str = 'Q: ') -&gt; pd.DataFrame</code>","text":"<p>Convert speakers into a dataframe</p> <p>Make sure to have <code>params={\"questions\": \"all\"}</code> for the PretalxAPI if <code>with_questions</code> is True.</p> Source code in <code>src/pytanis/pretalx/utils.py</code> <pre><code>def speakers_as_df(\n    speakers: Iterable[Speaker], *, with_questions: bool = False, question_prefix: str = 'Q: '\n) -&gt; pd.DataFrame:\n    \"\"\"Convert speakers into a dataframe\n\n    Make sure to have `params={\"questions\": \"all\"}` for the PretalxAPI if `with_questions` is True.\n    \"\"\"\n    rows = []\n    for speaker in speakers:\n        row = {\n            Col.speaker_code: speaker.code,\n            Col.speaker_name: speaker.name,\n            Col.email: speaker.email,\n            Col.biography: speaker.biography,\n            Col.submission: speaker.submissions,\n        }\n        if with_questions and speaker.answers is not None:\n            for answer in speaker.answers:\n                # The API returns also questions that are 'per proposal/submission', we get these using the\n                # submission endpoint and don't want them here due to ambiguity if several submission were made.\n                if isinstance(answer, int):\n                    # answers can be a list of ints now / API v1\n                    continue\n                if answer.person is not None:\n                    row[f'{question_prefix}{answer.question.question.en}'] = answer.answer\n        rows.append(row)\n    return pd.DataFrame(rows)\n</code></pre>"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.subs_as_df","title":"<code>subs_as_df(subs: Iterable[Submission], *, with_questions: bool = False, question_prefix: str = 'Q: ') -&gt; pd.DataFrame</code>","text":"<p>Convert submissions into a dataframe</p> <p>Make sure to have <code>params={\"questions\": \"all\"}</code> for the PretalxAPI if <code>with_questions</code> is True.</p> Source code in <code>src/pytanis/pretalx/utils.py</code> <pre><code>def subs_as_df(\n    subs: Iterable[Submission], *, with_questions: bool = False, question_prefix: str = 'Q: '\n) -&gt; pd.DataFrame:\n    \"\"\"Convert submissions into a dataframe\n\n    Make sure to have `params={\"questions\": \"all\"}` for the PretalxAPI if `with_questions` is True.\n    \"\"\"\n    rows = []\n    for sub in subs:\n        row = {\n            Col.submission: sub.code,\n            Col.title: sub.title,\n            Col.track: sub.track.en if sub.track else None,\n            Col.speaker_code: [speaker.code for speaker in sub.speakers],\n            Col.speaker_name: [speaker.name for speaker in sub.speakers],\n            Col.duration: sub.duration,\n            Col.submission_type: (\n                sub.submission_type.en if hasattr(sub.submission_type, 'en') else str(sub.submission_type)\n            ),\n            Col.submission_type_id: sub.submission_type_id,\n            Col.state: sub.state.value,\n            Col.pending_state: None if sub.pending_state is None else sub.pending_state.value,\n            Col.created: sub.created,\n        }\n        if with_questions and sub.answers is not None:\n            for answer in sub.answers:\n                row[f'{question_prefix}{answer.question.question.en}'] = answer.answer\n        rows.append(row)\n    return pd.DataFrame(rows)\n</code></pre>"},{"location":"reference/pytanis/pretalx/utils/#pytanis.pretalx.utils.talks_to_json","title":"<code>talks_to_json(talks: Iterable[Talk], pretalx_client: PretalxClient | None = None, event_slug: str | None = None) -&gt; str</code>","text":"<p>Convert Talk objects to a JSON list of SimpleTalk objects.</p> <p>This function extracts the essential information from pretalx Talk objects and returns a JSON string containing a list of simplified talk objects.</p> <p>Parameters:</p> Name Type Description Default <code>talks</code> <code>Iterable[Talk]</code> <p>An iterable of Talk objects</p> required <code>pretalx_client</code> <code>PretalxClient | None</code> <p>Optional PretalxClient instance to fetch speaker data</p> <code>None</code> <code>event_slug</code> <code>str | None</code> <p>Optional event slug needed if pretalx_client is provided</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>A JSON string containing a list of SimpleTalk objects</p> Source code in <code>src/pytanis/pretalx/utils.py</code> <pre><code>def talks_to_json(\n    talks: Iterable[Talk], pretalx_client: PretalxClient | None = None, event_slug: str | None = None\n) -&gt; str:\n    \"\"\"\n    Convert Talk objects to a JSON list of SimpleTalk objects.\n\n    This function extracts the essential information from pretalx Talk objects\n    and returns a JSON string containing a list of simplified talk objects.\n\n    Args:\n        talks: An iterable of Talk objects\n        pretalx_client: Optional PretalxClient instance to fetch speaker data\n        event_slug: Optional event slug needed if pretalx_client is provided\n\n    Returns:\n        A JSON string containing a list of SimpleTalk objects\n    \"\"\"\n    simple_talks = []\n\n    # Store speaker data to avoid fetching the same speaker multiple times\n    speaker_data: dict[str, Speaker] = {}\n\n    for talk in talks:\n        # Create a SimpleTalk object with basic information\n        simple_talk = create_simple_talk_from_talk(talk)\n\n        # Extract expertise levels and prerequisites\n        extract_expertise_and_prerequisites(talk, simple_talk)\n\n        # Extract organisation information\n        if event_slug and pretalx_client:\n            extract_organisation(talk, simple_talk, pretalx_client, event_slug, speaker_data)\n\n        simple_talks.append(simple_talk)\n\n    # Convert to JSON\n    return json.dumps([talk.model_dump() for talk in simple_talks], indent=2)\n</code></pre>"},{"location":"tasks/cfp/","title":"The Call for Participation Process","text":""},{"location":"tasks/cfp/#overview","title":"Overview","text":"<p>The organisation of your conference programme starts with the Call for Participation/Proposals (CfP). Before you announce your CfP, obvious things to consider are:</p> <ul> <li>what is the audience we are trying to address? Beginners, experts, ... also first-time speakers, diverse &amp; underrepresented groups.</li> <li>what information do wee need to know about our speakers? Name, country, biography, affiliation, job &amp; position, social media, on-site availability, ...</li> <li>what are the topics of interest for our conference? How are those tracks named? E.g. PyCon: Libraries, PyData: Machine Learning &amp; Stats, ...</li> <li>what is the presentation format, i.e. session types? 30min, 45min talks (including 5min Q&amp;A), 90min tutorials...</li> <li>should a financial aid program be offered? Check out the Financial Aid Programme of PyconDE / PyData 2023 Berlin for an example.</li> <li>what are the rough milestones/deadlines of the whole process? See below for an example.</li> <li>what is the deadline of the CfP? Do we want to extend it later on? Do we have enough time for the reviews?</li> </ul> <p>An example CfP can be found on the Call for Proposals of the PyConDE / PyData 2023 Berlin. The actual CfP submission is handled easily by Pretalx as you can just fill out everything in the web UI. As these tasks are all purely organisational/conceptional, there is no need to use Pytanis for any of this.</p>"},{"location":"tasks/cfp/#example-milestones-of-pyconde-pydata-2023-berlin","title":"Example: Milestones of PyConDE / PyData 2023 Berlin","text":"<ul> <li>2022-12-11: (Sunday) CfP opens</li> <li>2022-12-14: Financial Aid Program opens</li> <li>2023-01-05: (Thursday) -&gt; Extension 2023-01-09 (Monday) CfP closes. [Voting can be prepared beforehand via Pretalx.]</li> <li>2023-01-06: (Friday) Open the Review for external Reviewers</li> <li>2023-01-11: Q&amp;A session 1 for external reviewers, 30min at 5pm</li> <li>2023-01-17: Q&amp;A session 2 for external reviewers, 30min at 5pm</li> <li>2022-01-16: Financial Aid Program closes (2 weeks to select)</li> <li>2023-01-16: Ticket sales opens</li> <li>2023-01-16: (Monday) till 2023-01-23 (Sunday) talk voting over Pretalx (1 week)</li> <li>2023-01-31: (Tuesday) deadline for external &amp; internal reviewers</li> <li>2023-02-13: (Monday) acceptance notices to speakers</li> <li>2023-02-14: (Tuesday) publish list of accepted talks</li> <li>2023-02-20: Financial Aid applicants will be notified by e-mail about acceptance or rejection</li> <li>2023-03-01: (Wednesday) publish talk schedule via Pretalx</li> <li>2022-03-07: Ticket prices increase to switch to late bird pricing</li> <li>2023-04-16: Set-up-day, the night before the conference \ud83c\udf89</li> <li>2023-04-17: (Monday) conference starts, we have a lift-off \ud83d\ude80</li> </ul> <p>Warning</p> <p>Obviously, you should never announce a CfP extension before the deadline of the original CfP is over \ud83d\ude1c. It is also useful to keep some of the above deadlines internally to avoid receiving a lot of emails when you have missed the deadline \ud83d\ude48.</p>"},{"location":"tasks/review/","title":"The Review Process","text":""},{"location":"tasks/review/#overview","title":"Overview","text":"<p>On a high-level, the review process of the proposals for a conference works as follows:</p> <ol> <li>find external reviewers and learn about their preferences,</li> <li>onboard reviewers in Pretalx,</li> <li>assign proposals to reviewers according to their preferences,</li> <li>communicate with the reviewers occasionally for updates,</li> <li>track the whole process.</li> </ol>"},{"location":"tasks/review/#1-find-external-reviewers-and-learn-about-their-preferences","title":"1. Find External Reviewers and Learn about their Preferences","text":"<p>For the PyConDE / PyData Berlin 2023, we were looking for about 50 external reviewers since we expected about 400 proposals, and we wanted to have 3 reviews per proposal. This would amount to about 25 proposals to review per person, which is manageable within a few weeks if you schedule 5-15 minutes per proposal.</p> <p>To get external reviewers, we decided that would only ask within our (Program Committee members') circle of trust and refer them to Google Forms. The form basically consisted of following questions with descriptions:</p> <ul> <li>Name [short answer]: Please write your name starting with your first name, e.g. Albert Einstein.</li> <li>Affiliation [short answer]: Please state the name or organisation you are affiliated with.</li> <li>Who do you know from the Committee? [short answer]: We believe in the ring of trust model. With this question, we really only   want to make sure that random people are not signing up with no connection to any member of the Program Committee.</li> <li>Availability during the Review Period [checkboxes]: The bulk of the review work will take place from January 5<sup>th</sup> to February   13<sup>th</sup>, 2023, so it is important that you are broadly available during this period. That being said, you will be quite   flexible in managing your time but being on vacation with no internet for 3 weeks might be suboptimal here ;-)   There was only one mandatory checkbox: Yes, I am broadly available during this period.</li> <li>Additional comments regarding your availability during the review period. [long answer]</li> <li>Topics you want to review: These are the topics you are interested in reviewing. The more you select the better.   Don't be shy, you don't have to be an expert in a topic to review a proposal. If you are interested in a topic and   have some knowledge about it, you are totally up for the job :-)   Each track in Pretalx corresponded to one checkbox in this form. At least 5 preferences needed to be chosen.</li> <li>Do you want your name to be listed as a reviewer on the conference website? [checkbox] Mandatory yes/no checkboxes</li> <li>Any additional comments for the Program Committee [long answer]</li> </ul> <p>Tip</p> <ul> <li>Google Form will use the separator <code>,</code> (comma, whitespace) for the selected checkboxes. Having the same separator   in your track name, e.g. \"General: Community, Diversity, Career, Life and everything else\", will make it a bit harder   to parse the resulting Google Sheet. So it's better to avoid them in track names.</li> <li>Depending on how you want to assign proposals to reviewers later, it might also make sense to ask the reviewers if   they only want to be assigned a single batch, or if they are also interested in getting more proposals to review after   their batch is done.</li> </ul> <p>Every submission of the Google Form is then automatically added to a Google Sheet, let's call it the volunteer sheet, which can be easily read with the help of Pytanis. Check out our Google Sheet docs and Pytanis' google module to learn about more functionality.</p>"},{"location":"tasks/review/#2-onboard-reviewers-in-pretalx","title":"2. Onboard Reviewers in Pretalx","text":"<p>In Pretalx select Organisers in the left menu bar (you need Admin-rights for that) and click the teams under your event name. You should see a list of all teams and it's a good idea to have one for all reviewers, e.g. <code>2023-Reviewers-ALL</code>. By clicking on the team name you get to a page that lists the names and corresponding e-mails of team members as well as an option to add new members at the bottom.</p> <p>You can now start typing in the e-mail addresses from the volunteer sheet to send out invitations to them. After volunteers accept the invitation they will show up with a user-name and e-mail in the team table. Now, here comes the tricky part that can cause a lot of confusion. If person A entered in the Google Form the e-mail address <code>work@mail.com</code>, and you added this in Pretalx, it might happen that person A accepts the team invitation with a different Pretalx account that is linked to the e-mail address <code>private@mail.com</code>. In this case, Pretalx will automatically replace <code>work@mail.com</code>, which was used for the invitation, with <code>private@mail.com</code> in the Pretalx table of team members. Unfortunately, Pretalx has no way of automatically tracking this change of mail addresses and this issue, as filed in #1417, is still unresolved.</p> <p>To work around this email issue and to be able to later join your volunteer sheet for instance with reviews, it makes sense to introduce a new column, e.g. \"Pretalx mail\", where you add the actual Pretalx account e-mail that was used by the invited user. Additionally, you should have a column for the Pretalx user-name, e.g. \"Pretalx user\", where you state the user-name by copying it over from the Pretalx team member table. This user-name column will be useful later to join our volunteer reviewers with the reviews they did, because the review-endpoint of Pretalx only returns the user-name, not the e-mail of a reviewer. This problem was also discussed in #1416 and is an intended behaviour.</p>"},{"location":"tasks/review/#3-assign-proposals-to-reviewers-according-to-their-preferences","title":"3. Assign Proposals to Reviewers according to their Preferences","text":"<p>Pretalx already provides a basic assignment feature so that proposals with the least number of reviews will show up earlier in the review queue so that they get more reviews. Additionally, Pretalx allows uploading a mapping JSON file so that you can assign certain proposals to a reviewer matching their preferences with the tracks of the proposals. Also, Pretalx is working on more elaborate automatic assignment features and some discussion about it can be found in issue #1331.</p> <p>Pytanis allows you to create JSON mapping files that can be uploaded in Pretalx under Review \u00bb Assign reviews. Then click Actions (upper right) \u00bb Import assignments and select the option <code>Assign proposals to reviewers</code>, choose the JSON file and make sure to always set <code>Replace current assignments</code> to <code>Yes</code>. Overwriting the current assignments makes sure that the assignment state in Pretalx is always consistent with what you expect. Also, be sure to always back up your assignment files somewhere in case you need to roll back later on. To make this easy, just name your files <code>assignments-YYYYMMDD_I.json</code>, where <code>YYYY</code> is the current year, <code>MM</code> the month, <code>DD</code> the day in the month and <code>I</code> the version increment, e.g. <code>1</code> or <code>2</code>, in case you need several assignments throughout the same day.</p> <p>So how do you create an assignment file using Pytanis? Currently, we have implemented in a notebook an initial simple algorithm that can be easily run. Fancier algorithms will come in the future and don't hesitate to contribute. The main idea of the algorithm is to set a goal of number of reviews for each proposal, e.g. 3 reviews, and a certain buffer, e.g. 1. This means every proposal is assigned to goal number of reviews + buffer - current review number in case the current review number is not already equal or greater than the goal number of reviews. Rerunning this assignment frequently helps to avoid overshooting as the buffer mainly addresses the fact that you will also have inactive reviewers or some that start on the last day before your review deadline. For each proposal and remaining review, the algorithm assigns the proposals to:</p> <ul> <li>not a person having already assigned the review for a proposal (no duplicates),</li> <li>to a person having a preference for the track with the least amount of current work,</li> <li>if no person has a preference for the track of the proposal, assign to someone with not much work.</li> </ul> <p>Be aware that some of your reviewers might have also make proposal submissions. Thus, it might happen by chance that someone gets assigned his/her own proposal using this approach but luckily Pretalx takes care of that--if the same Pretalx account was used.</p> <p>This quite simple algorithm can be found in the notebook 10_reviewer-assignment_v1. It uses Pytanis to pull the submission/proposals as well as the current reviews from Pretalx and joins them to get an overview of the current state of reviews. Then Pytanis is used to get the Google sheet of reviewers and their preferences, which is also joined with the data from Pretalx. Then the aforementioned algorithm is run and the assignment JSON file written.</p>"},{"location":"tasks/review/#4-communicate-with-the-reviewers-occasionally-for-updates","title":"4. Communicate with the Reviewers occasionally for Updates","text":"<p>From time to time, you want to get in contact with your reviewers to remind them of some deadline or just to say thank you for their work. Pytanis has an easy interface to HelpDesk that can be used as an e-mail client. For some practical examples, just check out the notebook 20_mail_to_reviewers_v1, the docs about mailing, as well as the Pytanis' mail references.</p>"},{"location":"tasks/review/#5-track-the-whole-process","title":"5. Track the whole process","text":"<p>During the review process it very important to keep track of review activity to make sure your internal deadlines for the review process are met. For instance, there might be reviewers that are having difficulties but have not reached out yet. So finding inactivate reviewers after a certain period of time and sending a nice supportive e-mail helps a lot. Also, some reviewers might have finished their batch of work early but might be up for more, thus identifying and getting in contact with them, is always a good idea. Many of those analyses are really individual, and you can check our examples in the notebook 10_reviewer-assignment_v1.</p>"},{"location":"tasks/schedule/","title":"Creating the Schedule","text":"<p>After all you talks and tutorials are confirmed, the next major milestone is to create a schedule so that each talk gets a time and place to be presented. Pretalx allows you to create a schedule by dragging &amp; dropping the talk blocks onto a schedule, where you can define the number of days and rooms. You can also specify breaks like lunch or coffee breaks and later on publish the schedule for everyone. So this feature is pretty need but for larger conferences with a lot of parallel sessions, i.e. many rooms, some help might be needed.</p> <p>Assuming that you had some blank schedule before that already defines the time slots with their lengths and when the breaks are, then surely following constraints must be satisfied:</p> <ul> <li>each talk must be assigned to a time slot,</li> <li>each room/time slot combination can only be occupied by one talk at most,</li> <li>the length of the time slot must match the length of the talk,</li> <li>if some talks/tutorials have several parts, e.g. part 1 &amp; 2, they must be consecutive.</li> </ul> <p>Besides those constraints you might want to optimize for several objectives:</p> <ol> <li>the preferences for day and time of the speakers are considered (if they provided some),</li> <li>the more popular a talk is (from the public voting data), the more capacity the assigned room should have,</li> <li>if many people are highly interested in seeing two talks (voting data), these talks should rather not be scheduled in parallel.    Also, sponsored talks should never be in parallel to avoid cannibalization,</li> <li>talks should have same main track, e.g. PyData, if they are in the same session (block of talks in one room),</li> <li>talks should have same sub track, e.g. PyData: Data Handling, if they are in the same session.</li> </ol> <p>The easiest way of dealing with multi-objective optimization is to create one new main objective by weighting and summing all objectives. For the objectives outlined above, it surely makes sense to choose the weights so that the importance is 1 &gt; 2 &gt; 3 &gt; 4 &gt; 5.</p> <p>In the notebook 50_scheduling_v1, you can find an example that uses Mixed-Integer-Programming (MIP) to generate a preliminary schedule that can be used as a starting point before creating the schedule in Pretalx. Although the constraints and objective from above may look quite simple, MIPs are not only hard, they are even NP-hard ;-) The example in the notebook uses Pyomo to formulate the problem and transform it into a standardized form, so that the solver HiGHS can do its job. In the concrete example, even after 24h no perfect solution was found, but the good thing is that the gap between best found feasible solution and the maximum possible objective value, i.e. the gap, was relatively small.</p> <p>Again, to visualize a solution like this, you can push it easily with the help of Pytanis to Google Sheets,  which is illustrated in the figure below.</p> <p>Tip</p> <p>If you want to also specify link previews, sometimes also called a social banners, then check out the notebook 40_talk_image_v1 on how Pytanis can help you to create them.</p>"},{"location":"tasks/selection/","title":"The Selection Process","text":""},{"location":"tasks/selection/#overview","title":"Overview","text":"<p>On a high-level, the selection process involves the following</p> <ol> <li>have an optional public voting for the proposals,</li> <li>decide on how many talks, tutorials in which length, track or skill level you want to have,</li> <li>get an overview of the proposals, the speakers, the reviewer scores, and optionally the vote scores,</li> <li>select in Pretalx which talks are accepted and which ones are not.</li> </ol>"},{"location":"tasks/selection/#1-optional-public-voting","title":"1. Optional Public Voting","text":"<p>The pretalx-public-voting plugin allows to vote for the proposals which is a nice signal if a talk is generally interesting to the audience or not, solely based on the title and abstract. If it is installed activate it in Pretalx under Settings \u00bb Public voting. After the end date of the voting has passed this is also the place where you can download the results as a csv file. Unfortunately, there is currently no API provided by Pretalx for this feature.</p>"},{"location":"tasks/selection/#2-decision-on-number-of-talks-and-rules-for-acceptance","title":"2. Decision on Number of Talks and Rules for Acceptance","text":"<p>Deciding on the rules of acceptance might be one of the hardest parts and no Software can support you with it. It is really important to do this early on since it will help with the actual selection process. In order to decide for instance for the number of talks/tutorials in various lengths, it's important to already have a blank schedule, i.e. just the time slots, at hand. Diversity is also an important topic, so one rule might be to over-represent the under-represented but by how much? And do you expect your audience to be rather advanced, even senior, and what does that mean for ratio of the various required skill levels of the talks? How about the tracks you defined? Are speakers allowed to give more than one talk? How to deal with talks that have been given before? It's best to decide on a few guidelines before you proceed with the next steps.</p>"},{"location":"tasks/selection/#3-overview-of-the-proposals","title":"3. Overview of the proposals","text":"<p>Getting an overview of all proposals, their features, their review score and optionally their public score, is crucial when it comes to make a selection. Luckily with the help of Pytanis this is really easy. You can pull all the data from Pretalx, join it with additional data like the voting scores and push it to a Google Sheet, where everyone can easily view it and add comments. Find a practical example on how Pytanis was used for the PyConDE / PyData 2023 in this notebook 30_selection_v1.</p>"},{"location":"tasks/selection/#4-final-selection-in-pretalx","title":"4. Final Selection in Pretalx","text":"<p>Selecting the talks/tutorials for your conference is an iterative process. Maybe there are some talks you definitely want to select and others so bad you surely want to reject. Then there might be some you want to preliminarily accept or reject. Fortunately, Pretalx allows all that and Pytanis can pull that information to mark the rows in your GSheet with a certain colour. Here is an example on how this might look like.</p> <p>This example is also part of the notebook 30_selection_v1. Also be aware that after you accepted a talk or tutorial the author(s) must confirm. In practice, it happens also that accepted talks are withdrawn, so make sure you always keep a buffer of talks that haven't gotten any feedback yet to be able to accept some more.</p>"},{"location":"usage/gsheet/","title":"Google Sheets","text":""},{"location":"usage/gsheet/#basic-usage","title":"Basic Usage","text":"<p>Pytanis' Google Sheet client is really made for simplicity. Retrieving a worksheet of a Google sheet is as simple as: <pre><code>from pytanis import GSheetsClient\n\ngsheets_client = GSheetsClient()\ngsheet_df = gsheets_client.gsheet_as_df(SPREADSHEET_ID, WORKSHEET_NAME)\n</code></pre> where <code>SPREADSHEET_ID</code> is the ID taken from the spreadsheet's url, e.g. the ID is <code>17juVXM7V3p7Fgfi-9WkwPlMAYJB-DuxRhYCi_hastbB</code> if your spreadsheet's url is <code>https://docs.google.com/spreadsheets/d/17juVXM7V3p7Fgfi-9WkwPlMAYJB-DuxRhYCi_hastbB/edit#gid=1289752230</code>, and <code>WORKSHEET_NAME</code> is the name of the actual sheet, e.g. <code>Form responses 1</code>, that you find in the lower bar of your spreadsheet. The function <code>gsheet_as_df</code> returns a simple Pandas dataframe, which most users are surely familiar with.</p> <p>If you run the above script the first time, you will get a link to a Google consent page, or it will directly open up if you run this in a Jupyter notebook. Read it carefully and accept the access to your Google Sheet. This step is only necessary and everytime you change the access scope. For instance, if you also want to have write-access to a worksheet, run: <pre><code>gsheets_client = GSheetsClient(read_only=False)\ngsheets_client.recreate_token()\n</code></pre> and you will see the consent screen again, asking this time for write-access. Having accepted, you can now use <pre><code>gsheets_client.save_df_as_gsheet(subs_df, SPREADSHEET_ID, WORKSHEET_NAME)\n</code></pre> to upload a dataframe as Google sheet, overriding what's currently in there.</p> <p>Tip</p> <p>Google Sheet has a real useful version history that can be found under File \u00bb Version history \u00bb See version history. Even if you have accidentally overwritten you Google Sheet you can also restore an old version.</p>"},{"location":"usage/gsheet/#advanced-usage","title":"Advanced Usage","text":"<p>In case you want even more functionality and a dataframe is just not enough, you can use the <code>gsheet</code> method to get a Worksheet object or Spreadsheet object of GSpread. GSpread gives you full access to the API of Google Sheet and all the <code>gsheet_as_df</code> does is to basically use GSpread-Dataframe to convert this into a Pandas dataframe to simplify things for you. Also check out GSpread-Formatting if you want to use features like conditional formatting, colored cells, etc. Pytanis' google module gives you a complete reference of the current functionality within Pytanis but make sure to check out the GSpread ecosystem too as mentioned above.</p>"},{"location":"usage/installation/","title":"Getting Started","text":""},{"location":"usage/installation/#installation","title":"Installation","text":"<p>To install Pytanis simple run: <pre><code>pip install pytanis\n</code></pre> or to install all recommended additional dependencies: <pre><code>pip install 'pytanis[all]'\n</code></pre> Then create a configuration file and directory in your user's home directory. For Linux/MacOS/Unix use <code>~/.pytanis/config.toml</code> and for Windows <code>$HOME\\.pytanis\\config.toml</code>, where <code>$HOME</code> is e.g. <code>C:\\Users\\yourusername\\</code>. Use your favourite editor to open <code>config.toml</code> within the <code>.pytanis</code> directory and add the following content: <pre><code>[Pretalx]\napi_token = \"932ndsf9uk32nf9sdkn3454532nj32jn\"\napi_version = \"v1\"  # Optional, defaults to \"v1\" if not specified\n\n[Google]\nclient_secret_json = \"client_secret.json\"\ntoken_json = \"token.json\"\n\n[HelpDesk]\naccount = \"934jcjkdf-39df-9df-93kf-934jfhuuij39fd\"\nentity_id = \"email@host.com\"\ntoken = \"dal:Sx4id934C3Y-X934jldjdfjk\"\n</code></pre> where you need to replace the dummy values in the sections <code>[Pretalx]</code> and <code>[HelpDesk]</code> accordingly.</p> <p>Info</p> <p>You have to configure the credentials and tokens only for the sections you actually want to use. For instance, <code>[Pretalx]</code> and <code>[Google]</code> are the most important sections for users that want to interact with Pretalx and also Google Sheets. If for instance no access to HelpDesk is necessary, e.g. no mails need to be sent, you can just leave out the key/value pairs in the <code>[HelpDesk]</code> section.</p>"},{"location":"usage/installation/#retrieving-the-credentials-and-tokens","title":"Retrieving the Credentials and Tokens","text":"<ul> <li>Google: Follow the Python Quickstart for the Google API to generate and download the file <code>client_secret.json</code>. Move it to the <code>~/.pytanis</code> folder as <code>client_secret.json</code>. The file <code>token.json</code> will be automatically generated later. Note that <code>config.toml</code> references those two files relative to its own location.</li> <li>Pretalx: The API token can be found in the Pretalx user settings.</li> <li>HelpDesk: Log into the LiveChat Developer Console then go to Tools \u00bb Personal Access Tokens.   Hit Create new token +, enter a the name <code>Pytanis</code>, select all scopes and confirm. In the following screen   copy the <code>Account ID</code>, <code>Entity ID</code> and <code>Token</code> and paste them into <code>config.toml</code>.   In case there is any trouble with livechat, contact a helpdesk admin.</li> </ul>"},{"location":"usage/installation/#verifying-your-installation","title":"Verifying Your Installation","text":"<p>After installation and configuration, you can verify that everything is working correctly by running the integration tests. See the Testing Guide for detailed instructions on how to validate your setup and test API compatibility.</p>"},{"location":"usage/mail/","title":"Sending Mails","text":""},{"location":"usage/mail/#basic-usage","title":"Basic Usage","text":"<p>The usage of Pytanis' mail functionality is really simple. There are only three steps, you instantiate the mail client, create a mail object with your content and assemble a list of recipients.</p>"},{"location":"usage/mail/#team-agent-id","title":"Team &amp; Agent ID","text":"<p>But before we write an e-mail we have to determine the team and agent id so that the e-mails we send are assigned to the right roles as set up within HelpDesk. In order to do this, we can just do:</p> <p><pre><code>from pytanis import HelpDeskClient\n\nhelpdesk = HelpDeskClient()\n\nprint([agent.ID for agent in helpdesk.list_agents() if \"AGENTS EMAIL\" in agent.email])\nprint([team.ID for team in helpdesk.list_teams() if \"TEAM NAME\" in team.name])\n</code></pre> to find the right IDs with respect to the e-mail address <code>AGENTS EMAIL</code> and the corresponding <code>TEAM NAME</code>. We assume now that you stored those two values in <code>agent_id</code> and <code>team_id</code>, respectively.</p>"},{"location":"usage/mail/#defining-the-recipients","title":"Defining the Recipients","text":"<p>Defining the recipients means that you create a list of Recipient objects like: <pre><code>from pytanis.helpdesk import Recipient\n\nrecipients = [\n    Recipient(name=\"Peter Parker\", email=\"peter@parker.com\", address_as=\"Peter\"),\n    Recipient(name=\"Mary Watson\", email=\"marry-jane@watson.com\", address_as=\"Mary\"),\n]\n</code></pre> in most cases you will create this using a dataframe of some Google Sheet, and thus it will look more like: <pre><code>recipients = []\nrecip_df = google_sheet_df[[\"First name\", \"Last name\", \"E-mail\"]]\n\nfor _, row in recip_df.iterrows():\n    recipient = Recipient(\n        name=f\"{row['First name']} {row['Last name']}\",\n        email=row[\"E-mail\"],\n        address_as=row[\"First name\"],\n    )\n    recipients.append(recipient)\n</code></pre></p> <p>For more advanced usages, e.g. individual mails corresponding to certain individuals, you can use the <code>data</code> parameter of the <code>Recipient</code> that takes a dictionary. Let's say we want to add a special sentence later for Peter to pay his rent, we can define: <pre><code>Recipient(\n    name=\"Peter Parker\",\n    email=\"peter@parker.com\",\n    address_as=\"Peter\",\n    data={\"feedback\": \"Pay your rent, Parker!\"},\n)\n</code></pre> In the section, we will see how we can access this special attribute again.</p>"},{"location":"usage/mail/#writing-the-e-mail","title":"Writing the E-Mail","text":"<p>So now we can write the actual e-mail text, which just uses the basic string substitution functionality of Python: <pre><code>mail_body = \"\"\"\nHi {recipient.address_as}!\n\nThis is a message from the Program committee with the subject {mail.subject} :-)\n{recipient.data.feedback}\n\nThank you very much {recipient.address_as} for your support!\n\nAll the best,\nProgram Committee\n\"\"\"\n</code></pre> You see that we can use <code>recipient</code> and <code>mail</code> to access the attributes of the Recipient as well as the Mail object to personalize the e-mail.</p> <p>Now we create the Mail object with: <pre><code>from pytanis.helpdesk import Mail\n\nmail = Mail(\n    subject=\"Deadline is coming soon\",\n    text=mail_body,\n    team_id=team_id,\n    agent_id=agent_id,\n    status=\"solved\",\n    recipients=recipients,\n)\n</code></pre></p>"},{"location":"usage/mail/#sending-an-e-mail","title":"Sending an E-mail","text":"<p>Now we have everything assembled to send the e-mail with: <pre><code>from pytanis.helpdesk import MailClient\n\nmail_client = MailClient()\nresponses, errors = mail_client.send(mail, dry_run=True)\nassert not errors\n</code></pre> Having <code>dry_run=True</code> allows you to test you code and just print the resulting e-mails on your console to check if everything is like expected. Later set <code>dry_run=False</code> to actually send the e-mails via HelpDesk.</p> <p>The method <code>send</code> returns a list of successful <code>responses</code> and a hopefully empty list of <code>errors</code>. The <code>responses</code> list is a list of tuples where each tuple holds the Recipient as wells as the returned HelpDesk ticket. The <code>errors</code> list is a list of tuples with the Recipient and the corresponding exception object which occured when sending the mail to the recipient.</p>"},{"location":"usage/mail/#advanced-usage","title":"Advanced Usage","text":"<p>For more details, check out Pytanis' mail references and also the notebook 20_mail_to_reviewers_v1.</p> <p>Tip</p> <p>For contacting your (potential) speakers, Pretalx itself has pretty advanced templating and mailing features so there is no need to use this functionality here. Just make sure that you refer always to HelpDesk in your mails, so that you have a single point of managing mails and tickets.</p>"},{"location":"usage/optional_components/","title":"Optional Components","text":"<p>Starting with version 0.8.0, Pytanis has been refactored to make external dependencies optional. This allows you to install only the components you need, reducing the overall dependency footprint.</p>"},{"location":"usage/optional_components/#installation","title":"Installation","text":""},{"location":"usage/optional_components/#core-installation","title":"Core Installation","text":"<p>The core installation includes only the essential dependencies: <pre><code>pip install pytanis\n</code></pre></p> <p>This gives you: - Pretalx client for conference management - Local file storage (CSV/Excel) - Core utilities and configuration</p>"},{"location":"usage/optional_components/#optional-components_1","title":"Optional Components","text":"<p>Install additional components as needed:</p> <pre><code># Google Sheets support\npip install pytanis[google]\n\n# HelpDesk support\npip install pytanis[helpdesk]\n\n# Mailgun support\npip install pytanis[mailgun]\n\n# Jupyter notebooks and visualization\npip install pytanis[jupyter]\n\n# Schedule optimization\npip install pytanis[optimization]\n\n# Everything\npip install pytanis[all]\n</code></pre>"},{"location":"usage/optional_components/#storage-abstraction","title":"Storage Abstraction","text":"<p>Pytanis now provides a storage abstraction layer that allows you to choose between different storage backends.</p>"},{"location":"usage/optional_components/#configuration","title":"Configuration","text":"<p>Configure your storage provider in <code>config.toml</code>:</p> <pre><code>[Storage]\nprovider = \"google\"\nlocal_path = \"./data\"  # for local storage\n\n[Google]  # Only needed if using Google storage\nclient_secret_json = \"client_secret.json\"\ntoken_json = \"token.json\"\n</code></pre>"},{"location":"usage/optional_components/#google-sheets-storage","title":"Google Sheets Storage","text":"<p>When using Google Sheets: - Requires <code>pytanis[google]</code> installation - Uses the same API as local storage - Spreadsheet IDs are Google Sheets IDs</p>"},{"location":"usage/optional_components/#communication-abstraction","title":"Communication Abstraction","text":"<p>Pytanis provides abstraction for email and ticket systems.</p>"},{"location":"usage/optional_components/#configuration_1","title":"Configuration","text":"<pre><code>[Communication]\nemail_provider = \"mailgun\"  # or \"helpdesk\"\nticket_provider = \"helpdesk\"\n\n[Mailgun]  # If using Mailgun\ntoken = \"your-token\"\nfrom_address = \"noreply@example.com\"\n\n[HelpDesk]  # If using HelpDesk\naccount = \"your-account\"\nentity_id = \"your-entity\"\ntoken = \"your-token\"\n</code></pre>"},{"location":"usage/optional_components/#using-the-communication-api","title":"Using the Communication API","text":"<pre><code>from pytanis import get_mail_client\nfrom pytanis.communication import EmailMessage\n\n# Get mail client based on configuration\nmail_client = get_mail_client()\n\n# Create and send an email\nmessage = EmailMessage(\n    to=['recipient@example.com'],\n    subject='Conference Update',\n    body='Your talk has been accepted!',\n    html_body='&lt;p&gt;Your talk has been accepted!&lt;/p&gt;'\n)\n\nmessage_id = mail_client.send_email(message)\n</code></pre>"},{"location":"usage/optional_components/#backward-compatibility","title":"Backward Compatibility","text":"<p>The original APIs (<code>GSheetsClient</code>, <code>HelpDeskClient</code>) are still available and work as before. They are now lazy-loaded, meaning dependencies are only required when you actually use them.</p> <pre><code># This still works but requires pytanis[google]\nfrom pytanis import GSheetsClient\nclient = GSheetsClient()\n\n# This still works but requires pytanis[helpdesk]\nfrom pytanis import HelpDeskClient\nclient = HelpDeskClient()\n</code></pre>"},{"location":"usage/pretalx/","title":"Pretalx Client","text":""},{"location":"usage/pretalx/#basic-usage","title":"Basic Usage","text":"<p>Pytanis offers easy access to the Pretalx API and the usage is quite self-explanatory. Let's look at some basic example: <pre><code>from pytanis import PretalxClient\n\nevent_name = \"pyconde-pydata-2025\"\n\npretalx_client = PretalxClient()\nsubs_count, subs = pretalx_client.submissions(event_name)\n</code></pre> This simple code will return the total number of submissions as <code>subs_count</code> and an iterator of all submissions <code>subs</code>. When iterating over <code>subs</code> new requests will be made internally to the Pretalx server to retrieve more result pages. This method of retrieving partial results is called pagination. Quite often you will just use <code>subs = list(subs)</code> to retrieve all submissions and get a list instead for easier handling. If you want to retrieve always all results directly, i.e. in a blocking way, you can tell this to the client via <code>PretalxClient(blocking=True)</code> but be aware that you must still call <code>subs = list(subs)</code>.</p> <p>All endpoints of the Pretalx API are implemented in Pytanis and the method name corresponds to the name of the endpoint. Additional parameters can be passed using the <code>params</code> argument like e.g.: <pre><code>subs_count, subs = pretalx_client.submissions(\n    event_name, params={\"questions\": \"all\", \"state\": \"submitted\"}\n)\n</code></pre> Check the Pretalx API for a list of options.</p>"},{"location":"usage/pretalx/#api-version-configuration","title":"API Version Configuration","text":"<p>Pytanis supports configuring the Pretalx API version through the configuration file. By default, it uses API version \"v1\", but you can change this if needed:</p> <pre><code>[Pretalx]\napi_token = \"your-api-token\"\napi_version = \"v2\"  # Use a different API version\n</code></pre> <p>The <code>api_version</code> setting is optional. If not specified in your <code>~/.pytanis/config.toml</code>, it will default to \"v1\". This version is sent in the <code>Pretalx-Version</code> header with each API request.</p>"},{"location":"usage/pretalx/#advanced-usage","title":"Advanced Usage","text":"<p>Find out more about the client's capabilities, e.g. throttling, by looking at Pytanis' reference of the pretalx client module.</p>"},{"location":"usage/testing/","title":"Testing","text":"<p>This guide covers testing pytanis, including setup, running tests with hatch, and configuration options.</p>"},{"location":"usage/testing/#setup","title":"Setup","text":"<p>Install pytanis with development dependencies:</p> <pre><code># Clone the repository\ngit clone https://github.com/pioneershub/pytanis.git\ncd pytanis\n\n# Install with hatch (recommended)\npip install hatch\nhatch env create\n\n# Or install directly with pip\npip install -e \".[all]\"\npip install pytest pytest-cov pytest-mock pytest-vcr\n</code></pre>"},{"location":"usage/testing/#running-tests","title":"Running Tests","text":""},{"location":"usage/testing/#using-hatch-recommended","title":"Using Hatch (Recommended)","text":"<p>Hatch provides pre-configured test environments:</p> <pre><code># Run all tests with coverage\nhatch run cov\n\n# Run tests without coverage\nhatch run no-cov\n\n# Debug mode with breakpoints\nhatch run debug\n\n# Run integration tests\nhatch run integration\n</code></pre>"},{"location":"usage/testing/#direct-pytest-usage","title":"Direct pytest Usage","text":"<pre><code># Run all tests\npytest\n\n# Run with coverage report\npytest --cov=pytanis --cov-report=term-missing\n\n# Run specific test file\npytest tests/pretalx/test_client.py\n\n# Run tests matching pattern\npytest -k \"test_event\"\n\n# Exclude integration tests\npytest -m \"not integration\"\n</code></pre>"},{"location":"usage/testing/#configuration","title":"Configuration","text":""},{"location":"usage/testing/#environment-variables","title":"Environment Variables","text":"<p>When local configuration is not available or desired, use environment variables:</p> <pre><code># Pretalx API configuration\nexport PRETALX_API_TOKEN=\"your-api-token\"\nexport PRETALX_TEST_EVENT=\"event-slug\"  # Default: pyconde-pydata-2025\n\n# Run integration tests with environment variables\nhatch run integration\n</code></pre>"},{"location":"usage/testing/#local-configuration","title":"Local Configuration","text":"<p>Create a <code>config.toml</code> file in your project root:</p> <pre><code>[Pretalx]\napi_token = \"your-api-token\"\n\n[Google]\nclient_secret_json = \"path/to/client_secret.json\"\ntoken_json = \"token.json\"\n\n[HelpDesk]\naccount = \"account-id\"\nentity_id = \"email@example.com\"\ntoken = \"helpdesk-token\"\n</code></pre>"},{"location":"usage/testing/#test-types","title":"Test Types","text":""},{"location":"usage/testing/#unit-tests","title":"Unit Tests","text":"<p>Standard tests that don't require external services:</p> <pre><code># Run unit tests only\npytest tests/ -m \"not integration\"\n</code></pre>"},{"location":"usage/testing/#integration-tests","title":"Integration Tests","text":"<p>Tests that interact with live APIs (marked with <code>@pytest.mark.integration</code>):</p> <pre><code># Run integration tests only\npytest -m integration\n\n# Or use hatch\nhatch run integration\n</code></pre>"},{"location":"usage/testing/#coverage-reports","title":"Coverage Reports","text":"<p>Generate detailed coverage reports:</p> <pre><code># Terminal report\nhatch run cov\n\n# HTML report\npytest --cov=pytanis --cov-report=html\n# Open htmlcov/index.html in browser\n\n# XML report for CI\nhatch run ci\n</code></pre>"},{"location":"usage/testing/#test-structure","title":"Test Structure","text":"<pre><code>tests/\n\u251c\u2500\u2500 conftest.py          # Shared fixtures\n\u251c\u2500\u2500 test_config.toml     # Test configuration\n\u251c\u2500\u2500 pretalx/\n\u2502   \u251c\u2500\u2500 test_client.py   # Client unit tests\n\u2502   \u251c\u2500\u2500 test_integration.py  # Integration tests\n\u2502   \u2514\u2500\u2500 test_config.py   # Configuration tests\n\u2514\u2500\u2500 helpdesk/\n    \u2514\u2500\u2500 test_mail.py     # HelpDesk tests\n</code></pre>"},{"location":"usage/testing/#common-commands","title":"Common Commands","text":"<pre><code># Quick test during development\nhatch run no-cov tests/pretalx/test_client.py\n\n# Full test suite before commits\nhatch run cov\n\n# Integration test with custom event\nPRETALX_TEST_EVENT=\"my-event\" hatch run integration\n\n# Debug failing test\nhatch run debug tests/pretalx/test_client.py::test_specific_case\n</code></pre>"},{"location":"usage/testing/#troubleshooting","title":"Troubleshooting","text":""},{"location":"usage/testing/#missing-dependencies","title":"Missing Dependencies","text":"<pre><code># Ensure all test dependencies are installed\nhatch env prune\nhatch env create\n</code></pre>"},{"location":"usage/testing/#authentication-errors","title":"Authentication Errors","text":"<ul> <li>Verify <code>PRETALX_API_TOKEN</code> is set correctly</li> <li>Check token has necessary permissions</li> <li>Ensure event slug exists and is accessible</li> </ul>"},{"location":"usage/testing/#slow-tests","title":"Slow Tests","text":"<ul> <li>Use <code>-x</code> to stop on first failure</li> <li>Run specific tests with <code>-k pattern</code></li> <li>Skip integration tests for faster feedback</li> </ul>"},{"location":"usage/testing/#sslcertificate-issues","title":"SSL/Certificate Issues","text":"<ul> <li>Update system certificates</li> <li>Check corporate proxy settings</li> <li>Set <code>REQUESTS_CA_BUNDLE</code> if needed</li> </ul>"}]}